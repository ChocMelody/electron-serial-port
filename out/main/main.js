"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const require$$1$5 = require("electron");
const require$$0$6 = require("path");
const require$$0$4 = require("stream");
const require$$1$1 = require("util");
const require$$5$1 = require("perf_hooks");
const require$$0$5 = require("crypto");
const require$$1$2 = require("os");
const require$$0$7 = require("tty");
const require$$1$3 = require("fs");
const require$$4$1 = require("net");
const require$$0$8 = require("events");
const zlib = require("zlib");
const require$$0$9 = require("buffer");
const require$$1$4 = require("string_decoder");
const require$$8 = require("querystring");
const require$$0$a = require("url");
const require$$7$2 = require("http");
const require$$8$1 = require("https");
const require$$8$2 = require("repl");
const require$$4$2 = require("assert");
const require$$0$b = require("child_process");
const http2 = require("http2");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var core$d = {};
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t2 = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t2[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t2[p[i]] = s[p[i]];
    }
  return t2;
}
function __decorate(decorators2, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators2, target, key, desc);
  else
    for (var i = decorators2.length - 1; i >= 0; i--)
      if (d = decorators2[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators2, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators2.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators2[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
};
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle2(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n](v), settle2(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle2(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
};
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault$4(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state2, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
}
function __classPrivateFieldSet(receiver, state2, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state2.set(receiver, value), value;
}
function __classPrivateFieldIn(state2, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault: __importDefault$4,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault: __importDefault$4,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect$1;
(function(Reflect2) {
  (function(factory2) {
    var root = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect2);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect2;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory2(exporter);
    function makeExporter(target, previous) {
      return function(key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
        }
        if (previous)
          previous(key, value);
      };
    }
  })(function(exporter) {
    var hasOwn2 = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map2, key) {
        return hasOwn2.call(map2, key);
      } : function(map2, key) {
        return key in map2;
      },
      get: downLevel ? function(map2, key) {
        return hasOwn2.call(map2, key) ? map2[key] : void 0;
      } : function(map2, key) {
        return map2[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process["env"] && process["env"]["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var Metadata = new _WeakMap();
    function decorate(decorators2, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators2))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators2, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators2))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators2, target);
      }
    }
    exporter("decorate", decorate);
    function metadata2(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata2);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      if (!metadataMap.delete(metadataKey))
        return false;
      if (metadataMap.size > 0)
        return true;
      var targetMetadata = Metadata.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0)
        return true;
      Metadata.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators2, target) {
      for (var i = decorators2.length - 1; i >= 0; --i) {
        var decorator = decorators2[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators2, target, propertyKey, descriptor) {
      for (var i = decorators2.length - 1; i >= 0; --i) {
        var decorator = decorators2[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      var targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return void 0;
        targetMetadata = new _Map();
        Metadata.set(O, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return void 0;
        metadataMap = new _Map();
        targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn3 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn3)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn3 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn3)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return void 0;
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        true
      );
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O, P) {
      var keys = [];
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return keys;
      var keysObj = metadataMap.keys();
      var iterator2 = GetIterator(keysObj);
      var k = 0;
      while (true) {
        var next = IteratorStep(iterator2);
        if (!next) {
          keys.length = k;
          return keys;
        }
        var nextValue = IteratorValue(next);
        try {
          keys[k] = nextValue;
        } catch (e) {
          try {
            IteratorClose(iterator2);
          } finally {
            throw e;
          }
        }
        k++;
      }
    }
    function Type2(x) {
      if (x === null)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return x === void 0;
    }
    function IsNull(x) {
      return x === null;
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type2(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type2(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function GetMethod(V, P) {
      var func = V[P];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator2 = method.call(obj);
      if (!IsObject(iterator2))
        throw new TypeError();
      return iterator2;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator2) {
      var result = iterator2.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator2) {
      var f = iterator2["return"];
      if (f)
        f.call(iterator2);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype2 = O.prototype;
      var prototypeProto = prototype2 && Object.getPrototypeOf(prototype2);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error2) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error2;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }()
      );
      return (
        /** @class */
        function() {
          function Map2() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map2.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map2.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map2.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map2.prototype.set = function(key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value;
            return this;
          };
          Map2.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (key === this._cacheKey) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map2.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map2.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map2.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map2.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map2.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map2.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map2.prototype._find = function(key, insert) {
            if (this._cacheKey !== key) {
              this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map2;
        }()
      );
      function getKey(key, _) {
        return key;
      }
      function getValue(_, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return (
        /** @class */
        function() {
          function Set2() {
            this._map = new _Map();
          }
          Object.defineProperty(Set2.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set2.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set2.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set2.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set2.prototype.clear = function() {
            this._map.clear();
          };
          Set2.prototype.keys = function() {
            return this._map.keys();
          };
          Set2.prototype.values = function() {
            return this._map.values();
          };
          Set2.prototype.entries = function() {
            return this._map.entries();
          };
          Set2.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set2.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set2;
        }()
      );
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn2.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer2, size) {
        for (var i = 0; i < size; ++i)
          buffer2[i] = Math.random() * 255 | 0;
        return buffer2;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined")
            return crypto.getRandomValues(new Uint8Array(size));
          if (typeof msCrypto !== "undefined")
            return msCrypto.getRandomValues(new Uint8Array(size));
          return FillRandomBytes(new Uint8Array(size), size);
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect$1 || (Reflect$1 = {}));
var adapters$2 = {};
var httpAdapter$1 = {};
var hasRequiredHttpAdapter;
function requireHttpAdapter() {
  if (hasRequiredHttpAdapter)
    return httpAdapter$1;
  hasRequiredHttpAdapter = 1;
  Object.defineProperty(httpAdapter$1, "__esModule", { value: true });
  httpAdapter$1.AbstractHttpAdapter = void 0;
  class AbstractHttpAdapter {
    constructor(instance) {
      this.instance = instance;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    async init() {
    }
    use(...args2) {
      return this.instance.use(...args2);
    }
    get(...args2) {
      return this.instance.get(...args2);
    }
    post(...args2) {
      return this.instance.post(...args2);
    }
    head(...args2) {
      return this.instance.head(...args2);
    }
    delete(...args2) {
      return this.instance.delete(...args2);
    }
    put(...args2) {
      return this.instance.put(...args2);
    }
    patch(...args2) {
      return this.instance.patch(...args2);
    }
    all(...args2) {
      return this.instance.all(...args2);
    }
    options(...args2) {
      return this.instance.options(...args2);
    }
    listen(port, hostname, callback) {
      return this.instance.listen(port, hostname, callback);
    }
    getHttpServer() {
      return this.httpServer;
    }
    setHttpServer(httpServer) {
      this.httpServer = httpServer;
    }
    setInstance(instance) {
      this.instance = instance;
    }
    getInstance() {
      return this.instance;
    }
  }
  httpAdapter$1.AbstractHttpAdapter = AbstractHttpAdapter;
  return httpAdapter$1;
}
var hasRequiredAdapters$1;
function requireAdapters$1() {
  if (hasRequiredAdapters$1)
    return adapters$2;
  hasRequiredAdapters$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireHttpAdapter(), exports2);
  })(adapters$2);
  return adapters$2;
}
var applicationConfig = {};
var hasRequiredApplicationConfig;
function requireApplicationConfig() {
  if (hasRequiredApplicationConfig)
    return applicationConfig;
  hasRequiredApplicationConfig = 1;
  Object.defineProperty(applicationConfig, "__esModule", { value: true });
  applicationConfig.ApplicationConfig = void 0;
  class ApplicationConfig {
    constructor(ioAdapter = null) {
      this.ioAdapter = ioAdapter;
      this.globalPrefix = "";
      this.globalPrefixOptions = {};
      this.globalPipes = [];
      this.globalFilters = [];
      this.globalInterceptors = [];
      this.globalGuards = [];
      this.globalRequestPipes = [];
      this.globalRequestFilters = [];
      this.globalRequestInterceptors = [];
      this.globalRequestGuards = [];
    }
    setGlobalPrefix(prefix) {
      this.globalPrefix = prefix;
    }
    getGlobalPrefix() {
      return this.globalPrefix;
    }
    setGlobalPrefixOptions(options) {
      this.globalPrefixOptions = options;
    }
    getGlobalPrefixOptions() {
      return this.globalPrefixOptions;
    }
    setIoAdapter(ioAdapter) {
      this.ioAdapter = ioAdapter;
    }
    getIoAdapter() {
      return this.ioAdapter;
    }
    addGlobalPipe(pipe2) {
      this.globalPipes.push(pipe2);
    }
    useGlobalPipes(...pipes2) {
      this.globalPipes = this.globalPipes.concat(pipes2);
    }
    getGlobalFilters() {
      return this.globalFilters;
    }
    addGlobalFilter(filter3) {
      this.globalFilters.push(filter3);
    }
    useGlobalFilters(...filters) {
      this.globalFilters = this.globalFilters.concat(filters);
    }
    getGlobalPipes() {
      return this.globalPipes;
    }
    getGlobalInterceptors() {
      return this.globalInterceptors;
    }
    addGlobalInterceptor(interceptor) {
      this.globalInterceptors.push(interceptor);
    }
    useGlobalInterceptors(...interceptors2) {
      this.globalInterceptors = this.globalInterceptors.concat(interceptors2);
    }
    getGlobalGuards() {
      return this.globalGuards;
    }
    addGlobalGuard(guard) {
      this.globalGuards.push(guard);
    }
    useGlobalGuards(...guards2) {
      this.globalGuards = this.globalGuards.concat(guards2);
    }
    addGlobalRequestInterceptor(wrapper) {
      this.globalRequestInterceptors.push(wrapper);
    }
    getGlobalRequestInterceptors() {
      return this.globalRequestInterceptors;
    }
    addGlobalRequestPipe(wrapper) {
      this.globalRequestPipes.push(wrapper);
    }
    getGlobalRequestPipes() {
      return this.globalRequestPipes;
    }
    addGlobalRequestFilter(wrapper) {
      this.globalRequestFilters.push(wrapper);
    }
    getGlobalRequestFilters() {
      return this.globalRequestFilters;
    }
    addGlobalRequestGuard(wrapper) {
      this.globalRequestGuards.push(wrapper);
    }
    getGlobalRequestGuards() {
      return this.globalRequestGuards;
    }
    enableVersioning(options) {
      if (Array.isArray(options.defaultVersion)) {
        options.defaultVersion = Array.from(new Set(options.defaultVersion));
      }
      this.versioningOptions = options;
    }
    getVersioning() {
      return this.versioningOptions;
    }
  }
  applicationConfig.ApplicationConfig = ApplicationConfig;
  return applicationConfig;
}
var constants$7 = {};
var hasRequiredConstants$5;
function requireConstants$5() {
  if (hasRequiredConstants$5)
    return constants$7;
  hasRequiredConstants$5 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ENHANCER_TOKEN_TO_SUBTYPE_MAP = exports2.APP_FILTER = exports2.APP_GUARD = exports2.APP_PIPE = exports2.APP_INTERCEPTOR = exports2.MESSAGES = void 0;
    exports2.MESSAGES = {
      APPLICATION_START: `Starting Nest application...`,
      APPLICATION_READY: `Nest application successfully started`,
      MICROSERVICE_READY: `Nest microservice successfully started`,
      UNKNOWN_EXCEPTION_MESSAGE: "Internal server error",
      ERROR_DURING_SHUTDOWN: "Error happened during shutdown",
      CALL_LISTEN_FIRST: "app.listen() needs to be called before calling app.getUrl()"
    };
    exports2.APP_INTERCEPTOR = "APP_INTERCEPTOR";
    exports2.APP_PIPE = "APP_PIPE";
    exports2.APP_GUARD = "APP_GUARD";
    exports2.APP_FILTER = "APP_FILTER";
    exports2.ENHANCER_TOKEN_TO_SUBTYPE_MAP = {
      [exports2.APP_GUARD]: "guard",
      [exports2.APP_INTERCEPTOR]: "interceptor",
      [exports2.APP_PIPE]: "pipe",
      [exports2.APP_FILTER]: "filter"
    };
  })(constants$7);
  return constants$7;
}
var discovery = {};
var discoveryModule = {};
var common$9 = {};
var cache = {};
var cache_constants = {};
var cache_moduleDefinition = {};
var moduleUtils = {};
var configurableModule_builder = {};
var logger_service = {};
var core$c = {};
var bind_decorator = {};
var hasRequiredBind_decorator;
function requireBind_decorator() {
  if (hasRequiredBind_decorator)
    return bind_decorator;
  hasRequiredBind_decorator = 1;
  Object.defineProperty(bind_decorator, "__esModule", { value: true });
  bind_decorator.Bind = void 0;
  function Bind(...decorators2) {
    return (target, key, descriptor) => {
      decorators2.forEach((fn, index) => fn(target, key, index));
      return descriptor;
    };
  }
  bind_decorator.Bind = Bind;
  return bind_decorator;
}
var catch_decorator = {};
var constants$6 = {};
var hasRequiredConstants$4;
function requireConstants$4() {
  if (hasRequiredConstants$4)
    return constants$6;
  hasRequiredConstants$4 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ENTRY_PROVIDER_WATERMARK = exports2.CATCH_WATERMARK = exports2.CONTROLLER_WATERMARK = exports2.INJECTABLE_WATERMARK = exports2.VERSION_METADATA = exports2.SSE_METADATA = exports2.RESPONSE_PASSTHROUGH_METADATA = exports2.REDIRECT_METADATA = exports2.HEADERS_METADATA = exports2.MODULE_PATH = exports2.HTTP_CODE_METADATA = exports2.RENDER_METADATA = exports2.ENHANCER_KEY_TO_SUBTYPE_MAP = exports2.EXCEPTION_FILTERS_METADATA = exports2.INTERCEPTORS_METADATA = exports2.GUARDS_METADATA = exports2.PIPES_METADATA = exports2.FILTER_CATCH_EXCEPTIONS = exports2.CUSTOM_ROUTE_AGRS_METADATA = exports2.CUSTOM_ROUTE_ARGS_METADATA = exports2.ROUTE_ARGS_METADATA = exports2.METHOD_METADATA = exports2.SCOPE_OPTIONS_METADATA = exports2.OPTIONAL_PROPERTY_DEPS_METADATA = exports2.PROPERTY_DEPS_METADATA = exports2.OPTIONAL_DEPS_METADATA = exports2.SELF_DECLARED_DEPS_METADATA = exports2.PARAMTYPES_METADATA = exports2.PATH_METADATA = exports2.HOST_METADATA = exports2.GLOBAL_MODULE_METADATA = exports2.MODULE_METADATA = void 0;
    exports2.MODULE_METADATA = {
      IMPORTS: "imports",
      PROVIDERS: "providers",
      CONTROLLERS: "controllers",
      EXPORTS: "exports"
    };
    exports2.GLOBAL_MODULE_METADATA = "__module:global__";
    exports2.HOST_METADATA = "host";
    exports2.PATH_METADATA = "path";
    exports2.PARAMTYPES_METADATA = "design:paramtypes";
    exports2.SELF_DECLARED_DEPS_METADATA = "self:paramtypes";
    exports2.OPTIONAL_DEPS_METADATA = "optional:paramtypes";
    exports2.PROPERTY_DEPS_METADATA = "self:properties_metadata";
    exports2.OPTIONAL_PROPERTY_DEPS_METADATA = "optional:properties_metadata";
    exports2.SCOPE_OPTIONS_METADATA = "scope:options";
    exports2.METHOD_METADATA = "method";
    exports2.ROUTE_ARGS_METADATA = "__routeArguments__";
    exports2.CUSTOM_ROUTE_ARGS_METADATA = "__customRouteArgs__";
    exports2.CUSTOM_ROUTE_AGRS_METADATA = exports2.CUSTOM_ROUTE_ARGS_METADATA;
    exports2.FILTER_CATCH_EXCEPTIONS = "__filterCatchExceptions__";
    exports2.PIPES_METADATA = "__pipes__";
    exports2.GUARDS_METADATA = "__guards__";
    exports2.INTERCEPTORS_METADATA = "__interceptors__";
    exports2.EXCEPTION_FILTERS_METADATA = "__exceptionFilters__";
    exports2.ENHANCER_KEY_TO_SUBTYPE_MAP = {
      [exports2.GUARDS_METADATA]: "guard",
      [exports2.INTERCEPTORS_METADATA]: "interceptor",
      [exports2.PIPES_METADATA]: "pipe",
      [exports2.EXCEPTION_FILTERS_METADATA]: "filter"
    };
    exports2.RENDER_METADATA = "__renderTemplate__";
    exports2.HTTP_CODE_METADATA = "__httpCode__";
    exports2.MODULE_PATH = "__module_path__";
    exports2.HEADERS_METADATA = "__headers__";
    exports2.REDIRECT_METADATA = "__redirect__";
    exports2.RESPONSE_PASSTHROUGH_METADATA = "__responsePassthrough__";
    exports2.SSE_METADATA = "__sse__";
    exports2.VERSION_METADATA = "__version__";
    exports2.INJECTABLE_WATERMARK = "__injectable__";
    exports2.CONTROLLER_WATERMARK = "__controller__";
    exports2.CATCH_WATERMARK = "__catch__";
    exports2.ENTRY_PROVIDER_WATERMARK = "__entryProvider__";
  })(constants$6);
  return constants$6;
}
var hasRequiredCatch_decorator;
function requireCatch_decorator() {
  if (hasRequiredCatch_decorator)
    return catch_decorator;
  hasRequiredCatch_decorator = 1;
  Object.defineProperty(catch_decorator, "__esModule", { value: true });
  catch_decorator.Catch = void 0;
  const constants_1 = requireConstants$4();
  function Catch(...exceptions2) {
    return (target) => {
      Reflect.defineMetadata(constants_1.CATCH_WATERMARK, true, target);
      Reflect.defineMetadata(constants_1.FILTER_CATCH_EXCEPTIONS, exceptions2, target);
    };
  }
  catch_decorator.Catch = Catch;
  return catch_decorator;
}
var controller_decorator = {};
var shared_utils = {};
var hasRequiredShared_utils;
function requireShared_utils() {
  if (hasRequiredShared_utils)
    return shared_utils;
  hasRequiredShared_utils = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSymbol = exports2.isEmpty = exports2.isNil = exports2.isConstructor = exports2.isNumber = exports2.isString = exports2.isFunction = exports2.stripEndSlash = exports2.normalizePath = exports2.addLeadingSlash = exports2.isPlainObject = exports2.isObject = exports2.isUndefined = void 0;
    const isUndefined2 = (obj) => typeof obj === "undefined";
    exports2.isUndefined = isUndefined2;
    const isObject2 = (fn) => !(0, exports2.isNil)(fn) && typeof fn === "object";
    exports2.isObject = isObject2;
    const isPlainObject2 = (fn) => {
      if (!(0, exports2.isObject)(fn)) {
        return false;
      }
      const proto = Object.getPrototypeOf(fn);
      if (proto === null) {
        return true;
      }
      const ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    };
    exports2.isPlainObject = isPlainObject2;
    const addLeadingSlash = (path2) => path2 && typeof path2 === "string" ? path2.charAt(0) !== "/" ? "/" + path2 : path2 : "";
    exports2.addLeadingSlash = addLeadingSlash;
    const normalizePath = (path2) => path2 ? path2.startsWith("/") ? ("/" + path2.replace(/\/+$/, "")).replace(/\/+/g, "/") : "/" + path2.replace(/\/+$/, "") : "/";
    exports2.normalizePath = normalizePath;
    const stripEndSlash = (path2) => path2[path2.length - 1] === "/" ? path2.slice(0, path2.length - 1) : path2;
    exports2.stripEndSlash = stripEndSlash;
    const isFunction2 = (val) => typeof val === "function";
    exports2.isFunction = isFunction2;
    const isString2 = (val) => typeof val === "string";
    exports2.isString = isString2;
    const isNumber2 = (val) => typeof val === "number";
    exports2.isNumber = isNumber2;
    const isConstructor = (val) => val === "constructor";
    exports2.isConstructor = isConstructor;
    const isNil = (val) => (0, exports2.isUndefined)(val) || val === null;
    exports2.isNil = isNil;
    const isEmpty2 = (array) => !(array && array.length > 0);
    exports2.isEmpty = isEmpty2;
    const isSymbol = (val) => typeof val === "symbol";
    exports2.isSymbol = isSymbol;
  })(shared_utils);
  return shared_utils;
}
var hasRequiredController_decorator;
function requireController_decorator() {
  if (hasRequiredController_decorator)
    return controller_decorator;
  hasRequiredController_decorator = 1;
  Object.defineProperty(controller_decorator, "__esModule", { value: true });
  controller_decorator.Controller = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  function Controller(prefixOrOptions) {
    const defaultPath = "/";
    const [path2, host, scopeOptions, versionOptions] = (0, shared_utils_1.isUndefined)(prefixOrOptions) ? [defaultPath, void 0, void 0, void 0] : (0, shared_utils_1.isString)(prefixOrOptions) || Array.isArray(prefixOrOptions) ? [prefixOrOptions, void 0, void 0, void 0] : [
      prefixOrOptions.path || defaultPath,
      prefixOrOptions.host,
      { scope: prefixOrOptions.scope, durable: prefixOrOptions.durable },
      Array.isArray(prefixOrOptions.version) ? Array.from(new Set(prefixOrOptions.version)) : prefixOrOptions.version
    ];
    return (target) => {
      Reflect.defineMetadata(constants_1.CONTROLLER_WATERMARK, true, target);
      Reflect.defineMetadata(constants_1.PATH_METADATA, path2, target);
      Reflect.defineMetadata(constants_1.HOST_METADATA, host, target);
      Reflect.defineMetadata(constants_1.SCOPE_OPTIONS_METADATA, scopeOptions, target);
      Reflect.defineMetadata(constants_1.VERSION_METADATA, versionOptions, target);
    };
  }
  controller_decorator.Controller = Controller;
  return controller_decorator;
}
var dependencies_decorator = {};
var hasRequiredDependencies_decorator;
function requireDependencies_decorator() {
  if (hasRequiredDependencies_decorator)
    return dependencies_decorator;
  hasRequiredDependencies_decorator = 1;
  Object.defineProperty(dependencies_decorator, "__esModule", { value: true });
  dependencies_decorator.Dependencies = dependencies_decorator.flatten = void 0;
  const constants_1 = requireConstants$4();
  function flatten2(arr) {
    const flat = [].concat(...arr);
    return flat.some(Array.isArray) ? flatten2(flat) : flat;
  }
  dependencies_decorator.flatten = flatten2;
  const Dependencies = (...dependencies2) => {
    const flattenDeps = flatten2(dependencies2);
    return (target) => {
      Reflect.defineMetadata(constants_1.PARAMTYPES_METADATA, flattenDeps, target);
    };
  };
  dependencies_decorator.Dependencies = Dependencies;
  return dependencies_decorator;
}
var exceptionFilters_decorator = {};
var extendMetadata_util = {};
var hasRequiredExtendMetadata_util;
function requireExtendMetadata_util() {
  if (hasRequiredExtendMetadata_util)
    return extendMetadata_util;
  hasRequiredExtendMetadata_util = 1;
  Object.defineProperty(extendMetadata_util, "__esModule", { value: true });
  extendMetadata_util.extendArrayMetadata = void 0;
  function extendArrayMetadata(key, metadata2, target) {
    const previousValue = Reflect.getMetadata(key, target) || [];
    const value = [...previousValue, ...metadata2];
    Reflect.defineMetadata(key, value, target);
  }
  extendMetadata_util.extendArrayMetadata = extendArrayMetadata;
  return extendMetadata_util;
}
var validateEach_util = {};
var hasRequiredValidateEach_util;
function requireValidateEach_util() {
  if (hasRequiredValidateEach_util)
    return validateEach_util;
  hasRequiredValidateEach_util = 1;
  Object.defineProperty(validateEach_util, "__esModule", { value: true });
  validateEach_util.validateEach = validateEach_util.InvalidDecoratorItemException = void 0;
  class InvalidDecoratorItemException extends Error {
    constructor(decorator, item, context) {
      const message = `Invalid ${item} passed to ${decorator}() decorator (${context}).`;
      super(message);
      this.msg = message;
    }
    what() {
      return this.msg;
    }
  }
  validateEach_util.InvalidDecoratorItemException = InvalidDecoratorItemException;
  function validateEach(context, arr, predicate, decorator, item) {
    if (!context || !context.name) {
      return true;
    }
    const errors2 = arr.some((str) => !predicate(str));
    if (errors2) {
      throw new InvalidDecoratorItemException(decorator, item, context.name);
    }
    return true;
  }
  validateEach_util.validateEach = validateEach;
  return validateEach_util;
}
var hasRequiredExceptionFilters_decorator;
function requireExceptionFilters_decorator() {
  if (hasRequiredExceptionFilters_decorator)
    return exceptionFilters_decorator;
  hasRequiredExceptionFilters_decorator = 1;
  Object.defineProperty(exceptionFilters_decorator, "__esModule", { value: true });
  exceptionFilters_decorator.UseFilters = void 0;
  const constants_1 = requireConstants$4();
  const extend_metadata_util_1 = requireExtendMetadata_util();
  const shared_utils_1 = requireShared_utils();
  const validate_each_util_1 = requireValidateEach_util();
  const UseFilters = (...filters) => addExceptionFiltersMetadata(...filters);
  exceptionFilters_decorator.UseFilters = UseFilters;
  function addExceptionFiltersMetadata(...filters) {
    return (target, key, descriptor) => {
      const isFilterValid = (filter3) => filter3 && ((0, shared_utils_1.isFunction)(filter3) || (0, shared_utils_1.isFunction)(filter3.catch));
      if (descriptor) {
        (0, validate_each_util_1.validateEach)(target.constructor, filters, isFilterValid, "@UseFilters", "filter");
        (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.EXCEPTION_FILTERS_METADATA, filters, descriptor.value);
        return descriptor;
      }
      (0, validate_each_util_1.validateEach)(target, filters, isFilterValid, "@UseFilters", "filter");
      (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.EXCEPTION_FILTERS_METADATA, filters, target);
      return target;
    };
  }
  return exceptionFilters_decorator;
}
var inject_decorator = {};
var hasRequiredInject_decorator;
function requireInject_decorator() {
  if (hasRequiredInject_decorator)
    return inject_decorator;
  hasRequiredInject_decorator = 1;
  Object.defineProperty(inject_decorator, "__esModule", { value: true });
  inject_decorator.Inject = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  function Inject(token) {
    return (target, key, index) => {
      const type2 = token || Reflect.getMetadata("design:type", target, key);
      if (!(0, shared_utils_1.isUndefined)(index)) {
        let dependencies2 = Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, target) || [];
        dependencies2 = [...dependencies2, { index, param: type2 }];
        Reflect.defineMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, dependencies2, target);
        return;
      }
      let properties2 = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, target.constructor) || [];
      properties2 = [...properties2, { key, type: type2 }];
      Reflect.defineMetadata(constants_1.PROPERTY_DEPS_METADATA, properties2, target.constructor);
    };
  }
  inject_decorator.Inject = Inject;
  return inject_decorator;
}
var injectable_decorator = {};
var dist$j = {};
var hasRequiredDist$1;
function requireDist$1() {
  if (hasRequiredDist$1)
    return dist$j;
  hasRequiredDist$1 = 1;
  var IDX = 256, HEX = [], SIZE = 256, BUFFER;
  while (IDX--)
    HEX[IDX] = (IDX + 256).toString(16).substring(1);
  function uid(len) {
    var i = 0, tmp = len || 11;
    if (!BUFFER || IDX + tmp > SIZE * 2) {
      for (BUFFER = "", IDX = 0; i < SIZE; i++) {
        BUFFER += HEX[Math.random() * 256 | 0];
      }
    }
    return BUFFER.substring(IDX, IDX++ + tmp);
  }
  dist$j.uid = uid;
  return dist$j;
}
var hasRequiredInjectable_decorator;
function requireInjectable_decorator() {
  if (hasRequiredInjectable_decorator)
    return injectable_decorator;
  hasRequiredInjectable_decorator = 1;
  Object.defineProperty(injectable_decorator, "__esModule", { value: true });
  injectable_decorator.mixin = injectable_decorator.Injectable = void 0;
  const uid_1 = requireDist$1();
  const constants_1 = requireConstants$4();
  function Injectable(options) {
    return (target) => {
      Reflect.defineMetadata(constants_1.INJECTABLE_WATERMARK, true, target);
      Reflect.defineMetadata(constants_1.SCOPE_OPTIONS_METADATA, options, target);
    };
  }
  injectable_decorator.Injectable = Injectable;
  function mixin(mixinClass) {
    Object.defineProperty(mixinClass, "name", {
      value: (0, uid_1.uid)(21)
    });
    Injectable()(mixinClass);
    return mixinClass;
  }
  injectable_decorator.mixin = mixin;
  return injectable_decorator;
}
var optional_decorator = {};
var hasRequiredOptional_decorator;
function requireOptional_decorator() {
  if (hasRequiredOptional_decorator)
    return optional_decorator;
  hasRequiredOptional_decorator = 1;
  Object.defineProperty(optional_decorator, "__esModule", { value: true });
  optional_decorator.Optional = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  function Optional() {
    return (target, key, index) => {
      if (!(0, shared_utils_1.isUndefined)(index)) {
        const args2 = Reflect.getMetadata(constants_1.OPTIONAL_DEPS_METADATA, target) || [];
        Reflect.defineMetadata(constants_1.OPTIONAL_DEPS_METADATA, [...args2, index], target);
        return;
      }
      const properties2 = Reflect.getMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, target.constructor) || [];
      Reflect.defineMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, [...properties2, key], target.constructor);
    };
  }
  optional_decorator.Optional = Optional;
  return optional_decorator;
}
var setMetadata_decorator = {};
var hasRequiredSetMetadata_decorator;
function requireSetMetadata_decorator() {
  if (hasRequiredSetMetadata_decorator)
    return setMetadata_decorator;
  hasRequiredSetMetadata_decorator = 1;
  Object.defineProperty(setMetadata_decorator, "__esModule", { value: true });
  setMetadata_decorator.SetMetadata = void 0;
  const SetMetadata = (metadataKey, metadataValue) => {
    const decoratorFactory = (target, key, descriptor) => {
      if (descriptor) {
        Reflect.defineMetadata(metadataKey, metadataValue, descriptor.value);
        return descriptor;
      }
      Reflect.defineMetadata(metadataKey, metadataValue, target);
      return target;
    };
    decoratorFactory.KEY = metadataKey;
    return decoratorFactory;
  };
  setMetadata_decorator.SetMetadata = SetMetadata;
  return setMetadata_decorator;
}
var useGuards_decorator = {};
var hasRequiredUseGuards_decorator;
function requireUseGuards_decorator() {
  if (hasRequiredUseGuards_decorator)
    return useGuards_decorator;
  hasRequiredUseGuards_decorator = 1;
  Object.defineProperty(useGuards_decorator, "__esModule", { value: true });
  useGuards_decorator.UseGuards = void 0;
  const constants_1 = requireConstants$4();
  const extend_metadata_util_1 = requireExtendMetadata_util();
  const shared_utils_1 = requireShared_utils();
  const validate_each_util_1 = requireValidateEach_util();
  function UseGuards(...guards2) {
    return (target, key, descriptor) => {
      const isGuardValid = (guard) => guard && ((0, shared_utils_1.isFunction)(guard) || (0, shared_utils_1.isFunction)(guard.canActivate));
      if (descriptor) {
        (0, validate_each_util_1.validateEach)(target.constructor, guards2, isGuardValid, "@UseGuards", "guard");
        (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.GUARDS_METADATA, guards2, descriptor.value);
        return descriptor;
      }
      (0, validate_each_util_1.validateEach)(target, guards2, isGuardValid, "@UseGuards", "guard");
      (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.GUARDS_METADATA, guards2, target);
      return target;
    };
  }
  useGuards_decorator.UseGuards = UseGuards;
  return useGuards_decorator;
}
var useInterceptors_decorator = {};
var hasRequiredUseInterceptors_decorator;
function requireUseInterceptors_decorator() {
  if (hasRequiredUseInterceptors_decorator)
    return useInterceptors_decorator;
  hasRequiredUseInterceptors_decorator = 1;
  Object.defineProperty(useInterceptors_decorator, "__esModule", { value: true });
  useInterceptors_decorator.UseInterceptors = void 0;
  const constants_1 = requireConstants$4();
  const extend_metadata_util_1 = requireExtendMetadata_util();
  const shared_utils_1 = requireShared_utils();
  const validate_each_util_1 = requireValidateEach_util();
  function UseInterceptors(...interceptors2) {
    return (target, key, descriptor) => {
      const isInterceptorValid = (interceptor) => interceptor && ((0, shared_utils_1.isFunction)(interceptor) || (0, shared_utils_1.isFunction)(interceptor.intercept));
      if (descriptor) {
        (0, validate_each_util_1.validateEach)(target.constructor, interceptors2, isInterceptorValid, "@UseInterceptors", "interceptor");
        (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.INTERCEPTORS_METADATA, interceptors2, descriptor.value);
        return descriptor;
      }
      (0, validate_each_util_1.validateEach)(target, interceptors2, isInterceptorValid, "@UseInterceptors", "interceptor");
      (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.INTERCEPTORS_METADATA, interceptors2, target);
      return target;
    };
  }
  useInterceptors_decorator.UseInterceptors = UseInterceptors;
  return useInterceptors_decorator;
}
var usePipes_decorator = {};
var hasRequiredUsePipes_decorator;
function requireUsePipes_decorator() {
  if (hasRequiredUsePipes_decorator)
    return usePipes_decorator;
  hasRequiredUsePipes_decorator = 1;
  Object.defineProperty(usePipes_decorator, "__esModule", { value: true });
  usePipes_decorator.UsePipes = void 0;
  const constants_1 = requireConstants$4();
  const extend_metadata_util_1 = requireExtendMetadata_util();
  const shared_utils_1 = requireShared_utils();
  const validate_each_util_1 = requireValidateEach_util();
  function UsePipes(...pipes2) {
    return (target, key, descriptor) => {
      const isPipeValid = (pipe2) => pipe2 && ((0, shared_utils_1.isFunction)(pipe2) || (0, shared_utils_1.isFunction)(pipe2.transform));
      if (descriptor) {
        (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.PIPES_METADATA, pipes2, descriptor.value);
        return descriptor;
      }
      (0, validate_each_util_1.validateEach)(target, pipes2, isPipeValid, "@UsePipes", "pipe");
      (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.PIPES_METADATA, pipes2, target);
      return target;
    };
  }
  usePipes_decorator.UsePipes = UsePipes;
  return usePipes_decorator;
}
var applyDecorators = {};
var hasRequiredApplyDecorators;
function requireApplyDecorators() {
  if (hasRequiredApplyDecorators)
    return applyDecorators;
  hasRequiredApplyDecorators = 1;
  Object.defineProperty(applyDecorators, "__esModule", { value: true });
  applyDecorators.applyDecorators = void 0;
  function applyDecorators$1(...decorators2) {
    return (target, propertyKey, descriptor) => {
      for (const decorator of decorators2) {
        if (target instanceof Function && !descriptor) {
          decorator(target);
          continue;
        }
        decorator(target, propertyKey, descriptor);
      }
    };
  }
  applyDecorators.applyDecorators = applyDecorators$1;
  return applyDecorators;
}
var version_decorator = {};
var hasRequiredVersion_decorator;
function requireVersion_decorator() {
  if (hasRequiredVersion_decorator)
    return version_decorator;
  hasRequiredVersion_decorator = 1;
  Object.defineProperty(version_decorator, "__esModule", { value: true });
  version_decorator.Version = void 0;
  const constants_1 = requireConstants$4();
  function Version(version) {
    if (Array.isArray(version)) {
      version = Array.from(new Set(version));
    }
    return (target, key, descriptor) => {
      Reflect.defineMetadata(constants_1.VERSION_METADATA, version, descriptor.value);
      return descriptor;
    };
  }
  version_decorator.Version = Version;
  return version_decorator;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core$c;
  hasRequiredCore = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireBind_decorator(), exports2);
    tslib_1.__exportStar(requireCatch_decorator(), exports2);
    tslib_1.__exportStar(requireController_decorator(), exports2);
    tslib_1.__exportStar(requireDependencies_decorator(), exports2);
    tslib_1.__exportStar(requireExceptionFilters_decorator(), exports2);
    tslib_1.__exportStar(requireInject_decorator(), exports2);
    tslib_1.__exportStar(requireInjectable_decorator(), exports2);
    tslib_1.__exportStar(requireOptional_decorator(), exports2);
    tslib_1.__exportStar(requireSetMetadata_decorator(), exports2);
    tslib_1.__exportStar(requireUseGuards_decorator(), exports2);
    tslib_1.__exportStar(requireUseInterceptors_decorator(), exports2);
    tslib_1.__exportStar(requireUsePipes_decorator(), exports2);
    tslib_1.__exportStar(requireApplyDecorators(), exports2);
    tslib_1.__exportStar(requireVersion_decorator(), exports2);
  })(core$c);
  return core$c;
}
var consoleLogger_service = {};
var cliColors_util = {};
var hasRequiredCliColors_util;
function requireCliColors_util() {
  if (hasRequiredCliColors_util)
    return cliColors_util;
  hasRequiredCliColors_util = 1;
  Object.defineProperty(cliColors_util, "__esModule", { value: true });
  cliColors_util.yellow = cliColors_util.clc = void 0;
  const isColorAllowed = () => !process.env.NO_COLOR;
  const colorIfAllowed = (colorFn) => (text) => isColorAllowed() ? colorFn(text) : text;
  cliColors_util.clc = {
    bold: colorIfAllowed((text) => `\x1B[1m${text}\x1B[0m`),
    green: colorIfAllowed((text) => `\x1B[32m${text}\x1B[39m`),
    yellow: colorIfAllowed((text) => `\x1B[33m${text}\x1B[39m`),
    red: colorIfAllowed((text) => `\x1B[31m${text}\x1B[39m`),
    magentaBright: colorIfAllowed((text) => `\x1B[95m${text}\x1B[39m`),
    cyanBright: colorIfAllowed((text) => `\x1B[96m${text}\x1B[39m`)
  };
  cliColors_util.yellow = colorIfAllowed((text) => `\x1B[38;5;3m${text}\x1B[39m`);
  return cliColors_util;
}
var utils$c = {};
var isLogLevelEnabled_util = {};
var hasRequiredIsLogLevelEnabled_util;
function requireIsLogLevelEnabled_util() {
  if (hasRequiredIsLogLevelEnabled_util)
    return isLogLevelEnabled_util;
  hasRequiredIsLogLevelEnabled_util = 1;
  Object.defineProperty(isLogLevelEnabled_util, "__esModule", { value: true });
  isLogLevelEnabled_util.isLogLevelEnabled = void 0;
  const LOG_LEVEL_VALUES = {
    debug: 0,
    verbose: 1,
    log: 2,
    warn: 3,
    error: 4
  };
  function isLogLevelEnabled(targetLevel, logLevels) {
    var _a;
    if (!logLevels || Array.isArray(logLevels) && (logLevels === null || logLevels === void 0 ? void 0 : logLevels.length) === 0) {
      return false;
    }
    if (logLevels.includes(targetLevel)) {
      return true;
    }
    const highestLogLevelValue = (_a = logLevels.map((level) => LOG_LEVEL_VALUES[level]).sort((a, b) => b - a)) === null || _a === void 0 ? void 0 : _a[0];
    const targetLevelValue = LOG_LEVEL_VALUES[targetLevel];
    return targetLevelValue >= highestLogLevelValue;
  }
  isLogLevelEnabled_util.isLogLevelEnabled = isLogLevelEnabled;
  return isLogLevelEnabled_util;
}
var hasRequiredUtils$8;
function requireUtils$8() {
  if (hasRequiredUtils$8)
    return utils$c;
  hasRequiredUtils$8 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireIsLogLevelEnabled_util(), exports2);
  })(utils$c);
  return utils$c;
}
var hasRequiredConsoleLogger_service;
function requireConsoleLogger_service() {
  if (hasRequiredConsoleLogger_service)
    return consoleLogger_service;
  hasRequiredConsoleLogger_service = 1;
  var ConsoleLogger_1;
  Object.defineProperty(consoleLogger_service, "__esModule", { value: true });
  consoleLogger_service.ConsoleLogger = void 0;
  const tslib_1 = require$$0$3;
  const core_12 = requireCore();
  const cli_colors_util_1 = requireCliColors_util();
  const shared_utils_1 = requireShared_utils();
  const utils_12 = requireUtils$8();
  const DEFAULT_LOG_LEVELS = [
    "log",
    "error",
    "warn",
    "debug",
    "verbose"
  ];
  const dateTimeFormatter = new Intl.DateTimeFormat(void 0, {
    year: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric",
    day: "2-digit",
    month: "2-digit"
  });
  let ConsoleLogger = ConsoleLogger_1 = class ConsoleLogger {
    constructor(context, options = {}) {
      this.context = context;
      this.options = options;
      if (!options.logLevels) {
        options.logLevels = DEFAULT_LOG_LEVELS;
      }
      if (context) {
        this.originalContext = context;
      }
    }
    log(message, ...optionalParams) {
      if (!this.isLevelEnabled("log")) {
        return;
      }
      const { messages: messages2, context } = this.getContextAndMessagesToPrint([
        message,
        ...optionalParams
      ]);
      this.printMessages(messages2, context, "log");
    }
    error(message, ...optionalParams) {
      if (!this.isLevelEnabled("error")) {
        return;
      }
      const { messages: messages2, context, stack } = this.getContextAndStackAndMessagesToPrint([message, ...optionalParams]);
      this.printMessages(messages2, context, "error", "stderr");
      this.printStackTrace(stack);
    }
    warn(message, ...optionalParams) {
      if (!this.isLevelEnabled("warn")) {
        return;
      }
      const { messages: messages2, context } = this.getContextAndMessagesToPrint([
        message,
        ...optionalParams
      ]);
      this.printMessages(messages2, context, "warn");
    }
    debug(message, ...optionalParams) {
      if (!this.isLevelEnabled("debug")) {
        return;
      }
      const { messages: messages2, context } = this.getContextAndMessagesToPrint([
        message,
        ...optionalParams
      ]);
      this.printMessages(messages2, context, "debug");
    }
    verbose(message, ...optionalParams) {
      if (!this.isLevelEnabled("verbose")) {
        return;
      }
      const { messages: messages2, context } = this.getContextAndMessagesToPrint([
        message,
        ...optionalParams
      ]);
      this.printMessages(messages2, context, "verbose");
    }
    /**
     * Set log levels
     * @param levels log levels
     */
    setLogLevels(levels) {
      if (!this.options) {
        this.options = {};
      }
      this.options.logLevels = levels;
    }
    /**
     * Set logger context
     * @param context context
     */
    setContext(context) {
      this.context = context;
    }
    /**
     * Resets the logger context to the value that was passed in the constructor.
     */
    resetContext() {
      this.context = this.originalContext;
    }
    isLevelEnabled(level) {
      var _a;
      const logLevels = (_a = this.options) === null || _a === void 0 ? void 0 : _a.logLevels;
      return (0, utils_12.isLogLevelEnabled)(level, logLevels);
    }
    getTimestamp() {
      return dateTimeFormatter.format(Date.now());
    }
    printMessages(messages2, context = "", logLevel = "log", writeStreamType) {
      messages2.forEach((message) => {
        const pidMessage = this.formatPid(process.pid);
        const contextMessage = this.formatContext(context);
        const timestampDiff = this.updateAndGetTimestampDiff();
        const formattedLogLevel = logLevel.toUpperCase().padStart(7, " ");
        const formattedMessage = this.formatMessage(logLevel, message, pidMessage, formattedLogLevel, contextMessage, timestampDiff);
        process[writeStreamType !== null && writeStreamType !== void 0 ? writeStreamType : "stdout"].write(formattedMessage);
      });
    }
    formatPid(pid) {
      return `[Nest] ${pid}  - `;
    }
    formatContext(context) {
      return context ? (0, cli_colors_util_1.yellow)(`[${context}] `) : "";
    }
    formatMessage(logLevel, message, pidMessage, formattedLogLevel, contextMessage, timestampDiff) {
      const output = this.stringifyMessage(message, logLevel);
      pidMessage = this.colorize(pidMessage, logLevel);
      formattedLogLevel = this.colorize(formattedLogLevel, logLevel);
      return `${pidMessage}${this.getTimestamp()} ${formattedLogLevel} ${contextMessage}${output}${timestampDiff}
`;
    }
    stringifyMessage(message, logLevel) {
      return (0, shared_utils_1.isFunction)(message) ? this.stringifyMessage(message(), logLevel) : (0, shared_utils_1.isPlainObject)(message) || Array.isArray(message) ? `${this.colorize("Object:", logLevel)}
${JSON.stringify(message, (key, value) => typeof value === "bigint" ? value.toString() : value, 2)}
` : this.colorize(message, logLevel);
    }
    colorize(message, logLevel) {
      const color = this.getColorByLogLevel(logLevel);
      return color(message);
    }
    printStackTrace(stack) {
      if (!stack) {
        return;
      }
      process.stderr.write(`${stack}
`);
    }
    updateAndGetTimestampDiff() {
      var _a;
      const includeTimestamp = ConsoleLogger_1.lastTimestampAt && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.timestamp);
      const result = includeTimestamp ? this.formatTimestampDiff(Date.now() - ConsoleLogger_1.lastTimestampAt) : "";
      ConsoleLogger_1.lastTimestampAt = Date.now();
      return result;
    }
    formatTimestampDiff(timestampDiff) {
      return (0, cli_colors_util_1.yellow)(` +${timestampDiff}ms`);
    }
    getContextAndMessagesToPrint(args2) {
      if ((args2 === null || args2 === void 0 ? void 0 : args2.length) <= 1) {
        return { messages: args2, context: this.context };
      }
      const lastElement = args2[args2.length - 1];
      const isContext = (0, shared_utils_1.isString)(lastElement);
      if (!isContext) {
        return { messages: args2, context: this.context };
      }
      return {
        context: lastElement,
        messages: args2.slice(0, args2.length - 1)
      };
    }
    getContextAndStackAndMessagesToPrint(args2) {
      if (args2.length === 2) {
        return this.isStackFormat(args2[1]) ? {
          messages: [args2[0]],
          stack: args2[1],
          context: this.context
        } : {
          messages: [args2[0]],
          context: args2[1]
        };
      }
      const { messages: messages2, context } = this.getContextAndMessagesToPrint(args2);
      if ((messages2 === null || messages2 === void 0 ? void 0 : messages2.length) <= 1) {
        return { messages: messages2, context };
      }
      const lastElement = messages2[messages2.length - 1];
      const isStack = (0, shared_utils_1.isString)(lastElement);
      if (!isStack && !(0, shared_utils_1.isUndefined)(lastElement)) {
        return { messages: messages2, context };
      }
      return {
        stack: lastElement,
        messages: messages2.slice(0, messages2.length - 1),
        context
      };
    }
    isStackFormat(stack) {
      if (!(0, shared_utils_1.isString)(stack) && !(0, shared_utils_1.isUndefined)(stack)) {
        return false;
      }
      return /^(.)+\n\s+at .+:\d+:\d+$/.test(stack);
    }
    getColorByLogLevel(level) {
      switch (level) {
        case "debug":
          return cli_colors_util_1.clc.magentaBright;
        case "warn":
          return cli_colors_util_1.clc.yellow;
        case "error":
          return cli_colors_util_1.clc.red;
        case "verbose":
          return cli_colors_util_1.clc.cyanBright;
        default:
          return cli_colors_util_1.clc.green;
      }
    }
  };
  ConsoleLogger = ConsoleLogger_1 = tslib_1.__decorate([
    (0, core_12.Injectable)(),
    tslib_1.__param(0, (0, core_12.Optional)()),
    tslib_1.__param(1, (0, core_12.Optional)()),
    tslib_1.__metadata("design:paramtypes", [String, Object])
  ], ConsoleLogger);
  consoleLogger_service.ConsoleLogger = ConsoleLogger;
  return consoleLogger_service;
}
var hasRequiredLogger_service;
function requireLogger_service() {
  if (hasRequiredLogger_service)
    return logger_service;
  hasRequiredLogger_service = 1;
  var Logger_1;
  Object.defineProperty(logger_service, "__esModule", { value: true });
  logger_service.Logger = void 0;
  const tslib_1 = require$$0$3;
  const core_12 = requireCore();
  const shared_utils_1 = requireShared_utils();
  const console_logger_service_1 = requireConsoleLogger_service();
  const utils_12 = requireUtils$8();
  const DEFAULT_LOGGER = new console_logger_service_1.ConsoleLogger();
  const dateTimeFormatter = new Intl.DateTimeFormat(void 0, {
    year: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric",
    day: "2-digit",
    month: "2-digit"
  });
  let Logger = Logger_1 = class Logger {
    constructor(context, options = {}) {
      this.context = context;
      this.options = options;
    }
    get localInstance() {
      if (Logger_1.staticInstanceRef === DEFAULT_LOGGER) {
        return this.registerLocalInstanceRef();
      } else if (Logger_1.staticInstanceRef instanceof Logger_1) {
        const prototype2 = Object.getPrototypeOf(Logger_1.staticInstanceRef);
        if (prototype2.constructor === Logger_1) {
          return this.registerLocalInstanceRef();
        }
      }
      return Logger_1.staticInstanceRef;
    }
    error(message, ...optionalParams) {
      var _a;
      optionalParams = this.context ? (optionalParams.length ? optionalParams : [void 0]).concat(this.context) : optionalParams;
      (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.error(message, ...optionalParams);
    }
    log(message, ...optionalParams) {
      var _a;
      optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
      (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.log(message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
      var _a;
      optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
      (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.warn(message, ...optionalParams);
    }
    debug(message, ...optionalParams) {
      var _a, _b;
      optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
      (_b = (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, message, ...optionalParams);
    }
    verbose(message, ...optionalParams) {
      var _a, _b;
      optionalParams = this.context ? optionalParams.concat(this.context) : optionalParams;
      (_b = (_a = this.localInstance) === null || _a === void 0 ? void 0 : _a.verbose) === null || _b === void 0 ? void 0 : _b.call(_a, message, ...optionalParams);
    }
    static error(message, ...optionalParams) {
      var _a;
      (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.error(message, ...optionalParams);
    }
    static log(message, ...optionalParams) {
      var _a;
      (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.log(message, ...optionalParams);
    }
    static warn(message, ...optionalParams) {
      var _a;
      (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.warn(message, ...optionalParams);
    }
    static debug(message, ...optionalParams) {
      var _a, _b;
      (_b = (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, message, ...optionalParams);
    }
    static verbose(message, ...optionalParams) {
      var _a, _b;
      (_b = (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.verbose) === null || _b === void 0 ? void 0 : _b.call(_a, message, ...optionalParams);
    }
    /**
     * Print buffered logs and detach buffer.
     */
    static flush() {
      this.isBufferAttached = false;
      this.logBuffer.forEach((item) => item.methodRef(...item.arguments));
      this.logBuffer = [];
    }
    /**
     * Attach buffer.
     * Turns on initialization logs buffering.
     */
    static attachBuffer() {
      this.isBufferAttached = true;
    }
    /**
     * Detach buffer.
     * Turns off initialization logs buffering.
     */
    static detachBuffer() {
      this.isBufferAttached = false;
    }
    static getTimestamp() {
      return dateTimeFormatter.format(Date.now());
    }
    static overrideLogger(logger) {
      var _a;
      if (Array.isArray(logger)) {
        Logger_1.logLevels = logger;
        return (_a = this.staticInstanceRef) === null || _a === void 0 ? void 0 : _a.setLogLevels(logger);
      }
      if ((0, shared_utils_1.isObject)(logger)) {
        if (logger instanceof Logger_1 && logger.constructor !== Logger_1) {
          const errorMessage = `Using the "extends Logger" instruction is not allowed in Nest v9. Please, use "extends ConsoleLogger" instead.`;
          this.staticInstanceRef.error(errorMessage);
          throw new Error(errorMessage);
        }
        this.staticInstanceRef = logger;
      } else {
        this.staticInstanceRef = void 0;
      }
    }
    static isLevelEnabled(level) {
      const logLevels = Logger_1.logLevels;
      return (0, utils_12.isLogLevelEnabled)(level, logLevels);
    }
    registerLocalInstanceRef() {
      var _a;
      if (this.localInstanceRef) {
        return this.localInstanceRef;
      }
      this.localInstanceRef = new console_logger_service_1.ConsoleLogger(this.context, {
        timestamp: (_a = this.options) === null || _a === void 0 ? void 0 : _a.timestamp,
        logLevels: Logger_1.logLevels
      });
      return this.localInstanceRef;
    }
  };
  Logger.logBuffer = new Array();
  Logger.staticInstanceRef = DEFAULT_LOGGER;
  Logger.WrapBuffer = (target, propertyKey, descriptor) => {
    const originalFn = descriptor.value;
    descriptor.value = function(...args2) {
      if (Logger_1.isBufferAttached) {
        Logger_1.logBuffer.push({
          methodRef: originalFn.bind(this),
          arguments: args2
        });
        return;
      }
      return originalFn.call(this, ...args2);
    };
  };
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger.prototype, "error", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger.prototype, "log", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger.prototype, "warn", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger.prototype, "debug", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger.prototype, "verbose", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger, "error", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger, "log", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger, "warn", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger, "debug", null);
  tslib_1.__decorate([
    Logger_1.WrapBuffer,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", void 0)
  ], Logger, "verbose", null);
  Logger = Logger_1 = tslib_1.__decorate([
    (0, core_12.Injectable)(),
    tslib_1.__param(0, (0, core_12.Optional)()),
    tslib_1.__param(1, (0, core_12.Optional)()),
    tslib_1.__metadata("design:paramtypes", [String, Object])
  ], Logger);
  logger_service.Logger = Logger;
  return logger_service;
}
var randomStringGenerator_util = {};
var hasRequiredRandomStringGenerator_util;
function requireRandomStringGenerator_util() {
  if (hasRequiredRandomStringGenerator_util)
    return randomStringGenerator_util;
  hasRequiredRandomStringGenerator_util = 1;
  Object.defineProperty(randomStringGenerator_util, "__esModule", { value: true });
  randomStringGenerator_util.randomStringGenerator = void 0;
  const uid_1 = requireDist$1();
  const randomStringGenerator = () => (0, uid_1.uid)(21);
  randomStringGenerator_util.randomStringGenerator = randomStringGenerator;
  return randomStringGenerator_util;
}
var constants$5 = {};
var hasRequiredConstants$3;
function requireConstants$3() {
  if (hasRequiredConstants$3)
    return constants$5;
  hasRequiredConstants$3 = 1;
  Object.defineProperty(constants$5, "__esModule", { value: true });
  constants$5.CONFIGURABLE_MODULE_ID = constants$5.ASYNC_METHOD_SUFFIX = constants$5.DEFAULT_FACTORY_CLASS_METHOD_KEY = constants$5.DEFAULT_METHOD_KEY = void 0;
  constants$5.DEFAULT_METHOD_KEY = "register";
  constants$5.DEFAULT_FACTORY_CLASS_METHOD_KEY = "create";
  constants$5.ASYNC_METHOD_SUFFIX = "Async";
  constants$5.CONFIGURABLE_MODULE_ID = "CONFIGURABLE_MODULE_ID";
  return constants$5;
}
var utils$b = {};
var generateOptionsInjectionToken_util = {};
var hasRequiredGenerateOptionsInjectionToken_util;
function requireGenerateOptionsInjectionToken_util() {
  if (hasRequiredGenerateOptionsInjectionToken_util)
    return generateOptionsInjectionToken_util;
  hasRequiredGenerateOptionsInjectionToken_util = 1;
  Object.defineProperty(generateOptionsInjectionToken_util, "__esModule", { value: true });
  generateOptionsInjectionToken_util.generateOptionsInjectionToken = void 0;
  const random_string_generator_util_1 = requireRandomStringGenerator_util();
  function generateOptionsInjectionToken() {
    const hash = (0, random_string_generator_util_1.randomStringGenerator)();
    return `CONFIGURABLE_MODULE_OPTIONS[${hash}]`;
  }
  generateOptionsInjectionToken_util.generateOptionsInjectionToken = generateOptionsInjectionToken;
  return generateOptionsInjectionToken_util;
}
var getInjectionProviders_util = {};
var hasRequiredGetInjectionProviders_util;
function requireGetInjectionProviders_util() {
  if (hasRequiredGetInjectionProviders_util)
    return getInjectionProviders_util;
  hasRequiredGetInjectionProviders_util = 1;
  Object.defineProperty(getInjectionProviders_util, "__esModule", { value: true });
  getInjectionProviders_util.getInjectionProviders = void 0;
  function isOptionalFactoryDependency(x) {
    return !!((x === null || x === void 0 ? void 0 : x.token) && !(x === null || x === void 0 ? void 0 : x.prototype));
  }
  const mapInjectToTokens = (t2) => isOptionalFactoryDependency(t2) ? t2.token : t2;
  function getInjectionProviders(providers, tokens) {
    const result = [];
    let search = tokens.map(mapInjectToTokens);
    while (search.length > 0) {
      const match = (providers !== null && providers !== void 0 ? providers : []).filter((p) => !result.includes(p) && // this prevents circular loops and duplication
      (search.includes(p) || search.includes(p === null || p === void 0 ? void 0 : p.provide)));
      result.push(...match);
      search = match.filter((p) => p === null || p === void 0 ? void 0 : p.inject).map((p) => p.inject).flat().map(mapInjectToTokens);
    }
    return result;
  }
  getInjectionProviders_util.getInjectionProviders = getInjectionProviders;
  return getInjectionProviders_util;
}
var hasRequiredUtils$7;
function requireUtils$7() {
  if (hasRequiredUtils$7)
    return utils$b;
  hasRequiredUtils$7 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireGenerateOptionsInjectionToken_util(), exports2);
    tslib_1.__exportStar(requireGetInjectionProviders_util(), exports2);
  })(utils$b);
  return utils$b;
}
var hasRequiredConfigurableModule_builder;
function requireConfigurableModule_builder() {
  if (hasRequiredConfigurableModule_builder)
    return configurableModule_builder;
  hasRequiredConfigurableModule_builder = 1;
  Object.defineProperty(configurableModule_builder, "__esModule", { value: true });
  configurableModule_builder.ConfigurableModuleBuilder = void 0;
  const logger_service_1 = requireLogger_service();
  const random_string_generator_util_1 = requireRandomStringGenerator_util();
  const constants_1 = requireConstants$3();
  const utils_12 = requireUtils$7();
  class ConfigurableModuleBuilder {
    constructor(options = {}, parentBuilder) {
      this.options = options;
      this.logger = new logger_service_1.Logger(ConfigurableModuleBuilder.name);
      if (parentBuilder) {
        this.staticMethodKey = parentBuilder.staticMethodKey;
        this.factoryClassMethodKey = parentBuilder.factoryClassMethodKey;
        this.transformModuleDefinition = parentBuilder.transformModuleDefinition;
        this.extras = parentBuilder.extras;
      }
    }
    /**
     * Registers the "extras" object (a set of extra options that can be used to modify the dynamic module definition).
     * Values you specify within the "extras" object will be used as default values (that can be overridden by module consumers).
     *
     * This method also applies the so-called "module definition transform function" that takes the auto-generated
     * dynamic module object ("DynamicModule") and the actual consumer "extras" object as input parameters.
     * The "extras" object consists of values explicitly specified by module consumers and default values.
     *
     * @example
     * ```typescript
     * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>
     *    ({ ...definition, global: extras.isGlobal })
     * )
     * ```
     */
    setExtras(extras, transformDefinition = (def2) => def2) {
      const builder2 = new ConfigurableModuleBuilder(this.options, this);
      builder2.extras = extras;
      builder2.transformModuleDefinition = transformDefinition;
      return builder2;
    }
    /**
     * Dynamic modules must expose public static methods that let you pass in
     * configuration parameters (control the module's behavior from the outside).
     * Some frequently used names that you may have seen in other modules are:
     * "forRoot", "forFeature", "register", "configure".
     *
     * This method "setClassMethodName" lets you specify the name of the
     * method that will be auto-generated.
     *
     * @param key name of the method
     */
    setClassMethodName(key) {
      const builder2 = new ConfigurableModuleBuilder(this.options, this);
      builder2.staticMethodKey = key;
      return builder2;
    }
    /**
     * Asynchronously configured modules (that rely on other modules, i.e. "ConfigModule")
     * let you pass the configuration factory class that will be registered and instantiated as a provider.
     * This provider then will be used to retrieve the module's configuration. To provide the configuration,
     * the corresponding factory method must be implemented.
     *
     * This method ("setFactoryMethodName") lets you control what method name will have to be
     * implemented by the config factory (default is "create").
     *
     * @param key name of the method
     */
    setFactoryMethodName(key) {
      const builder2 = new ConfigurableModuleBuilder(this.options, this);
      builder2.factoryClassMethodKey = key;
      return builder2;
    }
    /**
     * Returns an object consisting of multiple properties that lets you
     * easily construct dynamic configurable modules. See "ConfigurableModuleHost" interface for more details.
     */
    build() {
      var _a, _b, _c, _d;
      var _e;
      (_a = this.staticMethodKey) !== null && _a !== void 0 ? _a : this.staticMethodKey = constants_1.DEFAULT_METHOD_KEY;
      (_b = this.factoryClassMethodKey) !== null && _b !== void 0 ? _b : this.factoryClassMethodKey = constants_1.DEFAULT_FACTORY_CLASS_METHOD_KEY;
      (_c = (_e = this.options).optionsInjectionToken) !== null && _c !== void 0 ? _c : _e.optionsInjectionToken = this.options.moduleName ? this.constructInjectionTokenString() : (0, utils_12.generateOptionsInjectionToken)();
      (_d = this.transformModuleDefinition) !== null && _d !== void 0 ? _d : this.transformModuleDefinition = (definition) => definition;
      return {
        ConfigurableModuleClass: this.createConfigurableModuleCls(),
        MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,
        ASYNC_OPTIONS_TYPE: this.createTypeProxy("ASYNC_OPTIONS_TYPE"),
        OPTIONS_TYPE: this.createTypeProxy("OPTIONS_TYPE")
      };
    }
    constructInjectionTokenString() {
      const moduleNameInSnakeCase = this.options.moduleName.trim().split(/(?=[A-Z])/).join("_").toUpperCase();
      return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;
    }
    createConfigurableModuleCls() {
      const self2 = this;
      const asyncMethodKey = this.staticMethodKey + constants_1.ASYNC_METHOD_SUFFIX;
      class InternalModuleClass {
        static [self2.staticMethodKey](options) {
          const providers = [
            {
              provide: self2.options.optionsInjectionToken,
              useValue: this.omitExtras(options, self2.extras)
            }
          ];
          if (self2.options.alwaysTransient) {
            providers.push({
              provide: constants_1.CONFIGURABLE_MODULE_ID,
              useValue: (0, random_string_generator_util_1.randomStringGenerator)()
            });
          }
          return self2.transformModuleDefinition({
            module: this,
            providers
          }, Object.assign(Object.assign({}, self2.extras), options));
        }
        static [asyncMethodKey](options) {
          const providers = this.createAsyncProviders(options);
          if (self2.options.alwaysTransient) {
            providers.push({
              provide: constants_1.CONFIGURABLE_MODULE_ID,
              useValue: (0, random_string_generator_util_1.randomStringGenerator)()
            });
          }
          return self2.transformModuleDefinition({
            module: this,
            imports: options.imports || [],
            providers
          }, Object.assign(Object.assign({}, self2.extras), options));
        }
        static omitExtras(input, extras) {
          if (!extras) {
            return input;
          }
          const moduleOptions = {};
          const extrasKeys = Object.keys(extras);
          Object.keys(input).filter((key) => !extrasKeys.includes(key)).forEach((key) => {
            moduleOptions[key] = input[key];
          });
          return moduleOptions;
        }
        static createAsyncProviders(options) {
          if (options.useExisting || options.useFactory) {
            if (options.inject && options.provideInjectionTokensFrom) {
              return [
                this.createAsyncOptionsProvider(options),
                ...(0, utils_12.getInjectionProviders)(options.provideInjectionTokensFrom, options.inject)
              ];
            }
            return [this.createAsyncOptionsProvider(options)];
          }
          return [
            this.createAsyncOptionsProvider(options),
            {
              provide: options.useClass,
              useClass: options.useClass
            }
          ];
        }
        static createAsyncOptionsProvider(options) {
          if (options.useFactory) {
            return {
              provide: self2.options.optionsInjectionToken,
              useFactory: options.useFactory,
              inject: options.inject || []
            };
          }
          return {
            provide: self2.options.optionsInjectionToken,
            useFactory: async (optionsFactory) => await optionsFactory[self2.factoryClassMethodKey](),
            inject: [options.useExisting || options.useClass]
          };
        }
      }
      return InternalModuleClass;
    }
    createTypeProxy(typeName) {
      const proxy = new Proxy({}, {
        get: () => {
          throw new Error(`"${typeName}" is not supposed to be used as a value.`);
        }
      });
      return proxy;
    }
  }
  configurableModule_builder.ConfigurableModuleBuilder = ConfigurableModuleBuilder;
  return configurableModule_builder;
}
var interfaces$5 = {};
var configurableModuleAsyncOptions_interface = {};
var hasRequiredConfigurableModuleAsyncOptions_interface;
function requireConfigurableModuleAsyncOptions_interface() {
  if (hasRequiredConfigurableModuleAsyncOptions_interface)
    return configurableModuleAsyncOptions_interface;
  hasRequiredConfigurableModuleAsyncOptions_interface = 1;
  Object.defineProperty(configurableModuleAsyncOptions_interface, "__esModule", { value: true });
  return configurableModuleAsyncOptions_interface;
}
var configurableModuleCls_interface = {};
var hasRequiredConfigurableModuleCls_interface;
function requireConfigurableModuleCls_interface() {
  if (hasRequiredConfigurableModuleCls_interface)
    return configurableModuleCls_interface;
  hasRequiredConfigurableModuleCls_interface = 1;
  Object.defineProperty(configurableModuleCls_interface, "__esModule", { value: true });
  return configurableModuleCls_interface;
}
var configurableModuleHost_interface = {};
var hasRequiredConfigurableModuleHost_interface;
function requireConfigurableModuleHost_interface() {
  if (hasRequiredConfigurableModuleHost_interface)
    return configurableModuleHost_interface;
  hasRequiredConfigurableModuleHost_interface = 1;
  Object.defineProperty(configurableModuleHost_interface, "__esModule", { value: true });
  return configurableModuleHost_interface;
}
var hasRequiredInterfaces$5;
function requireInterfaces$5() {
  if (hasRequiredInterfaces$5)
    return interfaces$5;
  hasRequiredInterfaces$5 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireConfigurableModuleAsyncOptions_interface(), exports2);
    tslib_1.__exportStar(requireConfigurableModuleCls_interface(), exports2);
    tslib_1.__exportStar(requireConfigurableModuleHost_interface(), exports2);
  })(interfaces$5);
  return interfaces$5;
}
var hasRequiredModuleUtils;
function requireModuleUtils() {
  if (hasRequiredModuleUtils)
    return moduleUtils;
  hasRequiredModuleUtils = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireConfigurableModule_builder(), exports2);
    tslib_1.__exportStar(requireInterfaces$5(), exports2);
  })(moduleUtils);
  return moduleUtils;
}
var hasRequiredCache_moduleDefinition;
function requireCache_moduleDefinition() {
  if (hasRequiredCache_moduleDefinition)
    return cache_moduleDefinition;
  hasRequiredCache_moduleDefinition = 1;
  var _a;
  Object.defineProperty(cache_moduleDefinition, "__esModule", { value: true });
  cache_moduleDefinition.MODULE_OPTIONS_TOKEN = cache_moduleDefinition.ConfigurableModuleClass = void 0;
  const module_utils_1 = requireModuleUtils();
  _a = new module_utils_1.ConfigurableModuleBuilder({
    moduleName: "Cache"
  }).setFactoryMethodName("createCacheOptions").build(), cache_moduleDefinition.ConfigurableModuleClass = _a.ConfigurableModuleClass, cache_moduleDefinition.MODULE_OPTIONS_TOKEN = _a.MODULE_OPTIONS_TOKEN;
  return cache_moduleDefinition;
}
var hasRequiredCache_constants;
function requireCache_constants() {
  if (hasRequiredCache_constants)
    return cache_constants;
  hasRequiredCache_constants = 1;
  Object.defineProperty(cache_constants, "__esModule", { value: true });
  cache_constants.CACHE_MODULE_OPTIONS = cache_constants.CACHE_TTL_METADATA = cache_constants.CACHE_KEY_METADATA = cache_constants.CACHE_MANAGER = void 0;
  const cache_module_definition_1 = requireCache_moduleDefinition();
  cache_constants.CACHE_MANAGER = "CACHE_MANAGER";
  cache_constants.CACHE_KEY_METADATA = "cache_module:cache_key";
  cache_constants.CACHE_TTL_METADATA = "cache_module:cache_ttl";
  cache_constants.CACHE_MODULE_OPTIONS = cache_module_definition_1.MODULE_OPTIONS_TOKEN;
  return cache_constants;
}
var cache_module = {};
var decorators$2 = {};
var modules$1 = {};
var global_decorator = {};
var hasRequiredGlobal_decorator;
function requireGlobal_decorator() {
  if (hasRequiredGlobal_decorator)
    return global_decorator;
  hasRequiredGlobal_decorator = 1;
  Object.defineProperty(global_decorator, "__esModule", { value: true });
  global_decorator.Global = void 0;
  const constants_1 = requireConstants$4();
  function Global() {
    return (target) => {
      Reflect.defineMetadata(constants_1.GLOBAL_MODULE_METADATA, true, target);
    };
  }
  global_decorator.Global = Global;
  return global_decorator;
}
var module_decorator = {};
var validateModuleKeys_util = {};
var hasRequiredValidateModuleKeys_util;
function requireValidateModuleKeys_util() {
  if (hasRequiredValidateModuleKeys_util)
    return validateModuleKeys_util;
  hasRequiredValidateModuleKeys_util = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModuleKeys = exports2.INVALID_MODULE_CONFIG_MESSAGE = void 0;
    const constants_1 = requireConstants$4();
    const INVALID_MODULE_CONFIG_MESSAGE = (text, property) => `Invalid property '${property}' passed into the @Module() decorator.`;
    exports2.INVALID_MODULE_CONFIG_MESSAGE = INVALID_MODULE_CONFIG_MESSAGE;
    const metadataKeys = [
      constants_1.MODULE_METADATA.IMPORTS,
      constants_1.MODULE_METADATA.EXPORTS,
      constants_1.MODULE_METADATA.CONTROLLERS,
      constants_1.MODULE_METADATA.PROVIDERS
    ];
    function validateModuleKeys(keys) {
      const validateKey = (key) => {
        if (metadataKeys.includes(key)) {
          return;
        }
        throw new Error((0, exports2.INVALID_MODULE_CONFIG_MESSAGE)`${key}`);
      };
      keys.forEach(validateKey);
    }
    exports2.validateModuleKeys = validateModuleKeys;
  })(validateModuleKeys_util);
  return validateModuleKeys_util;
}
var hasRequiredModule_decorator;
function requireModule_decorator() {
  if (hasRequiredModule_decorator)
    return module_decorator;
  hasRequiredModule_decorator = 1;
  Object.defineProperty(module_decorator, "__esModule", { value: true });
  module_decorator.Module = void 0;
  const validate_module_keys_util_1 = requireValidateModuleKeys_util();
  function Module(metadata2) {
    const propsKeys = Object.keys(metadata2);
    (0, validate_module_keys_util_1.validateModuleKeys)(propsKeys);
    return (target) => {
      for (const property in metadata2) {
        if (metadata2.hasOwnProperty(property)) {
          Reflect.defineMetadata(property, metadata2[property], target);
        }
      }
    };
  }
  module_decorator.Module = Module;
  return module_decorator;
}
var hasRequiredModules$1;
function requireModules$1() {
  if (hasRequiredModules$1)
    return modules$1;
  hasRequiredModules$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireGlobal_decorator(), exports2);
    tslib_1.__exportStar(requireModule_decorator(), exports2);
  })(modules$1);
  return modules$1;
}
var http$4 = {};
var requestMapping_decorator = {};
var requestMethod_enum = {};
var hasRequiredRequestMethod_enum;
function requireRequestMethod_enum() {
  if (hasRequiredRequestMethod_enum)
    return requestMethod_enum;
  hasRequiredRequestMethod_enum = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RequestMethod = void 0;
    (function(RequestMethod) {
      RequestMethod[RequestMethod["GET"] = 0] = "GET";
      RequestMethod[RequestMethod["POST"] = 1] = "POST";
      RequestMethod[RequestMethod["PUT"] = 2] = "PUT";
      RequestMethod[RequestMethod["DELETE"] = 3] = "DELETE";
      RequestMethod[RequestMethod["PATCH"] = 4] = "PATCH";
      RequestMethod[RequestMethod["ALL"] = 5] = "ALL";
      RequestMethod[RequestMethod["OPTIONS"] = 6] = "OPTIONS";
      RequestMethod[RequestMethod["HEAD"] = 7] = "HEAD";
    })(exports2.RequestMethod || (exports2.RequestMethod = {}));
  })(requestMethod_enum);
  return requestMethod_enum;
}
var hasRequiredRequestMapping_decorator;
function requireRequestMapping_decorator() {
  if (hasRequiredRequestMapping_decorator)
    return requestMapping_decorator;
  hasRequiredRequestMapping_decorator = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.All = exports2.Head = exports2.Options = exports2.Patch = exports2.Put = exports2.Delete = exports2.Get = exports2.Post = exports2.RequestMapping = void 0;
    const constants_1 = requireConstants$4();
    const request_method_enum_1 = requireRequestMethod_enum();
    const defaultMetadata = {
      [constants_1.PATH_METADATA]: "/",
      [constants_1.METHOD_METADATA]: request_method_enum_1.RequestMethod.GET
    };
    const RequestMapping = (metadata2 = defaultMetadata) => {
      const pathMetadata = metadata2[constants_1.PATH_METADATA];
      const path2 = pathMetadata && pathMetadata.length ? pathMetadata : "/";
      const requestMethod = metadata2[constants_1.METHOD_METADATA] || request_method_enum_1.RequestMethod.GET;
      return (target, key, descriptor) => {
        Reflect.defineMetadata(constants_1.PATH_METADATA, path2, descriptor.value);
        Reflect.defineMetadata(constants_1.METHOD_METADATA, requestMethod, descriptor.value);
        return descriptor;
      };
    };
    exports2.RequestMapping = RequestMapping;
    const createMappingDecorator = (method) => (path2) => {
      return (0, exports2.RequestMapping)({
        [constants_1.PATH_METADATA]: path2,
        [constants_1.METHOD_METADATA]: method
      });
    };
    exports2.Post = createMappingDecorator(request_method_enum_1.RequestMethod.POST);
    exports2.Get = createMappingDecorator(request_method_enum_1.RequestMethod.GET);
    exports2.Delete = createMappingDecorator(request_method_enum_1.RequestMethod.DELETE);
    exports2.Put = createMappingDecorator(request_method_enum_1.RequestMethod.PUT);
    exports2.Patch = createMappingDecorator(request_method_enum_1.RequestMethod.PATCH);
    exports2.Options = createMappingDecorator(request_method_enum_1.RequestMethod.OPTIONS);
    exports2.Head = createMappingDecorator(request_method_enum_1.RequestMethod.HEAD);
    exports2.All = createMappingDecorator(request_method_enum_1.RequestMethod.ALL);
  })(requestMapping_decorator);
  return requestMapping_decorator;
}
var routeParams_decorator = {};
var routeParamtypes_enum = {};
var hasRequiredRouteParamtypes_enum;
function requireRouteParamtypes_enum() {
  if (hasRequiredRouteParamtypes_enum)
    return routeParamtypes_enum;
  hasRequiredRouteParamtypes_enum = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RouteParamtypes = void 0;
    (function(RouteParamtypes) {
      RouteParamtypes[RouteParamtypes["REQUEST"] = 0] = "REQUEST";
      RouteParamtypes[RouteParamtypes["RESPONSE"] = 1] = "RESPONSE";
      RouteParamtypes[RouteParamtypes["NEXT"] = 2] = "NEXT";
      RouteParamtypes[RouteParamtypes["BODY"] = 3] = "BODY";
      RouteParamtypes[RouteParamtypes["QUERY"] = 4] = "QUERY";
      RouteParamtypes[RouteParamtypes["PARAM"] = 5] = "PARAM";
      RouteParamtypes[RouteParamtypes["HEADERS"] = 6] = "HEADERS";
      RouteParamtypes[RouteParamtypes["SESSION"] = 7] = "SESSION";
      RouteParamtypes[RouteParamtypes["FILE"] = 8] = "FILE";
      RouteParamtypes[RouteParamtypes["FILES"] = 9] = "FILES";
      RouteParamtypes[RouteParamtypes["HOST"] = 10] = "HOST";
      RouteParamtypes[RouteParamtypes["IP"] = 11] = "IP";
    })(exports2.RouteParamtypes || (exports2.RouteParamtypes = {}));
  })(routeParamtypes_enum);
  return routeParamtypes_enum;
}
var hasRequiredRouteParams_decorator;
function requireRouteParams_decorator() {
  if (hasRequiredRouteParams_decorator)
    return routeParams_decorator;
  hasRequiredRouteParams_decorator = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Res = exports2.Req = exports2.HostParam = exports2.Param = exports2.Body = exports2.Query = exports2.Headers = exports2.UploadedFiles = exports2.UploadedFile = exports2.Session = exports2.Ip = exports2.Next = exports2.Response = exports2.Request = exports2.assignMetadata = void 0;
    const constants_1 = requireConstants$4();
    const route_paramtypes_enum_1 = requireRouteParamtypes_enum();
    const shared_utils_1 = requireShared_utils();
    function assignMetadata(args2, paramtype, index, data, ...pipes2) {
      return Object.assign(Object.assign({}, args2), { [`${paramtype}:${index}`]: {
        index,
        data,
        pipes: pipes2
      } });
    }
    exports2.assignMetadata = assignMetadata;
    function createRouteParamDecorator(paramtype) {
      return (data) => (target, key, index) => {
        const args2 = Reflect.getMetadata(constants_1.ROUTE_ARGS_METADATA, target.constructor, key) || {};
        Reflect.defineMetadata(constants_1.ROUTE_ARGS_METADATA, assignMetadata(args2, paramtype, index, data), target.constructor, key);
      };
    }
    const createPipesRouteParamDecorator = (paramtype) => (data, ...pipes2) => (target, key, index) => {
      const args2 = Reflect.getMetadata(constants_1.ROUTE_ARGS_METADATA, target.constructor, key) || {};
      const hasParamData = (0, shared_utils_1.isNil)(data) || (0, shared_utils_1.isString)(data);
      const paramData = hasParamData ? data : void 0;
      const paramPipes = hasParamData ? pipes2 : [data, ...pipes2];
      Reflect.defineMetadata(constants_1.ROUTE_ARGS_METADATA, assignMetadata(args2, paramtype, index, paramData, ...paramPipes), target.constructor, key);
    };
    exports2.Request = createRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.REQUEST);
    const Response = (options) => (target, key, index) => {
      if (options === null || options === void 0 ? void 0 : options.passthrough) {
        Reflect.defineMetadata(constants_1.RESPONSE_PASSTHROUGH_METADATA, options === null || options === void 0 ? void 0 : options.passthrough, target.constructor, key);
      }
      return createRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.RESPONSE)()(target, key, index);
    };
    exports2.Response = Response;
    exports2.Next = createRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.NEXT);
    exports2.Ip = createRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.IP);
    exports2.Session = createRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.SESSION);
    function UploadedFile(fileKey, ...pipes2) {
      return createPipesRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.FILE)(fileKey, ...pipes2);
    }
    exports2.UploadedFile = UploadedFile;
    function UploadedFiles(...pipes2) {
      return createPipesRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.FILES)(void 0, ...pipes2);
    }
    exports2.UploadedFiles = UploadedFiles;
    exports2.Headers = createRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.HEADERS);
    function Query(property, ...pipes2) {
      return createPipesRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.QUERY)(property, ...pipes2);
    }
    exports2.Query = Query;
    function Body(property, ...pipes2) {
      return createPipesRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.BODY)(property, ...pipes2);
    }
    exports2.Body = Body;
    function Param(property, ...pipes2) {
      return createPipesRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.PARAM)(property, ...pipes2);
    }
    exports2.Param = Param;
    function HostParam(property) {
      return createRouteParamDecorator(route_paramtypes_enum_1.RouteParamtypes.HOST)(property);
    }
    exports2.HostParam = HostParam;
    exports2.Req = exports2.Request;
    exports2.Res = exports2.Response;
  })(routeParams_decorator);
  return routeParams_decorator;
}
var httpCode_decorator = {};
var hasRequiredHttpCode_decorator;
function requireHttpCode_decorator() {
  if (hasRequiredHttpCode_decorator)
    return httpCode_decorator;
  hasRequiredHttpCode_decorator = 1;
  Object.defineProperty(httpCode_decorator, "__esModule", { value: true });
  httpCode_decorator.HttpCode = void 0;
  const constants_1 = requireConstants$4();
  function HttpCode(statusCode) {
    return (target, key, descriptor) => {
      Reflect.defineMetadata(constants_1.HTTP_CODE_METADATA, statusCode, descriptor.value);
      return descriptor;
    };
  }
  httpCode_decorator.HttpCode = HttpCode;
  return httpCode_decorator;
}
var createRouteParamMetadata_decorator = {};
var assignCustomMetadata_util = {};
var hasRequiredAssignCustomMetadata_util;
function requireAssignCustomMetadata_util() {
  if (hasRequiredAssignCustomMetadata_util)
    return assignCustomMetadata_util;
  hasRequiredAssignCustomMetadata_util = 1;
  Object.defineProperty(assignCustomMetadata_util, "__esModule", { value: true });
  assignCustomMetadata_util.assignCustomParameterMetadata = void 0;
  const constants_1 = requireConstants$4();
  function assignCustomParameterMetadata(args2, paramtype, index, factory2, data, ...pipes2) {
    return Object.assign(Object.assign({}, args2), { [`${paramtype}${constants_1.CUSTOM_ROUTE_ARGS_METADATA}:${index}`]: {
      index,
      factory: factory2,
      data,
      pipes: pipes2
    } });
  }
  assignCustomMetadata_util.assignCustomParameterMetadata = assignCustomParameterMetadata;
  return assignCustomMetadata_util;
}
var hasRequiredCreateRouteParamMetadata_decorator;
function requireCreateRouteParamMetadata_decorator() {
  if (hasRequiredCreateRouteParamMetadata_decorator)
    return createRouteParamMetadata_decorator;
  hasRequiredCreateRouteParamMetadata_decorator = 1;
  Object.defineProperty(createRouteParamMetadata_decorator, "__esModule", { value: true });
  createRouteParamMetadata_decorator.createParamDecorator = void 0;
  const uid_1 = requireDist$1();
  const constants_1 = requireConstants$4();
  const assign_custom_metadata_util_1 = requireAssignCustomMetadata_util();
  const shared_utils_1 = requireShared_utils();
  function createParamDecorator(factory2, enhancers = []) {
    const paramtype = (0, uid_1.uid)(21);
    return (data, ...pipes2) => (target, key, index) => {
      const args2 = Reflect.getMetadata(constants_1.ROUTE_ARGS_METADATA, target.constructor, key) || {};
      const isPipe = (pipe2) => pipe2 && ((0, shared_utils_1.isFunction)(pipe2) && pipe2.prototype && (0, shared_utils_1.isFunction)(pipe2.prototype.transform) || (0, shared_utils_1.isFunction)(pipe2.transform));
      const hasParamData = (0, shared_utils_1.isNil)(data) || !isPipe(data);
      const paramData = hasParamData ? data : void 0;
      const paramPipes = hasParamData ? pipes2 : [data, ...pipes2];
      Reflect.defineMetadata(constants_1.ROUTE_ARGS_METADATA, (0, assign_custom_metadata_util_1.assignCustomParameterMetadata)(args2, paramtype, index, factory2, paramData, ...paramPipes), target.constructor, key);
      enhancers.forEach((fn) => fn(target, key, index));
    };
  }
  createRouteParamMetadata_decorator.createParamDecorator = createParamDecorator;
  return createRouteParamMetadata_decorator;
}
var render_decorator = {};
var hasRequiredRender_decorator;
function requireRender_decorator() {
  if (hasRequiredRender_decorator)
    return render_decorator;
  hasRequiredRender_decorator = 1;
  Object.defineProperty(render_decorator, "__esModule", { value: true });
  render_decorator.Render = void 0;
  const constants_1 = requireConstants$4();
  function Render(template) {
    return (target, key, descriptor) => {
      Reflect.defineMetadata(constants_1.RENDER_METADATA, template, descriptor.value);
      return descriptor;
    };
  }
  render_decorator.Render = Render;
  return render_decorator;
}
var header_decorator = {};
var hasRequiredHeader_decorator;
function requireHeader_decorator() {
  if (hasRequiredHeader_decorator)
    return header_decorator;
  hasRequiredHeader_decorator = 1;
  Object.defineProperty(header_decorator, "__esModule", { value: true });
  header_decorator.Header = void 0;
  const constants_1 = requireConstants$4();
  const extend_metadata_util_1 = requireExtendMetadata_util();
  function Header(name, value) {
    return (target, key, descriptor) => {
      (0, extend_metadata_util_1.extendArrayMetadata)(constants_1.HEADERS_METADATA, [{ name, value }], descriptor.value);
      return descriptor;
    };
  }
  header_decorator.Header = Header;
  return header_decorator;
}
var redirect_decorator = {};
var hasRequiredRedirect_decorator;
function requireRedirect_decorator() {
  if (hasRequiredRedirect_decorator)
    return redirect_decorator;
  hasRequiredRedirect_decorator = 1;
  Object.defineProperty(redirect_decorator, "__esModule", { value: true });
  redirect_decorator.Redirect = void 0;
  const constants_1 = requireConstants$4();
  function Redirect(url2 = "", statusCode) {
    return (target, key, descriptor) => {
      Reflect.defineMetadata(constants_1.REDIRECT_METADATA, { statusCode, url: url2 }, descriptor.value);
      return descriptor;
    };
  }
  redirect_decorator.Redirect = Redirect;
  return redirect_decorator;
}
var sse_decorator = {};
var hasRequiredSse_decorator;
function requireSse_decorator() {
  if (hasRequiredSse_decorator)
    return sse_decorator;
  hasRequiredSse_decorator = 1;
  Object.defineProperty(sse_decorator, "__esModule", { value: true });
  sse_decorator.Sse = void 0;
  const constants_1 = requireConstants$4();
  const request_method_enum_1 = requireRequestMethod_enum();
  function Sse(path2) {
    return (target, key, descriptor) => {
      path2 = path2 && path2.length ? path2 : "/";
      Reflect.defineMetadata(constants_1.PATH_METADATA, path2, descriptor.value);
      Reflect.defineMetadata(constants_1.METHOD_METADATA, request_method_enum_1.RequestMethod.GET, descriptor.value);
      Reflect.defineMetadata(constants_1.SSE_METADATA, true, descriptor.value);
      return descriptor;
    };
  }
  sse_decorator.Sse = Sse;
  return sse_decorator;
}
var hasRequiredHttp$1;
function requireHttp$1() {
  if (hasRequiredHttp$1)
    return http$4;
  hasRequiredHttp$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireRequestMapping_decorator(), exports2);
    tslib_1.__exportStar(requireRouteParams_decorator(), exports2);
    tslib_1.__exportStar(requireHttpCode_decorator(), exports2);
    tslib_1.__exportStar(requireCreateRouteParamMetadata_decorator(), exports2);
    tslib_1.__exportStar(requireRender_decorator(), exports2);
    tslib_1.__exportStar(requireHeader_decorator(), exports2);
    tslib_1.__exportStar(requireRedirect_decorator(), exports2);
    tslib_1.__exportStar(requireSse_decorator(), exports2);
  })(http$4);
  return http$4;
}
var hasRequiredDecorators$2;
function requireDecorators$2() {
  if (hasRequiredDecorators$2)
    return decorators$2;
  hasRequiredDecorators$2 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireCore(), exports2);
    tslib_1.__exportStar(requireModules$1(), exports2);
    tslib_1.__exportStar(requireHttp$1(), exports2);
  })(decorators$2);
  return decorators$2;
}
var cache_providers = {};
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var loadPackage_util = {};
var hasRequiredLoadPackage_util;
function requireLoadPackage_util() {
  if (hasRequiredLoadPackage_util)
    return loadPackage_util;
  hasRequiredLoadPackage_util = 1;
  Object.defineProperty(loadPackage_util, "__esModule", { value: true });
  loadPackage_util.loadPackage = void 0;
  const logger_service_1 = requireLogger_service();
  const MISSING_REQUIRED_DEPENDENCY = (name, reason) => `The "${name}" package is missing. Please, make sure to install this library ($ npm install ${name}) to take advantage of ${reason}.`;
  const logger = new logger_service_1.Logger("PackageLoader");
  function loadPackage(packageName, context, loaderFn) {
    try {
      return loaderFn ? loaderFn() : commonjsRequire(packageName);
    } catch (e) {
      logger.error(MISSING_REQUIRED_DEPENDENCY(packageName, context));
      logger_service_1.Logger.flush();
      process.exit(1);
    }
  }
  loadPackage_util.loadPackage = loadPackage;
  return loadPackage_util;
}
var defaultOptions = {};
var hasRequiredDefaultOptions;
function requireDefaultOptions() {
  if (hasRequiredDefaultOptions)
    return defaultOptions;
  hasRequiredDefaultOptions = 1;
  Object.defineProperty(defaultOptions, "__esModule", { value: true });
  defaultOptions.defaultCacheOptions = void 0;
  defaultOptions.defaultCacheOptions = {
    ttl: 5,
    max: 100,
    store: "memory"
  };
  return defaultOptions;
}
const common$7 = {};
const common$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: common$7
}, Symbol.toStringTag, { value: "Module" }));
const require$$9$3 = /* @__PURE__ */ getAugmentedNamespace(common$8);
var hasRequiredCache_providers;
function requireCache_providers() {
  if (hasRequiredCache_providers)
    return cache_providers;
  hasRequiredCache_providers = 1;
  Object.defineProperty(cache_providers, "__esModule", { value: true });
  cache_providers.createCacheManager = void 0;
  const load_package_util_1 = requireLoadPackage_util();
  const cache_constants_1 = requireCache_constants();
  const cache_module_definition_1 = requireCache_moduleDefinition();
  const default_options_1 = requireDefaultOptions();
  function createCacheManager() {
    return {
      provide: cache_constants_1.CACHE_MANAGER,
      useFactory: async (options) => {
        const cacheManager = (0, load_package_util_1.loadPackage)("cache-manager", "CacheModule", () => require$$9$3);
        const cacheManagerIsv5OrGreater = "memoryStore" in cacheManager;
        const cachingFactory = async (store, options2) => {
          if (!cacheManagerIsv5OrGreater) {
            return cacheManager.caching(Object.assign(Object.assign({}, default_options_1.defaultCacheOptions), Object.assign(Object.assign({}, options2), { store })));
          }
          let cache2 = "memory";
          default_options_1.defaultCacheOptions.ttl *= 1e3;
          if (typeof store === "object") {
            if ("create" in store) {
              cache2 = store.create;
            } else {
              cache2 = store;
            }
          } else if (typeof store === "function") {
            cache2 = store;
          }
          return cacheManager.caching(cache2, Object.assign(Object.assign({}, default_options_1.defaultCacheOptions), options2));
        };
        return Array.isArray(options) ? cacheManager.multiCaching(await Promise.all(options.map((option) => cachingFactory(option.store, option)))) : cachingFactory(options.store, options);
      },
      inject: [cache_module_definition_1.MODULE_OPTIONS_TOKEN]
    };
  }
  cache_providers.createCacheManager = createCacheManager;
  return cache_providers;
}
var hasRequiredCache_module;
function requireCache_module() {
  if (hasRequiredCache_module)
    return cache_module;
  hasRequiredCache_module = 1;
  Object.defineProperty(cache_module, "__esModule", { value: true });
  cache_module.CacheModule = void 0;
  const tslib_1 = require$$0$3;
  const decorators_1 = requireDecorators$2();
  const cache_constants_1 = requireCache_constants();
  const cache_module_definition_1 = requireCache_moduleDefinition();
  const cache_providers_1 = requireCache_providers();
  let CacheModule = class CacheModule extends cache_module_definition_1.ConfigurableModuleClass {
    /**
     * Configure the cache manager statically.
     *
     * @param options options to configure the cache manager
     *
     * @see [Customize caching](https://docs.nestjs.com/techniques/caching#customize-caching)
     */
    static register(options = {}) {
      return Object.assign({ global: options.isGlobal }, super.register(options));
    }
    /**
     * Configure the cache manager dynamically.
     *
     * @param options method for dynamically supplying cache manager configuration
     * options
     *
     * @see [Async configuration](https://docs.nestjs.com/techniques/caching#async-configuration)
     */
    static registerAsync(options) {
      const moduleDefinition = super.registerAsync(options);
      return Object.assign(Object.assign({ global: options.isGlobal }, moduleDefinition), { providers: options.extraProviders ? moduleDefinition.providers.concat(options.extraProviders) : moduleDefinition.providers });
    }
  };
  CacheModule = tslib_1.__decorate([
    (0, decorators_1.Module)({
      providers: [(0, cache_providers_1.createCacheManager)()],
      exports: [cache_constants_1.CACHE_MANAGER]
    })
  ], CacheModule);
  cache_module.CacheModule = CacheModule;
  return cache_module;
}
var decorators$1 = {};
var cacheKey_decorator = {};
var hasRequiredCacheKey_decorator;
function requireCacheKey_decorator() {
  if (hasRequiredCacheKey_decorator)
    return cacheKey_decorator;
  hasRequiredCacheKey_decorator = 1;
  Object.defineProperty(cacheKey_decorator, "__esModule", { value: true });
  cacheKey_decorator.CacheKey = void 0;
  const decorators_1 = requireDecorators$2();
  const cache_constants_1 = requireCache_constants();
  const CacheKey = (key) => (0, decorators_1.SetMetadata)(cache_constants_1.CACHE_KEY_METADATA, key);
  cacheKey_decorator.CacheKey = CacheKey;
  return cacheKey_decorator;
}
var cacheTtl_decorator = {};
var hasRequiredCacheTtl_decorator;
function requireCacheTtl_decorator() {
  if (hasRequiredCacheTtl_decorator)
    return cacheTtl_decorator;
  hasRequiredCacheTtl_decorator = 1;
  Object.defineProperty(cacheTtl_decorator, "__esModule", { value: true });
  cacheTtl_decorator.CacheTTL = void 0;
  const decorators_1 = requireDecorators$2();
  const cache_constants_1 = requireCache_constants();
  const CacheTTL = (ttl) => (0, decorators_1.SetMetadata)(cache_constants_1.CACHE_TTL_METADATA, ttl);
  cacheTtl_decorator.CacheTTL = CacheTTL;
  return cacheTtl_decorator;
}
var hasRequiredDecorators$1;
function requireDecorators$1() {
  if (hasRequiredDecorators$1)
    return decorators$1;
  hasRequiredDecorators$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireCacheKey_decorator(), exports2);
    tslib_1.__exportStar(requireCacheTtl_decorator(), exports2);
  })(decorators$1);
  return decorators$1;
}
var interceptors$2 = {};
var cache_interceptor = {};
var cjs = {};
var Observable = {};
var Subscriber = {};
var isFunction$3 = {};
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction)
    return isFunction$3;
  hasRequiredIsFunction = 1;
  Object.defineProperty(isFunction$3, "__esModule", { value: true });
  isFunction$3.isFunction = void 0;
  function isFunction2(value) {
    return typeof value === "function";
  }
  isFunction$3.isFunction = isFunction2;
  return isFunction$3;
}
var Subscription = {};
var UnsubscriptionError = {};
var createErrorClass = {};
var hasRequiredCreateErrorClass;
function requireCreateErrorClass() {
  if (hasRequiredCreateErrorClass)
    return createErrorClass;
  hasRequiredCreateErrorClass = 1;
  Object.defineProperty(createErrorClass, "__esModule", { value: true });
  createErrorClass.createErrorClass = void 0;
  function createErrorClass$1(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  createErrorClass.createErrorClass = createErrorClass$1;
  return createErrorClass;
}
var hasRequiredUnsubscriptionError;
function requireUnsubscriptionError() {
  if (hasRequiredUnsubscriptionError)
    return UnsubscriptionError;
  hasRequiredUnsubscriptionError = 1;
  Object.defineProperty(UnsubscriptionError, "__esModule", { value: true });
  UnsubscriptionError.UnsubscriptionError = void 0;
  var createErrorClass_1 = requireCreateErrorClass();
  UnsubscriptionError.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors2) {
      _super(this);
      this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors2;
    };
  });
  return UnsubscriptionError;
}
var arrRemove = {};
var hasRequiredArrRemove;
function requireArrRemove() {
  if (hasRequiredArrRemove)
    return arrRemove;
  hasRequiredArrRemove = 1;
  Object.defineProperty(arrRemove, "__esModule", { value: true });
  arrRemove.arrRemove = void 0;
  function arrRemove$1(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  arrRemove.arrRemove = arrRemove$1;
  return arrRemove;
}
var hasRequiredSubscription;
function requireSubscription() {
  if (hasRequiredSubscription)
    return Subscription;
  hasRequiredSubscription = 1;
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(Subscription, "__esModule", { value: true });
  Subscription.isSubscription = Subscription.EMPTY_SUBSCRIPTION = Subscription.Subscription = void 0;
  var isFunction_1 = requireIsFunction();
  var UnsubscriptionError_1 = requireUnsubscriptionError();
  var arrRemove_1 = requireArrRemove();
  var Subscription$1 = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors2;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values2(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction_1.isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors2 = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values2(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors2 = __spreadArray2(__spreadArray2([], __read2(errors2)), __read2(err.errors));
                } else {
                  errors2.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors2) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors2);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove_1.arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty2 = new Subscription2();
      empty2.closed = true;
      return empty2;
    }();
    return Subscription2;
  }();
  Subscription.Subscription = Subscription$1;
  Subscription.EMPTY_SUBSCRIPTION = Subscription$1.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription$1 || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
  }
  Subscription.isSubscription = isSubscription;
  function execFinalizer(finalizer) {
    if (isFunction_1.isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  return Subscription;
}
var config = {};
var hasRequiredConfig;
function requireConfig() {
  if (hasRequiredConfig)
    return config;
  hasRequiredConfig = 1;
  Object.defineProperty(config, "__esModule", { value: true });
  config.config = void 0;
  config.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
  return config;
}
var reportUnhandledError = {};
var timeoutProvider = {};
var hasRequiredTimeoutProvider;
function requireTimeoutProvider() {
  if (hasRequiredTimeoutProvider)
    return timeoutProvider;
  hasRequiredTimeoutProvider = 1;
  (function(exports2) {
    var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeoutProvider = void 0;
    exports2.timeoutProvider = {
      setTimeout: function(handler, timeout2) {
        var args2 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args2[_i - 2] = arguments[_i];
        }
        var delegate = exports2.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout2], __read2(args2)));
        }
        return setTimeout.apply(void 0, __spreadArray2([handler, timeout2], __read2(args2)));
      },
      clearTimeout: function(handle) {
        var delegate = exports2.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  })(timeoutProvider);
  return timeoutProvider;
}
var hasRequiredReportUnhandledError;
function requireReportUnhandledError() {
  if (hasRequiredReportUnhandledError)
    return reportUnhandledError;
  hasRequiredReportUnhandledError = 1;
  Object.defineProperty(reportUnhandledError, "__esModule", { value: true });
  reportUnhandledError.reportUnhandledError = void 0;
  var config_1 = requireConfig();
  var timeoutProvider_1 = requireTimeoutProvider();
  function reportUnhandledError$1(err) {
    timeoutProvider_1.timeoutProvider.setTimeout(function() {
      var onUnhandledError = config_1.config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }
  reportUnhandledError.reportUnhandledError = reportUnhandledError$1;
  return reportUnhandledError;
}
var noop$2 = {};
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop)
    return noop$2;
  hasRequiredNoop = 1;
  Object.defineProperty(noop$2, "__esModule", { value: true });
  noop$2.noop = void 0;
  function noop2() {
  }
  noop$2.noop = noop2;
  return noop$2;
}
var NotificationFactories = {};
var hasRequiredNotificationFactories;
function requireNotificationFactories() {
  if (hasRequiredNotificationFactories)
    return NotificationFactories;
  hasRequiredNotificationFactories = 1;
  Object.defineProperty(NotificationFactories, "__esModule", { value: true });
  NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
  NotificationFactories.COMPLETE_NOTIFICATION = function() {
    return createNotification("C", void 0, void 0);
  }();
  function errorNotification(error2) {
    return createNotification("E", void 0, error2);
  }
  NotificationFactories.errorNotification = errorNotification;
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  NotificationFactories.nextNotification = nextNotification;
  function createNotification(kind, value, error2) {
    return {
      kind,
      value,
      error: error2
    };
  }
  NotificationFactories.createNotification = createNotification;
  return NotificationFactories;
}
var errorContext = {};
var hasRequiredErrorContext;
function requireErrorContext() {
  if (hasRequiredErrorContext)
    return errorContext;
  hasRequiredErrorContext = 1;
  Object.defineProperty(errorContext, "__esModule", { value: true });
  errorContext.captureError = errorContext.errorContext = void 0;
  var config_1 = requireConfig();
  var context = null;
  function errorContext$1(cb) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error2 = _a.error;
        context = null;
        if (errorThrown) {
          throw error2;
        }
      }
    } else {
      cb();
    }
  }
  errorContext.errorContext = errorContext$1;
  function captureError(err) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }
  errorContext.captureError = captureError;
  return errorContext;
}
var hasRequiredSubscriber;
function requireSubscriber() {
  if (hasRequiredSubscriber)
    return Subscriber;
  hasRequiredSubscriber = 1;
  (function(exports2) {
    var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EMPTY_OBSERVER = exports2.SafeSubscriber = exports2.Subscriber = void 0;
    var isFunction_1 = requireIsFunction();
    var Subscription_1 = requireSubscription();
    var config_1 = requireConfig();
    var reportUnhandledError_1 = requireReportUnhandledError();
    var noop_1 = requireNoop();
    var NotificationFactories_1 = requireNotificationFactories();
    var timeoutProvider_1 = requireTimeoutProvider();
    var errorContext_1 = requireErrorContext();
    var Subscriber2 = function(_super) {
      __extends2(Subscriber3, _super);
      function Subscriber3(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports2.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber3.create = function(next, error2, complete) {
        return new SafeSubscriber(next, error2, complete);
      };
      Subscriber3.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber3.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber3.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber3.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber3.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber3.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber3.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber3;
    }(Subscription_1.Subscription);
    exports2.Subscriber = Subscriber2;
    var _bind = Function.prototype.bind;
    function bind3(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error2) {
            handleUnhandledError(error2);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error2) {
            handleUnhandledError(error2);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error2) {
            handleUnhandledError(error2);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends2(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error2, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error2 !== null && error2 !== void 0 ? error2 : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind3(observerOrNext.next, context_1),
              error: observerOrNext.error && bind3(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind3(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber2);
    exports2.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error2) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error2);
      } else {
        reportUnhandledError_1.reportUnhandledError(error2);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports2.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  })(Subscriber);
  return Subscriber;
}
var observable = {};
var hasRequiredObservable$1;
function requireObservable$1() {
  if (hasRequiredObservable$1)
    return observable;
  hasRequiredObservable$1 = 1;
  Object.defineProperty(observable, "__esModule", { value: true });
  observable.observable = void 0;
  observable.observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  return observable;
}
var pipe = {};
var identity = {};
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity)
    return identity;
  hasRequiredIdentity = 1;
  Object.defineProperty(identity, "__esModule", { value: true });
  identity.identity = void 0;
  function identity$1(x) {
    return x;
  }
  identity.identity = identity$1;
  return identity;
}
var hasRequiredPipe;
function requirePipe() {
  if (hasRequiredPipe)
    return pipe;
  hasRequiredPipe = 1;
  Object.defineProperty(pipe, "__esModule", { value: true });
  pipe.pipeFromArray = pipe.pipe = void 0;
  var identity_1 = requireIdentity();
  function pipe$1() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  pipe.pipe = pipe$1;
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity_1.identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  pipe.pipeFromArray = pipeFromArray;
  return pipe;
}
var hasRequiredObservable;
function requireObservable() {
  if (hasRequiredObservable)
    return Observable;
  hasRequiredObservable = 1;
  Object.defineProperty(Observable, "__esModule", { value: true });
  Observable.Observable = void 0;
  var Subscriber_1 = requireSubscriber();
  var Subscription_1 = requireSubscription();
  var observable_1 = requireObservable$1();
  var pipe_1 = requirePipe();
  var config_1 = requireConfig();
  var isFunction_1 = requireIsFunction();
  var errorContext_1 = requireErrorContext();
  var Observable$1 = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error2, complete);
      errorContext_1.errorContext(function() {
        var _a = _this, operator = _a.operator, source2 = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve2, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve2
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable_1.observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipe_1.pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve2, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve2(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  Observable.Observable = Observable$1;
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
  }
  return Observable;
}
var ConnectableObservable = {};
var refCount = {};
var lift = {};
var hasRequiredLift;
function requireLift() {
  if (hasRequiredLift)
    return lift;
  hasRequiredLift = 1;
  Object.defineProperty(lift, "__esModule", { value: true });
  lift.operate = lift.hasLift = void 0;
  var isFunction_1 = requireIsFunction();
  function hasLift(source2) {
    return isFunction_1.isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
  }
  lift.hasLift = hasLift;
  function operate(init2) {
    return function(source2) {
      if (hasLift(source2)) {
        return source2.lift(function(liftedSource) {
          try {
            return init2(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  lift.operate = operate;
  return lift;
}
var OperatorSubscriber = {};
var hasRequiredOperatorSubscriber;
function requireOperatorSubscriber() {
  if (hasRequiredOperatorSubscriber)
    return OperatorSubscriber;
  hasRequiredOperatorSubscriber = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(OperatorSubscriber, "__esModule", { value: true });
  OperatorSubscriber.OperatorSubscriber = OperatorSubscriber.createOperatorSubscriber = void 0;
  var Subscriber_1 = requireSubscriber();
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber$1(destination, onNext, onComplete, onError, onFinalize);
  }
  OperatorSubscriber.createOperatorSubscriber = createOperatorSubscriber;
  var OperatorSubscriber$1 = function(_super) {
    __extends2(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber_1.Subscriber);
  OperatorSubscriber.OperatorSubscriber = OperatorSubscriber$1;
  return OperatorSubscriber;
}
var hasRequiredRefCount;
function requireRefCount() {
  if (hasRequiredRefCount)
    return refCount;
  hasRequiredRefCount = 1;
  Object.defineProperty(refCount, "__esModule", { value: true });
  refCount.refCount = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function refCount$1() {
    return lift_1.operate(function(source2, subscriber) {
      var connection = null;
      source2._refCount++;
      var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
        if (!source2 || source2._refCount <= 0 || 0 < --source2._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source2._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source2.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source2.connect();
      }
    });
  }
  refCount.refCount = refCount$1;
  return refCount;
}
var hasRequiredConnectableObservable;
function requireConnectableObservable() {
  if (hasRequiredConnectableObservable)
    return ConnectableObservable;
  hasRequiredConnectableObservable = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(ConnectableObservable, "__esModule", { value: true });
  ConnectableObservable.ConnectableObservable = void 0;
  var Observable_1 = requireObservable();
  var Subscription_1 = requireSubscription();
  var refCount_1 = requireRefCount();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var lift_1 = requireLift();
  var ConnectableObservable$1 = function(_super) {
    __extends2(ConnectableObservable2, _super);
    function ConnectableObservable2(source2, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source2;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (lift_1.hasLift(source2)) {
        _this.lift = source2.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription_1.Subscription();
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err) {
          _this._teardown();
          subject_1.error(err);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription_1.Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount_1.refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable_1.Observable);
  ConnectableObservable.ConnectableObservable = ConnectableObservable$1;
  return ConnectableObservable;
}
var animationFrames = {};
var performanceTimestampProvider = {};
var hasRequiredPerformanceTimestampProvider;
function requirePerformanceTimestampProvider() {
  if (hasRequiredPerformanceTimestampProvider)
    return performanceTimestampProvider;
  hasRequiredPerformanceTimestampProvider = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.performanceTimestampProvider = void 0;
    exports2.performanceTimestampProvider = {
      now: function() {
        return (exports2.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  })(performanceTimestampProvider);
  return performanceTimestampProvider;
}
var animationFrameProvider = {};
var hasRequiredAnimationFrameProvider;
function requireAnimationFrameProvider() {
  if (hasRequiredAnimationFrameProvider)
    return animationFrameProvider;
  hasRequiredAnimationFrameProvider = 1;
  (function(exports2) {
    var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrameProvider = void 0;
    var Subscription_1 = requireSubscription();
    exports2.animationFrameProvider = {
      schedule: function(callback) {
        var request2 = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports2.animationFrameProvider.delegate;
        if (delegate) {
          request2 = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request2(function(timestamp2) {
          cancel = void 0;
          callback(timestamp2);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read2(args2)));
      },
      cancelAnimationFrame: function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read2(args2)));
      },
      delegate: void 0
    };
  })(animationFrameProvider);
  return animationFrameProvider;
}
var hasRequiredAnimationFrames;
function requireAnimationFrames() {
  if (hasRequiredAnimationFrames)
    return animationFrames;
  hasRequiredAnimationFrames = 1;
  Object.defineProperty(animationFrames, "__esModule", { value: true });
  animationFrames.animationFrames = void 0;
  var Observable_1 = requireObservable();
  var performanceTimestampProvider_1 = requirePerformanceTimestampProvider();
  var animationFrameProvider_1 = requireAnimationFrameProvider();
  function animationFrames$1(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
  }
  animationFrames.animationFrames = animationFrames$1;
  function animationFramesFactory(timestampProvider) {
    return new Observable_1.Observable(function(subscriber) {
      var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
      var start = provider.now();
      var id2 = 0;
      var run = function() {
        if (!subscriber.closed) {
          id2 = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp2) {
            id2 = 0;
            var now = provider.now();
            subscriber.next({
              timestamp: timestampProvider ? now : timestamp2,
              elapsed: now - start
            });
            run();
          });
        }
      };
      run();
      return function() {
        if (id2) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id2);
        }
      };
    });
  }
  var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  return animationFrames;
}
var Subject = {};
var ObjectUnsubscribedError = {};
var hasRequiredObjectUnsubscribedError;
function requireObjectUnsubscribedError() {
  if (hasRequiredObjectUnsubscribedError)
    return ObjectUnsubscribedError;
  hasRequiredObjectUnsubscribedError = 1;
  Object.defineProperty(ObjectUnsubscribedError, "__esModule", { value: true });
  ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
  var createErrorClass_1 = requireCreateErrorClass();
  ObjectUnsubscribedError.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
  return ObjectUnsubscribedError;
}
var hasRequiredSubject;
function requireSubject() {
  if (hasRequiredSubject)
    return Subject;
  hasRequiredSubject = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(Subject, "__esModule", { value: true });
  Subject.AnonymousSubject = Subject.Subject = void 0;
  var Observable_1 = requireObservable();
  var Subscription_1 = requireSubscription();
  var ObjectUnsubscribedError_1 = requireObjectUnsubscribedError();
  var arrRemove_1 = requireArrRemove();
  var errorContext_1 = requireErrorContext();
  var Subject$1 = function(_super) {
    __extends2(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext_1.errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values2(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return Subscription_1.EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription_1.Subscription(function() {
        _this.currentObservers = null;
        arrRemove_1.arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable_1.Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source2) {
      return new AnonymousSubject(destination, source2);
    };
    return Subject2;
  }(Observable_1.Observable);
  Subject.Subject = Subject$1;
  var AnonymousSubject = function(_super) {
    __extends2(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source2) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source2;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject$1);
  Subject.AnonymousSubject = AnonymousSubject;
  return Subject;
}
var BehaviorSubject = {};
var hasRequiredBehaviorSubject;
function requireBehaviorSubject() {
  if (hasRequiredBehaviorSubject)
    return BehaviorSubject;
  hasRequiredBehaviorSubject = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(BehaviorSubject, "__esModule", { value: true });
  BehaviorSubject.BehaviorSubject = void 0;
  var Subject_1 = requireSubject();
  var BehaviorSubject$1 = function(_super) {
    __extends2(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject_1.Subject);
  BehaviorSubject.BehaviorSubject = BehaviorSubject$1;
  return BehaviorSubject;
}
var ReplaySubject = {};
var dateTimestampProvider = {};
var hasRequiredDateTimestampProvider;
function requireDateTimestampProvider() {
  if (hasRequiredDateTimestampProvider)
    return dateTimestampProvider;
  hasRequiredDateTimestampProvider = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dateTimestampProvider = void 0;
    exports2.dateTimestampProvider = {
      now: function() {
        return (exports2.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  })(dateTimestampProvider);
  return dateTimestampProvider;
}
var hasRequiredReplaySubject;
function requireReplaySubject() {
  if (hasRequiredReplaySubject)
    return ReplaySubject;
  hasRequiredReplaySubject = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(ReplaySubject, "__esModule", { value: true });
  ReplaySubject.ReplaySubject = void 0;
  var Subject_1 = requireSubject();
  var dateTimestampProvider_1 = requireDateTimestampProvider();
  var ReplaySubject$1 = function(_super) {
    __extends2(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === void 0) {
        _bufferSize = Infinity;
      }
      if (_windowTime === void 0) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === void 0) {
        _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
      var copy = _buffer.slice();
      for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last2 = 0;
        for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
          last2 = i;
        }
        last2 && _buffer.splice(0, last2 + 1);
      }
    };
    return ReplaySubject2;
  }(Subject_1.Subject);
  ReplaySubject.ReplaySubject = ReplaySubject$1;
  return ReplaySubject;
}
var AsyncSubject = {};
var hasRequiredAsyncSubject;
function requireAsyncSubject() {
  if (hasRequiredAsyncSubject)
    return AsyncSubject;
  hasRequiredAsyncSubject = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsyncSubject, "__esModule", { value: true });
  AsyncSubject.AsyncSubject = void 0;
  var Subject_1 = requireSubject();
  var AsyncSubject$1 = function(_super) {
    __extends2(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._value = null;
      _this._hasValue = false;
      _this._isComplete = false;
      return _this;
    }
    AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped || _isComplete) {
        _hasValue && subscriber.next(_value);
        subscriber.complete();
      }
    };
    AsyncSubject2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._value = value;
        this._hasValue = true;
      }
    };
    AsyncSubject2.prototype.complete = function() {
      var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
      if (!_isComplete) {
        this._isComplete = true;
        _hasValue && _super.prototype.next.call(this, _value);
        _super.prototype.complete.call(this);
      }
    };
    return AsyncSubject2;
  }(Subject_1.Subject);
  AsyncSubject.AsyncSubject = AsyncSubject$1;
  return AsyncSubject;
}
var asap$1 = {};
var AsapAction = {};
var AsyncAction = {};
var Action = {};
var hasRequiredAction;
function requireAction() {
  if (hasRequiredAction)
    return Action;
  hasRequiredAction = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(Action, "__esModule", { value: true });
  Action.Action = void 0;
  var Subscription_1 = requireSubscription();
  var Action$1 = function(_super) {
    __extends2(Action2, _super);
    function Action2(scheduler2, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state2, delay2) {
      return this;
    };
    return Action2;
  }(Subscription_1.Subscription);
  Action.Action = Action$1;
  return Action;
}
var intervalProvider = {};
var hasRequiredIntervalProvider;
function requireIntervalProvider() {
  if (hasRequiredIntervalProvider)
    return intervalProvider;
  hasRequiredIntervalProvider = 1;
  (function(exports2) {
    var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.intervalProvider = void 0;
    exports2.intervalProvider = {
      setInterval: function(handler, timeout2) {
        var args2 = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args2[_i - 2] = arguments[_i];
        }
        var delegate = exports2.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout2], __read2(args2)));
        }
        return setInterval.apply(void 0, __spreadArray2([handler, timeout2], __read2(args2)));
      },
      clearInterval: function(handle) {
        var delegate = exports2.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  })(intervalProvider);
  return intervalProvider;
}
var hasRequiredAsyncAction;
function requireAsyncAction() {
  if (hasRequiredAsyncAction)
    return AsyncAction;
  hasRequiredAsyncAction = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsyncAction, "__esModule", { value: true });
  AsyncAction.AsyncAction = void 0;
  var Action_1 = requireAction();
  var intervalProvider_1 = requireIntervalProvider();
  var arrRemove_1 = requireArrRemove();
  var AsyncAction$1 = function(_super) {
    __extends2(AsyncAction2, _super);
    function AsyncAction2(scheduler2, work) {
      var _this = _super.call(this, scheduler2, work) || this;
      _this.scheduler = scheduler2;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state2, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state2;
      var id2 = this.id;
      var scheduler2 = this.scheduler;
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler2, id2, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler2, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler2, _id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return intervalProvider_1.intervalProvider.setInterval(scheduler2.flush.bind(scheduler2, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && this.delay === delay2 && this.pending === false) {
        return id2;
      }
      if (id2 != null) {
        intervalProvider_1.intervalProvider.clearInterval(id2);
      }
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state2, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error2 = this._execute(state2, delay2);
      if (error2) {
        return error2;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state2, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state2);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id2 = _a.id, scheduler2 = _a.scheduler;
        var actions = scheduler2.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove_1.arrRemove(actions, this);
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler2, id2, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action_1.Action);
  AsyncAction.AsyncAction = AsyncAction$1;
  return AsyncAction;
}
var immediateProvider = {};
var Immediate = {};
var hasRequiredImmediate;
function requireImmediate() {
  if (hasRequiredImmediate)
    return Immediate;
  hasRequiredImmediate = 1;
  Object.defineProperty(Immediate, "__esModule", { value: true });
  Immediate.TestTools = Immediate.Immediate = void 0;
  var nextHandle = 1;
  var resolved;
  var activeHandles = {};
  function findAndClearHandle(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  }
  Immediate.Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      if (!resolved) {
        resolved = Promise.resolve();
      }
      resolved.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  Immediate.TestTools = {
    pending: function() {
      return Object.keys(activeHandles).length;
    }
  };
  return Immediate;
}
var hasRequiredImmediateProvider;
function requireImmediateProvider() {
  if (hasRequiredImmediateProvider)
    return immediateProvider;
  hasRequiredImmediateProvider = 1;
  (function(exports2) {
    var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.immediateProvider = void 0;
    var Immediate_1 = requireImmediate();
    var setImmediate2 = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;
    exports2.immediateProvider = {
      setImmediate: function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray2([], __read2(args2)));
      },
      clearImmediate: function(handle) {
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  })(immediateProvider);
  return immediateProvider;
}
var hasRequiredAsapAction;
function requireAsapAction() {
  if (hasRequiredAsapAction)
    return AsapAction;
  hasRequiredAsapAction = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsapAction, "__esModule", { value: true });
  AsapAction.AsapAction = void 0;
  var AsyncAction_1 = requireAsyncAction();
  var immediateProvider_1 = requireImmediateProvider();
  var AsapAction$1 = function(_super) {
    __extends2(AsapAction2, _super);
    function AsapAction2(scheduler2, work) {
      var _this = _super.call(this, scheduler2, work) || this;
      _this.scheduler = scheduler2;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
      }
      scheduler2.actions.push(this);
      return scheduler2._scheduled || (scheduler2._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler2.flush.bind(scheduler2, void 0)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null ? delay2 > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
      }
      var actions = scheduler2.actions;
      if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
        immediateProvider_1.immediateProvider.clearImmediate(id2);
        if (scheduler2._scheduled === id2) {
          scheduler2._scheduled = void 0;
        }
      }
      return void 0;
    };
    return AsapAction2;
  }(AsyncAction_1.AsyncAction);
  AsapAction.AsapAction = AsapAction$1;
  return AsapAction;
}
var AsapScheduler = {};
var AsyncScheduler = {};
var Scheduler$1 = {};
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler)
    return Scheduler$1;
  hasRequiredScheduler = 1;
  Object.defineProperty(Scheduler$1, "__esModule", { value: true });
  Scheduler$1.Scheduler = void 0;
  var dateTimestampProvider_1 = requireDateTimestampProvider();
  var Scheduler2 = function() {
    function Scheduler3(schedulerActionCtor, now) {
      if (now === void 0) {
        now = Scheduler3.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler3.prototype.schedule = function(work, delay2, state2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state2, delay2);
    };
    Scheduler3.now = dateTimestampProvider_1.dateTimestampProvider.now;
    return Scheduler3;
  }();
  Scheduler$1.Scheduler = Scheduler2;
  return Scheduler$1;
}
var hasRequiredAsyncScheduler;
function requireAsyncScheduler() {
  if (hasRequiredAsyncScheduler)
    return AsyncScheduler;
  hasRequiredAsyncScheduler = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsyncScheduler, "__esModule", { value: true });
  AsyncScheduler.AsyncScheduler = void 0;
  var Scheduler_1 = requireScheduler();
  var AsyncScheduler$1 = function(_super) {
    __extends2(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler_1.Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error2;
      this._active = true;
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error2) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AsyncScheduler2;
  }(Scheduler_1.Scheduler);
  AsyncScheduler.AsyncScheduler = AsyncScheduler$1;
  return AsyncScheduler;
}
var hasRequiredAsapScheduler;
function requireAsapScheduler() {
  if (hasRequiredAsapScheduler)
    return AsapScheduler;
  hasRequiredAsapScheduler = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AsapScheduler, "__esModule", { value: true });
  AsapScheduler.AsapScheduler = void 0;
  var AsyncScheduler_1 = requireAsyncScheduler();
  var AsapScheduler$1 = function(_super) {
    __extends2(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = void 0;
      var actions = this.actions;
      var error2;
      action = action || actions.shift();
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error2) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  AsapScheduler.AsapScheduler = AsapScheduler$1;
  return AsapScheduler;
}
var hasRequiredAsap;
function requireAsap() {
  if (hasRequiredAsap)
    return asap$1;
  hasRequiredAsap = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asap = exports2.asapScheduler = void 0;
    var AsapAction_1 = requireAsapAction();
    var AsapScheduler_1 = requireAsapScheduler();
    exports2.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports2.asap = exports2.asapScheduler;
  })(asap$1);
  return asap$1;
}
var async$3 = {};
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync)
    return async$3;
  hasRequiredAsync = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.async = exports2.asyncScheduler = void 0;
    var AsyncAction_1 = requireAsyncAction();
    var AsyncScheduler_1 = requireAsyncScheduler();
    exports2.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports2.async = exports2.asyncScheduler;
  })(async$3);
  return async$3;
}
var queue = {};
var QueueAction = {};
var hasRequiredQueueAction;
function requireQueueAction() {
  if (hasRequiredQueueAction)
    return QueueAction;
  hasRequiredQueueAction = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(QueueAction, "__esModule", { value: true });
  QueueAction.QueueAction = void 0;
  var AsyncAction_1 = requireAsyncAction();
  var QueueAction$1 = function(_super) {
    __extends2(QueueAction2, _super);
    function QueueAction2(scheduler2, work) {
      var _this = _super.call(this, scheduler2, work) || this;
      _this.scheduler = scheduler2;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 > 0) {
        return _super.prototype.schedule.call(this, state2, delay2);
      }
      this.delay = delay2;
      this.state = state2;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state2, delay2) {
      return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
      }
      scheduler2.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction_1.AsyncAction);
  QueueAction.QueueAction = QueueAction$1;
  return QueueAction;
}
var QueueScheduler = {};
var hasRequiredQueueScheduler;
function requireQueueScheduler() {
  if (hasRequiredQueueScheduler)
    return QueueScheduler;
  hasRequiredQueueScheduler = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(QueueScheduler, "__esModule", { value: true });
  QueueScheduler.QueueScheduler = void 0;
  var AsyncScheduler_1 = requireAsyncScheduler();
  var QueueScheduler$1 = function(_super) {
    __extends2(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  QueueScheduler.QueueScheduler = QueueScheduler$1;
  return QueueScheduler;
}
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue)
    return queue;
  hasRequiredQueue = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.queue = exports2.queueScheduler = void 0;
    var QueueAction_1 = requireQueueAction();
    var QueueScheduler_1 = requireQueueScheduler();
    exports2.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports2.queue = exports2.queueScheduler;
  })(queue);
  return queue;
}
var animationFrame = {};
var AnimationFrameAction = {};
var hasRequiredAnimationFrameAction;
function requireAnimationFrameAction() {
  if (hasRequiredAnimationFrameAction)
    return AnimationFrameAction;
  hasRequiredAnimationFrameAction = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AnimationFrameAction, "__esModule", { value: true });
  AnimationFrameAction.AnimationFrameAction = void 0;
  var AsyncAction_1 = requireAsyncAction();
  var animationFrameProvider_1 = requireAnimationFrameProvider();
  var AnimationFrameAction$1 = function(_super) {
    __extends2(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler2, work) {
      var _this = _super.call(this, scheduler2, work) || this;
      _this.scheduler = scheduler2;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
      }
      scheduler2.actions.push(this);
      return scheduler2._scheduled || (scheduler2._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
        return scheduler2.flush(void 0);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null ? delay2 > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
      }
      var actions = scheduler2.actions;
      if (id2 != null && id2 === scheduler2._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
        animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id2);
        scheduler2._scheduled = void 0;
      }
      return void 0;
    };
    return AnimationFrameAction2;
  }(AsyncAction_1.AsyncAction);
  AnimationFrameAction.AnimationFrameAction = AnimationFrameAction$1;
  return AnimationFrameAction;
}
var AnimationFrameScheduler = {};
var hasRequiredAnimationFrameScheduler;
function requireAnimationFrameScheduler() {
  if (hasRequiredAnimationFrameScheduler)
    return AnimationFrameScheduler;
  hasRequiredAnimationFrameScheduler = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(AnimationFrameScheduler, "__esModule", { value: true });
  AnimationFrameScheduler.AnimationFrameScheduler = void 0;
  var AsyncScheduler_1 = requireAsyncScheduler();
  var AnimationFrameScheduler$1 = function(_super) {
    __extends2(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId;
      if (action) {
        flushId = action.id;
      } else {
        flushId = this._scheduled;
        this._scheduled = void 0;
      }
      var actions = this.actions;
      var error2;
      action = action || actions.shift();
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error2) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  AnimationFrameScheduler.AnimationFrameScheduler = AnimationFrameScheduler$1;
  return AnimationFrameScheduler;
}
var hasRequiredAnimationFrame;
function requireAnimationFrame() {
  if (hasRequiredAnimationFrame)
    return animationFrame;
  hasRequiredAnimationFrame = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrame = exports2.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = requireAnimationFrameAction();
    var AnimationFrameScheduler_1 = requireAnimationFrameScheduler();
    exports2.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports2.animationFrame = exports2.animationFrameScheduler;
  })(animationFrame);
  return animationFrame;
}
var VirtualTimeScheduler = {};
var hasRequiredVirtualTimeScheduler;
function requireVirtualTimeScheduler() {
  if (hasRequiredVirtualTimeScheduler)
    return VirtualTimeScheduler;
  hasRequiredVirtualTimeScheduler = 1;
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(VirtualTimeScheduler, "__esModule", { value: true });
  VirtualTimeScheduler.VirtualAction = VirtualTimeScheduler.VirtualTimeScheduler = void 0;
  var AsyncAction_1 = requireAsyncAction();
  var Subscription_1 = requireSubscription();
  var AsyncScheduler_1 = requireAsyncScheduler();
  var VirtualTimeScheduler$1 = function(_super) {
    __extends2(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
      if (schedulerActionCtor === void 0) {
        schedulerActionCtor = VirtualAction;
      }
      if (maxFrames === void 0) {
        maxFrames = Infinity;
      }
      var _this = _super.call(this, schedulerActionCtor, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
      var error2;
      var action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error2) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  VirtualTimeScheduler.VirtualTimeScheduler = VirtualTimeScheduler$1;
  var VirtualAction = function(_super) {
    __extends2(VirtualAction2, _super);
    function VirtualAction2(scheduler2, work, index) {
      if (index === void 0) {
        index = scheduler2.index += 1;
      }
      var _this = _super.call(this, scheduler2, work) || this;
      _this.scheduler = scheduler2;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler2.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (Number.isFinite(delay2)) {
        if (!this.id) {
          return _super.prototype.schedule.call(this, state2, delay2);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state2, delay2);
      } else {
        return Subscription_1.Subscription.EMPTY;
      }
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      this.delay = scheduler2.frame + delay2;
      var actions = scheduler2.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return 1;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
      return void 0;
    };
    VirtualAction2.prototype._execute = function(state2, delay2) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state2, delay2);
      }
    };
    VirtualAction2.sortActions = function(a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction_1.AsyncAction);
  VirtualTimeScheduler.VirtualAction = VirtualAction;
  return VirtualTimeScheduler;
}
var Notification = {};
var empty = {};
var hasRequiredEmpty;
function requireEmpty() {
  if (hasRequiredEmpty)
    return empty;
  hasRequiredEmpty = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.empty = exports2.EMPTY = void 0;
    var Observable_1 = requireObservable();
    exports2.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty2(scheduler2) {
      return scheduler2 ? emptyScheduled(scheduler2) : exports2.EMPTY;
    }
    exports2.empty = empty2;
    function emptyScheduled(scheduler2) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler2.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  })(empty);
  return empty;
}
var of = {};
var args = {};
var isScheduler = {};
var hasRequiredIsScheduler;
function requireIsScheduler() {
  if (hasRequiredIsScheduler)
    return isScheduler;
  hasRequiredIsScheduler = 1;
  Object.defineProperty(isScheduler, "__esModule", { value: true });
  isScheduler.isScheduler = void 0;
  var isFunction_1 = requireIsFunction();
  function isScheduler$1(value) {
    return value && isFunction_1.isFunction(value.schedule);
  }
  isScheduler.isScheduler = isScheduler$1;
  return isScheduler;
}
var hasRequiredArgs;
function requireArgs() {
  if (hasRequiredArgs)
    return args;
  hasRequiredArgs = 1;
  Object.defineProperty(args, "__esModule", { value: true });
  args.popNumber = args.popScheduler = args.popResultSelector = void 0;
  var isFunction_1 = requireIsFunction();
  var isScheduler_1 = requireIsScheduler();
  function last2(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args2) {
    return isFunction_1.isFunction(last2(args2)) ? args2.pop() : void 0;
  }
  args.popResultSelector = popResultSelector;
  function popScheduler(args2) {
    return isScheduler_1.isScheduler(last2(args2)) ? args2.pop() : void 0;
  }
  args.popScheduler = popScheduler;
  function popNumber(args2, defaultValue) {
    return typeof last2(args2) === "number" ? args2.pop() : defaultValue;
  }
  args.popNumber = popNumber;
  return args;
}
var from = {};
var scheduled = {};
var scheduleObservable = {};
var innerFrom = {};
var isArrayLike = {};
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike)
    return isArrayLike;
  hasRequiredIsArrayLike = 1;
  Object.defineProperty(isArrayLike, "__esModule", { value: true });
  isArrayLike.isArrayLike = void 0;
  isArrayLike.isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };
  return isArrayLike;
}
var isPromise = {};
var hasRequiredIsPromise;
function requireIsPromise() {
  if (hasRequiredIsPromise)
    return isPromise;
  hasRequiredIsPromise = 1;
  Object.defineProperty(isPromise, "__esModule", { value: true });
  isPromise.isPromise = void 0;
  var isFunction_1 = requireIsFunction();
  function isPromise$1(value) {
    return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
  }
  isPromise.isPromise = isPromise$1;
  return isPromise;
}
var isInteropObservable = {};
var hasRequiredIsInteropObservable;
function requireIsInteropObservable() {
  if (hasRequiredIsInteropObservable)
    return isInteropObservable;
  hasRequiredIsInteropObservable = 1;
  Object.defineProperty(isInteropObservable, "__esModule", { value: true });
  isInteropObservable.isInteropObservable = void 0;
  var observable_1 = requireObservable$1();
  var isFunction_1 = requireIsFunction();
  function isInteropObservable$1(input) {
    return isFunction_1.isFunction(input[observable_1.observable]);
  }
  isInteropObservable.isInteropObservable = isInteropObservable$1;
  return isInteropObservable;
}
var isAsyncIterable = {};
var hasRequiredIsAsyncIterable;
function requireIsAsyncIterable() {
  if (hasRequiredIsAsyncIterable)
    return isAsyncIterable;
  hasRequiredIsAsyncIterable = 1;
  Object.defineProperty(isAsyncIterable, "__esModule", { value: true });
  isAsyncIterable.isAsyncIterable = void 0;
  var isFunction_1 = requireIsFunction();
  function isAsyncIterable$1(obj) {
    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }
  isAsyncIterable.isAsyncIterable = isAsyncIterable$1;
  return isAsyncIterable;
}
var throwUnobservableError = {};
var hasRequiredThrowUnobservableError;
function requireThrowUnobservableError() {
  if (hasRequiredThrowUnobservableError)
    return throwUnobservableError;
  hasRequiredThrowUnobservableError = 1;
  Object.defineProperty(throwUnobservableError, "__esModule", { value: true });
  throwUnobservableError.createInvalidObservableTypeError = void 0;
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;
  return throwUnobservableError;
}
var isIterable$1 = {};
var iterator$1 = {};
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator$1;
  hasRequiredIterator = 1;
  Object.defineProperty(iterator$1, "__esModule", { value: true });
  iterator$1.iterator = iterator$1.getSymbolIterator = void 0;
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  iterator$1.getSymbolIterator = getSymbolIterator;
  iterator$1.iterator = getSymbolIterator();
  return iterator$1;
}
var hasRequiredIsIterable;
function requireIsIterable() {
  if (hasRequiredIsIterable)
    return isIterable$1;
  hasRequiredIsIterable = 1;
  Object.defineProperty(isIterable$1, "__esModule", { value: true });
  isIterable$1.isIterable = void 0;
  var iterator_1 = requireIterator();
  var isFunction_1 = requireIsFunction();
  function isIterable2(input) {
    return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
  }
  isIterable$1.isIterable = isIterable2;
  return isIterable$1;
}
var isReadableStreamLike = {};
var hasRequiredIsReadableStreamLike;
function requireIsReadableStreamLike() {
  if (hasRequiredIsReadableStreamLike)
    return isReadableStreamLike;
  hasRequiredIsReadableStreamLike = 1;
  var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __await2 = commonjsGlobal && commonjsGlobal.__await || function(v) {
    return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
  };
  var __asyncGenerator2 = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle2(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle2(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(isReadableStreamLike, "__esModule", { value: true });
  isReadableStreamLike.isReadableStreamLike = isReadableStreamLike.readableStreamLikeToAsyncGenerator = void 0;
  var isFunction_1 = requireIsFunction();
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator2(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator2(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            return [4, __await2(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await2(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await2(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  isReadableStreamLike.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
  function isReadableStreamLike$1(obj) {
    return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }
  isReadableStreamLike.isReadableStreamLike = isReadableStreamLike$1;
  return isReadableStreamLike;
}
var hasRequiredInnerFrom;
function requireInnerFrom() {
  if (hasRequiredInnerFrom)
    return innerFrom;
  hasRequiredInnerFrom = 1;
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __asyncValues2 = commonjsGlobal && commonjsGlobal.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve2, reject) {
          v = o[n](v), settle2(resolve2, reject, v.done, v.value);
        });
      };
    }
    function settle2(resolve2, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve2({ value: v2, done: d });
      }, reject);
    }
  };
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(innerFrom, "__esModule", { value: true });
  innerFrom.fromReadableStreamLike = innerFrom.fromAsyncIterable = innerFrom.fromIterable = innerFrom.fromPromise = innerFrom.fromArrayLike = innerFrom.fromInteropObservable = innerFrom.innerFrom = void 0;
  var isArrayLike_1 = requireIsArrayLike();
  var isPromise_1 = requireIsPromise();
  var Observable_1 = requireObservable();
  var isInteropObservable_1 = requireIsInteropObservable();
  var isAsyncIterable_1 = requireIsAsyncIterable();
  var throwUnobservableError_1 = requireThrowUnobservableError();
  var isIterable_1 = requireIsIterable();
  var isReadableStreamLike_1 = requireIsReadableStreamLike();
  var isFunction_1 = requireIsFunction();
  var reportUnhandledError_1 = requireReportUnhandledError();
  var observable_1 = requireObservable$1();
  function innerFrom$1(input) {
    if (input instanceof Observable_1.Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise_1.isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable_1.isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  innerFrom.innerFrom = innerFrom$1;
  function fromInteropObservable(obj) {
    return new Observable_1.Observable(function(subscriber) {
      var obs = obj[observable_1.observable]();
      if (isFunction_1.isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  innerFrom.fromInteropObservable = fromInteropObservable;
  function fromArrayLike(array) {
    return new Observable_1.Observable(function(subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  innerFrom.fromArrayLike = fromArrayLike;
  function fromPromise(promise) {
    return new Observable_1.Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError_1.reportUnhandledError);
    });
  }
  innerFrom.fromPromise = fromPromise;
  function fromIterable(iterable) {
    return new Observable_1.Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values2(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  innerFrom.fromIterable = fromIterable;
  function fromAsyncIterable(asyncIterable) {
    return new Observable_1.Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  innerFrom.fromAsyncIterable = fromAsyncIterable;
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
  }
  innerFrom.fromReadableStreamLike = fromReadableStreamLike;
  function process2(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter2(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator2(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues2(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
  return innerFrom;
}
var observeOn = {};
var executeSchedule = {};
var hasRequiredExecuteSchedule;
function requireExecuteSchedule() {
  if (hasRequiredExecuteSchedule)
    return executeSchedule;
  hasRequiredExecuteSchedule = 1;
  Object.defineProperty(executeSchedule, "__esModule", { value: true });
  executeSchedule.executeSchedule = void 0;
  function executeSchedule$1(parentSubscription, scheduler2, work, delay2, repeat2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (repeat2 === void 0) {
      repeat2 = false;
    }
    var scheduleSubscription = scheduler2.schedule(function() {
      work();
      if (repeat2) {
        parentSubscription.add(this.schedule(null, delay2));
      } else {
        this.unsubscribe();
      }
    }, delay2);
    parentSubscription.add(scheduleSubscription);
    if (!repeat2) {
      return scheduleSubscription;
    }
  }
  executeSchedule.executeSchedule = executeSchedule$1;
  return executeSchedule;
}
var hasRequiredObserveOn;
function requireObserveOn() {
  if (hasRequiredObserveOn)
    return observeOn;
  hasRequiredObserveOn = 1;
  Object.defineProperty(observeOn, "__esModule", { value: true });
  observeOn.observeOn = void 0;
  var executeSchedule_1 = requireExecuteSchedule();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function observeOn$1(scheduler2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return lift_1.operate(function(source2, subscriber) {
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler2, function() {
          return subscriber.next(value);
        }, delay2);
      }, function() {
        return executeSchedule_1.executeSchedule(subscriber, scheduler2, function() {
          return subscriber.complete();
        }, delay2);
      }, function(err) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler2, function() {
          return subscriber.error(err);
        }, delay2);
      }));
    });
  }
  observeOn.observeOn = observeOn$1;
  return observeOn;
}
var subscribeOn = {};
var hasRequiredSubscribeOn;
function requireSubscribeOn() {
  if (hasRequiredSubscribeOn)
    return subscribeOn;
  hasRequiredSubscribeOn = 1;
  Object.defineProperty(subscribeOn, "__esModule", { value: true });
  subscribeOn.subscribeOn = void 0;
  var lift_1 = requireLift();
  function subscribeOn$1(scheduler2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return lift_1.operate(function(source2, subscriber) {
      subscriber.add(scheduler2.schedule(function() {
        return source2.subscribe(subscriber);
      }, delay2));
    });
  }
  subscribeOn.subscribeOn = subscribeOn$1;
  return subscribeOn;
}
var hasRequiredScheduleObservable;
function requireScheduleObservable() {
  if (hasRequiredScheduleObservable)
    return scheduleObservable;
  hasRequiredScheduleObservable = 1;
  Object.defineProperty(scheduleObservable, "__esModule", { value: true });
  scheduleObservable.scheduleObservable = void 0;
  var innerFrom_1 = requireInnerFrom();
  var observeOn_1 = requireObserveOn();
  var subscribeOn_1 = requireSubscribeOn();
  function scheduleObservable$1(input, scheduler2) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler2), observeOn_1.observeOn(scheduler2));
  }
  scheduleObservable.scheduleObservable = scheduleObservable$1;
  return scheduleObservable;
}
var schedulePromise = {};
var hasRequiredSchedulePromise;
function requireSchedulePromise() {
  if (hasRequiredSchedulePromise)
    return schedulePromise;
  hasRequiredSchedulePromise = 1;
  Object.defineProperty(schedulePromise, "__esModule", { value: true });
  schedulePromise.schedulePromise = void 0;
  var innerFrom_1 = requireInnerFrom();
  var observeOn_1 = requireObserveOn();
  var subscribeOn_1 = requireSubscribeOn();
  function schedulePromise$1(input, scheduler2) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler2), observeOn_1.observeOn(scheduler2));
  }
  schedulePromise.schedulePromise = schedulePromise$1;
  return schedulePromise;
}
var scheduleArray = {};
var hasRequiredScheduleArray;
function requireScheduleArray() {
  if (hasRequiredScheduleArray)
    return scheduleArray;
  hasRequiredScheduleArray = 1;
  Object.defineProperty(scheduleArray, "__esModule", { value: true });
  scheduleArray.scheduleArray = void 0;
  var Observable_1 = requireObservable();
  function scheduleArray$1(input, scheduler2) {
    return new Observable_1.Observable(function(subscriber) {
      var i = 0;
      return scheduler2.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  scheduleArray.scheduleArray = scheduleArray$1;
  return scheduleArray;
}
var scheduleIterable = {};
var hasRequiredScheduleIterable;
function requireScheduleIterable() {
  if (hasRequiredScheduleIterable)
    return scheduleIterable;
  hasRequiredScheduleIterable = 1;
  Object.defineProperty(scheduleIterable, "__esModule", { value: true });
  scheduleIterable.scheduleIterable = void 0;
  var Observable_1 = requireObservable();
  var iterator_1 = requireIterator();
  var isFunction_1 = requireIsFunction();
  var executeSchedule_1 = requireExecuteSchedule();
  function scheduleIterable$1(input, scheduler2) {
    return new Observable_1.Observable(function(subscriber) {
      var iterator2;
      executeSchedule_1.executeSchedule(subscriber, scheduler2, function() {
        iterator2 = input[iterator_1.iterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler2, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator2.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction_1.isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }
  scheduleIterable.scheduleIterable = scheduleIterable$1;
  return scheduleIterable;
}
var scheduleAsyncIterable = {};
var hasRequiredScheduleAsyncIterable;
function requireScheduleAsyncIterable() {
  if (hasRequiredScheduleAsyncIterable)
    return scheduleAsyncIterable;
  hasRequiredScheduleAsyncIterable = 1;
  Object.defineProperty(scheduleAsyncIterable, "__esModule", { value: true });
  scheduleAsyncIterable.scheduleAsyncIterable = void 0;
  var Observable_1 = requireObservable();
  var executeSchedule_1 = requireExecuteSchedule();
  function scheduleAsyncIterable$1(input, scheduler2) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable_1.Observable(function(subscriber) {
      executeSchedule_1.executeSchedule(subscriber, scheduler2, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler2, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  scheduleAsyncIterable.scheduleAsyncIterable = scheduleAsyncIterable$1;
  return scheduleAsyncIterable;
}
var scheduleReadableStreamLike = {};
var hasRequiredScheduleReadableStreamLike;
function requireScheduleReadableStreamLike() {
  if (hasRequiredScheduleReadableStreamLike)
    return scheduleReadableStreamLike;
  hasRequiredScheduleReadableStreamLike = 1;
  Object.defineProperty(scheduleReadableStreamLike, "__esModule", { value: true });
  scheduleReadableStreamLike.scheduleReadableStreamLike = void 0;
  var scheduleAsyncIterable_1 = requireScheduleAsyncIterable();
  var isReadableStreamLike_1 = requireIsReadableStreamLike();
  function scheduleReadableStreamLike$1(input, scheduler2) {
    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler2);
  }
  scheduleReadableStreamLike.scheduleReadableStreamLike = scheduleReadableStreamLike$1;
  return scheduleReadableStreamLike;
}
var hasRequiredScheduled;
function requireScheduled() {
  if (hasRequiredScheduled)
    return scheduled;
  hasRequiredScheduled = 1;
  Object.defineProperty(scheduled, "__esModule", { value: true });
  scheduled.scheduled = void 0;
  var scheduleObservable_1 = requireScheduleObservable();
  var schedulePromise_1 = requireSchedulePromise();
  var scheduleArray_1 = requireScheduleArray();
  var scheduleIterable_1 = requireScheduleIterable();
  var scheduleAsyncIterable_1 = requireScheduleAsyncIterable();
  var isInteropObservable_1 = requireIsInteropObservable();
  var isPromise_1 = requireIsPromise();
  var isArrayLike_1 = requireIsArrayLike();
  var isIterable_1 = requireIsIterable();
  var isAsyncIterable_1 = requireIsAsyncIterable();
  var throwUnobservableError_1 = requireThrowUnobservableError();
  var isReadableStreamLike_1 = requireIsReadableStreamLike();
  var scheduleReadableStreamLike_1 = requireScheduleReadableStreamLike();
  function scheduled$1(input, scheduler2) {
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return scheduleObservable_1.scheduleObservable(input, scheduler2);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return scheduleArray_1.scheduleArray(input, scheduler2);
      }
      if (isPromise_1.isPromise(input)) {
        return schedulePromise_1.schedulePromise(input, scheduler2);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler2);
      }
      if (isIterable_1.isIterable(input)) {
        return scheduleIterable_1.scheduleIterable(input, scheduler2);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler2);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  scheduled.scheduled = scheduled$1;
  return scheduled;
}
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom)
    return from;
  hasRequiredFrom = 1;
  Object.defineProperty(from, "__esModule", { value: true });
  from.from = void 0;
  var scheduled_1 = requireScheduled();
  var innerFrom_1 = requireInnerFrom();
  function from$1(input, scheduler2) {
    return scheduler2 ? scheduled_1.scheduled(input, scheduler2) : innerFrom_1.innerFrom(input);
  }
  from.from = from$1;
  return from;
}
var hasRequiredOf;
function requireOf() {
  if (hasRequiredOf)
    return of;
  hasRequiredOf = 1;
  Object.defineProperty(of, "__esModule", { value: true });
  of.of = void 0;
  var args_1 = requireArgs();
  var from_1 = requireFrom();
  function of$1() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler2 = args_1.popScheduler(args2);
    return from_1.from(args2, scheduler2);
  }
  of.of = of$1;
  return of;
}
var throwError = {};
var hasRequiredThrowError;
function requireThrowError() {
  if (hasRequiredThrowError)
    return throwError;
  hasRequiredThrowError = 1;
  Object.defineProperty(throwError, "__esModule", { value: true });
  throwError.throwError = void 0;
  var Observable_1 = requireObservable();
  var isFunction_1 = requireIsFunction();
  function throwError$1(errorOrErrorFactory, scheduler2) {
    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init2 = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable_1.Observable(scheduler2 ? function(subscriber) {
      return scheduler2.schedule(init2, 0, subscriber);
    } : init2);
  }
  throwError.throwError = throwError$1;
  return throwError;
}
var hasRequiredNotification;
function requireNotification() {
  if (hasRequiredNotification)
    return Notification;
  hasRequiredNotification = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observeNotification = exports2.Notification = exports2.NotificationKind = void 0;
    var empty_1 = requireEmpty();
    var of_1 = requireOf();
    var throwError_1 = requireThrowError();
    var isFunction_1 = requireIsFunction();
    (function(NotificationKind) {
      NotificationKind["NEXT"] = "N";
      NotificationKind["ERROR"] = "E";
      NotificationKind["COMPLETE"] = "C";
    })(exports2.NotificationKind || (exports2.NotificationKind = {}));
    var Notification2 = function() {
      function Notification3(kind, value, error2) {
        this.kind = kind;
        this.value = value;
        this.error = error2;
        this.hasValue = kind === "N";
      }
      Notification3.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification3.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error2) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification3.prototype.accept = function(nextOrObserver, error2, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
      };
      Notification3.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error2;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification3.createNext = function(value) {
        return new Notification3("N", value);
      };
      Notification3.createError = function(err) {
        return new Notification3("E", void 0, err);
      };
      Notification3.createComplete = function() {
        return Notification3.completeNotification;
      };
      Notification3.completeNotification = new Notification3("C");
      return Notification3;
    }();
    exports2.Notification = Notification2;
    function observeNotification(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error2 = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error2) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports2.observeNotification = observeNotification;
  })(Notification);
  return Notification;
}
var isObservable = {};
var hasRequiredIsObservable;
function requireIsObservable() {
  if (hasRequiredIsObservable)
    return isObservable;
  hasRequiredIsObservable = 1;
  Object.defineProperty(isObservable, "__esModule", { value: true });
  isObservable.isObservable = void 0;
  var Observable_1 = requireObservable();
  var isFunction_1 = requireIsFunction();
  function isObservable$1(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
  }
  isObservable.isObservable = isObservable$1;
  return isObservable;
}
var lastValueFrom = {};
var EmptyError = {};
var hasRequiredEmptyError;
function requireEmptyError() {
  if (hasRequiredEmptyError)
    return EmptyError;
  hasRequiredEmptyError = 1;
  Object.defineProperty(EmptyError, "__esModule", { value: true });
  EmptyError.EmptyError = void 0;
  var createErrorClass_1 = requireCreateErrorClass();
  EmptyError.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
  return EmptyError;
}
var hasRequiredLastValueFrom;
function requireLastValueFrom() {
  if (hasRequiredLastValueFrom)
    return lastValueFrom;
  hasRequiredLastValueFrom = 1;
  Object.defineProperty(lastValueFrom, "__esModule", { value: true });
  lastValueFrom.lastValueFrom = void 0;
  var EmptyError_1 = requireEmptyError();
  function lastValueFrom$1(source2, config2) {
    var hasConfig = typeof config2 === "object";
    return new Promise(function(resolve2, reject) {
      var _hasValue = false;
      var _value;
      source2.subscribe({
        next: function(value) {
          _value = value;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve2(_value);
          } else if (hasConfig) {
            resolve2(config2.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError());
          }
        }
      });
    });
  }
  lastValueFrom.lastValueFrom = lastValueFrom$1;
  return lastValueFrom;
}
var firstValueFrom = {};
var hasRequiredFirstValueFrom;
function requireFirstValueFrom() {
  if (hasRequiredFirstValueFrom)
    return firstValueFrom;
  hasRequiredFirstValueFrom = 1;
  Object.defineProperty(firstValueFrom, "__esModule", { value: true });
  firstValueFrom.firstValueFrom = void 0;
  var EmptyError_1 = requireEmptyError();
  var Subscriber_1 = requireSubscriber();
  function firstValueFrom$1(source2, config2) {
    var hasConfig = typeof config2 === "object";
    return new Promise(function(resolve2, reject) {
      var subscriber = new Subscriber_1.SafeSubscriber({
        next: function(value) {
          resolve2(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve2(config2.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError());
          }
        }
      });
      source2.subscribe(subscriber);
    });
  }
  firstValueFrom.firstValueFrom = firstValueFrom$1;
  return firstValueFrom;
}
var ArgumentOutOfRangeError = {};
var hasRequiredArgumentOutOfRangeError;
function requireArgumentOutOfRangeError() {
  if (hasRequiredArgumentOutOfRangeError)
    return ArgumentOutOfRangeError;
  hasRequiredArgumentOutOfRangeError = 1;
  Object.defineProperty(ArgumentOutOfRangeError, "__esModule", { value: true });
  ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
  var createErrorClass_1 = requireCreateErrorClass();
  ArgumentOutOfRangeError.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
      _super(this);
      this.name = "ArgumentOutOfRangeError";
      this.message = "argument out of range";
    };
  });
  return ArgumentOutOfRangeError;
}
var NotFoundError = {};
var hasRequiredNotFoundError;
function requireNotFoundError() {
  if (hasRequiredNotFoundError)
    return NotFoundError;
  hasRequiredNotFoundError = 1;
  Object.defineProperty(NotFoundError, "__esModule", { value: true });
  NotFoundError.NotFoundError = void 0;
  var createErrorClass_1 = requireCreateErrorClass();
  NotFoundError.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
    return function NotFoundErrorImpl(message) {
      _super(this);
      this.name = "NotFoundError";
      this.message = message;
    };
  });
  return NotFoundError;
}
var SequenceError = {};
var hasRequiredSequenceError;
function requireSequenceError() {
  if (hasRequiredSequenceError)
    return SequenceError;
  hasRequiredSequenceError = 1;
  Object.defineProperty(SequenceError, "__esModule", { value: true });
  SequenceError.SequenceError = void 0;
  var createErrorClass_1 = requireCreateErrorClass();
  SequenceError.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
    return function SequenceErrorImpl(message) {
      _super(this);
      this.name = "SequenceError";
      this.message = message;
    };
  });
  return SequenceError;
}
var timeout = {};
var isDate$1 = {};
var hasRequiredIsDate;
function requireIsDate() {
  if (hasRequiredIsDate)
    return isDate$1;
  hasRequiredIsDate = 1;
  Object.defineProperty(isDate$1, "__esModule", { value: true });
  isDate$1.isValidDate = void 0;
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }
  isDate$1.isValidDate = isValidDate;
  return isDate$1;
}
var hasRequiredTimeout;
function requireTimeout() {
  if (hasRequiredTimeout)
    return timeout;
  hasRequiredTimeout = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = exports2.TimeoutError = void 0;
    var async_12 = requireAsync();
    var isDate_1 = requireIsDate();
    var lift_1 = requireLift();
    var innerFrom_1 = requireInnerFrom();
    var createErrorClass_1 = requireCreateErrorClass();
    var OperatorSubscriber_1 = requireOperatorSubscriber();
    var executeSchedule_1 = requireExecuteSchedule();
    exports2.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
    function timeout2(config2, schedulerArg) {
      var _a = isDate_1.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler2 = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_12.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first2 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source2, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay2) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler2, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay2);
        };
        originalSourceSubscription = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler2.now() : each);
      });
    }
    exports2.timeout = timeout2;
    function timeoutErrorFactory(info) {
      throw new exports2.TimeoutError(info);
    }
  })(timeout);
  return timeout;
}
var bindCallback = {};
var bindCallbackInternals = {};
var mapOneOrManyArgs = {};
var map$1 = {};
var hasRequiredMap$1;
function requireMap$1() {
  if (hasRequiredMap$1)
    return map$1;
  hasRequiredMap$1 = 1;
  Object.defineProperty(map$1, "__esModule", { value: true });
  map$1.map = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function map2(project, thisArg) {
    return lift_1.operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  map$1.map = map2;
  return map$1;
}
var hasRequiredMapOneOrManyArgs;
function requireMapOneOrManyArgs() {
  if (hasRequiredMapOneOrManyArgs)
    return mapOneOrManyArgs;
  hasRequiredMapOneOrManyArgs = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(mapOneOrManyArgs, "__esModule", { value: true });
  mapOneOrManyArgs.mapOneOrManyArgs = void 0;
  var map_1 = requireMap$1();
  var isArray2 = Array.isArray;
  function callOrApply(fn, args2) {
    return isArray2(args2) ? fn.apply(void 0, __spreadArray2([], __read2(args2))) : fn(args2);
  }
  function mapOneOrManyArgs$1(fn) {
    return map_1.map(function(args2) {
      return callOrApply(fn, args2);
    });
  }
  mapOneOrManyArgs.mapOneOrManyArgs = mapOneOrManyArgs$1;
  return mapOneOrManyArgs;
}
var hasRequiredBindCallbackInternals;
function requireBindCallbackInternals() {
  if (hasRequiredBindCallbackInternals)
    return bindCallbackInternals;
  hasRequiredBindCallbackInternals = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(bindCallbackInternals, "__esModule", { value: true });
  bindCallbackInternals.bindCallbackInternals = void 0;
  var isScheduler_1 = requireIsScheduler();
  var Observable_1 = requireObservable();
  var subscribeOn_1 = requireSubscribeOn();
  var mapOneOrManyArgs_1 = requireMapOneOrManyArgs();
  var observeOn_1 = requireObserveOn();
  var AsyncSubject_1 = requireAsyncSubject();
  function bindCallbackInternals$1(isNodeStyle, callbackFunc, resultSelector, scheduler2) {
    if (resultSelector) {
      if (isScheduler_1.isScheduler(resultSelector)) {
        scheduler2 = resultSelector;
      } else {
        return function() {
          var args2 = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args2[_i] = arguments[_i];
          }
          return bindCallbackInternals$1(isNodeStyle, callbackFunc, scheduler2).apply(this, args2).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        };
      }
    }
    if (scheduler2) {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return bindCallbackInternals$1(isNodeStyle, callbackFunc).apply(this, args2).pipe(subscribeOn_1.subscribeOn(scheduler2), observeOn_1.observeOn(scheduler2));
      };
    }
    return function() {
      var _this = this;
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var subject = new AsyncSubject_1.AsyncSubject();
      var uninitialized = true;
      return new Observable_1.Observable(function(subscriber) {
        var subs = subject.subscribe(subscriber);
        if (uninitialized) {
          uninitialized = false;
          var isAsync_1 = false;
          var isComplete_1 = false;
          callbackFunc.apply(_this, __spreadArray2(__spreadArray2([], __read2(args2)), [
            function() {
              var results = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err = results.shift();
                if (err != null) {
                  subject.error(err);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }
          ]));
          if (isComplete_1) {
            subject.complete();
          }
          isAsync_1 = true;
        }
        return subs;
      });
    };
  }
  bindCallbackInternals.bindCallbackInternals = bindCallbackInternals$1;
  return bindCallbackInternals;
}
var hasRequiredBindCallback;
function requireBindCallback() {
  if (hasRequiredBindCallback)
    return bindCallback;
  hasRequiredBindCallback = 1;
  Object.defineProperty(bindCallback, "__esModule", { value: true });
  bindCallback.bindCallback = void 0;
  var bindCallbackInternals_1 = requireBindCallbackInternals();
  function bindCallback$1(callbackFunc, resultSelector, scheduler2) {
    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler2);
  }
  bindCallback.bindCallback = bindCallback$1;
  return bindCallback;
}
var bindNodeCallback = {};
var hasRequiredBindNodeCallback;
function requireBindNodeCallback() {
  if (hasRequiredBindNodeCallback)
    return bindNodeCallback;
  hasRequiredBindNodeCallback = 1;
  Object.defineProperty(bindNodeCallback, "__esModule", { value: true });
  bindNodeCallback.bindNodeCallback = void 0;
  var bindCallbackInternals_1 = requireBindCallbackInternals();
  function bindNodeCallback$1(callbackFunc, resultSelector, scheduler2) {
    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler2);
  }
  bindNodeCallback.bindNodeCallback = bindNodeCallback$1;
  return bindNodeCallback;
}
var combineLatest$1 = {};
var argsArgArrayOrObject = {};
var hasRequiredArgsArgArrayOrObject;
function requireArgsArgArrayOrObject() {
  if (hasRequiredArgsArgArrayOrObject)
    return argsArgArrayOrObject;
  hasRequiredArgsArgArrayOrObject = 1;
  Object.defineProperty(argsArgArrayOrObject, "__esModule", { value: true });
  argsArgArrayOrObject.argsArgArrayOrObject = void 0;
  var isArray2 = Array.isArray;
  var getPrototypeOf2 = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
  function argsArgArrayOrObject$1(args2) {
    if (args2.length === 1) {
      var first_1 = args2[0];
      if (isArray2(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args: args2, keys: null };
  }
  argsArgArrayOrObject.argsArgArrayOrObject = argsArgArrayOrObject$1;
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf2(obj) === objectProto;
  }
  return argsArgArrayOrObject;
}
var createObject = {};
var hasRequiredCreateObject;
function requireCreateObject() {
  if (hasRequiredCreateObject)
    return createObject;
  hasRequiredCreateObject = 1;
  Object.defineProperty(createObject, "__esModule", { value: true });
  createObject.createObject = void 0;
  function createObject$1(keys, values) {
    return keys.reduce(function(result, key, i) {
      return result[key] = values[i], result;
    }, {});
  }
  createObject.createObject = createObject$1;
  return createObject;
}
var hasRequiredCombineLatest$1;
function requireCombineLatest$1() {
  if (hasRequiredCombineLatest$1)
    return combineLatest$1;
  hasRequiredCombineLatest$1 = 1;
  Object.defineProperty(combineLatest$1, "__esModule", { value: true });
  combineLatest$1.combineLatestInit = combineLatest$1.combineLatest = void 0;
  var Observable_1 = requireObservable();
  var argsArgArrayOrObject_1 = requireArgsArgArrayOrObject();
  var from_1 = requireFrom();
  var identity_1 = requireIdentity();
  var mapOneOrManyArgs_1 = requireMapOneOrManyArgs();
  var args_1 = requireArgs();
  var createObject_1 = requireCreateObject();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var executeSchedule_1 = requireExecuteSchedule();
  function combineLatest2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler2 = args_1.popScheduler(args2);
    var resultSelector = args_1.popResultSelector(args2);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args2), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from_1.from([], scheduler2);
    }
    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler2, keys ? function(values) {
      return createObject_1.createObject(keys, values);
    } : identity_1.identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  combineLatest$1.combineLatest = combineLatest2;
  function combineLatestInit(observables, scheduler2, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity_1.identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler2, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler2, function() {
            var source2 = from_1.from(observables[i2], scheduler2);
            var hasFirstValue = false;
            source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              values[i2] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0; i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  }
  combineLatest$1.combineLatestInit = combineLatestInit;
  function maybeSchedule(scheduler2, execute, subscription) {
    if (scheduler2) {
      executeSchedule_1.executeSchedule(subscription, scheduler2, execute);
    } else {
      execute();
    }
  }
  return combineLatest$1;
}
var concat$2 = {};
var concatAll = {};
var mergeAll = {};
var mergeMap = {};
var mergeInternals = {};
var hasRequiredMergeInternals;
function requireMergeInternals() {
  if (hasRequiredMergeInternals)
    return mergeInternals;
  hasRequiredMergeInternals = 1;
  Object.defineProperty(mergeInternals, "__esModule", { value: true });
  mergeInternals.mergeInternals = void 0;
  var innerFrom_1 = requireInnerFrom();
  var executeSchedule_1 = requireExecuteSchedule();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function mergeInternals$1(source2, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
    var buffer2 = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer2.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer2.push(value);
    };
    var doInnerSub = function(value) {
      expand2 && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand2) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer2.shift();
              if (innerSubScheduler) {
                executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer2.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }
  mergeInternals.mergeInternals = mergeInternals$1;
  return mergeInternals;
}
var hasRequiredMergeMap;
function requireMergeMap() {
  if (hasRequiredMergeMap)
    return mergeMap;
  hasRequiredMergeMap = 1;
  Object.defineProperty(mergeMap, "__esModule", { value: true });
  mergeMap.mergeMap = void 0;
  var map_1 = requireMap$1();
  var innerFrom_1 = requireInnerFrom();
  var lift_1 = requireLift();
  var mergeInternals_1 = requireMergeInternals();
  var isFunction_1 = requireIsFunction();
  function mergeMap$1(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap$1(function(a, i) {
        return map_1.map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom_1.innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return lift_1.operate(function(source2, subscriber) {
      return mergeInternals_1.mergeInternals(source2, subscriber, project, concurrent);
    });
  }
  mergeMap.mergeMap = mergeMap$1;
  return mergeMap;
}
var hasRequiredMergeAll;
function requireMergeAll() {
  if (hasRequiredMergeAll)
    return mergeAll;
  hasRequiredMergeAll = 1;
  Object.defineProperty(mergeAll, "__esModule", { value: true });
  mergeAll.mergeAll = void 0;
  var mergeMap_1 = requireMergeMap();
  var identity_1 = requireIdentity();
  function mergeAll$1(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
  }
  mergeAll.mergeAll = mergeAll$1;
  return mergeAll;
}
var hasRequiredConcatAll;
function requireConcatAll() {
  if (hasRequiredConcatAll)
    return concatAll;
  hasRequiredConcatAll = 1;
  Object.defineProperty(concatAll, "__esModule", { value: true });
  concatAll.concatAll = void 0;
  var mergeAll_1 = requireMergeAll();
  function concatAll$1() {
    return mergeAll_1.mergeAll(1);
  }
  concatAll.concatAll = concatAll$1;
  return concatAll;
}
var hasRequiredConcat$2;
function requireConcat$2() {
  if (hasRequiredConcat$2)
    return concat$2;
  hasRequiredConcat$2 = 1;
  Object.defineProperty(concat$2, "__esModule", { value: true });
  concat$2.concat = void 0;
  var concatAll_1 = requireConcatAll();
  var args_1 = requireArgs();
  var from_1 = requireFrom();
  function concat2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(from_1.from(args2, args_1.popScheduler(args2)));
  }
  concat$2.concat = concat2;
  return concat$2;
}
var connectable = {};
var defer$2 = {};
var hasRequiredDefer;
function requireDefer() {
  if (hasRequiredDefer)
    return defer$2;
  hasRequiredDefer = 1;
  Object.defineProperty(defer$2, "__esModule", { value: true });
  defer$2.defer = void 0;
  var Observable_1 = requireObservable();
  var innerFrom_1 = requireInnerFrom();
  function defer2(observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
    });
  }
  defer$2.defer = defer2;
  return defer$2;
}
var hasRequiredConnectable;
function requireConnectable() {
  if (hasRequiredConnectable)
    return connectable;
  hasRequiredConnectable = 1;
  Object.defineProperty(connectable, "__esModule", { value: true });
  connectable.connectable = void 0;
  var Subject_1 = requireSubject();
  var Observable_1 = requireObservable();
  var defer_12 = requireDefer();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject();
    },
    resetOnDisconnect: true
  };
  function connectable$1(source2, config2) {
    if (config2 === void 0) {
      config2 = DEFAULT_CONFIG;
    }
    var connection = null;
    var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
    var subject = connector();
    var result = new Observable_1.Observable(function(subscriber) {
      return subject.subscribe(subscriber);
    });
    result.connect = function() {
      if (!connection || connection.closed) {
        connection = defer_12.defer(function() {
          return source2;
        }).subscribe(subject);
        if (resetOnDisconnect) {
          connection.add(function() {
            return subject = connector();
          });
        }
      }
      return connection;
    };
    return result;
  }
  connectable.connectable = connectable$1;
  return connectable;
}
var forkJoin = {};
var hasRequiredForkJoin;
function requireForkJoin() {
  if (hasRequiredForkJoin)
    return forkJoin;
  hasRequiredForkJoin = 1;
  Object.defineProperty(forkJoin, "__esModule", { value: true });
  forkJoin.forkJoin = void 0;
  var Observable_1 = requireObservable();
  var argsArgArrayOrObject_1 = requireArgsArgArrayOrObject();
  var innerFrom_1 = requireInnerFrom();
  var args_1 = requireArgs();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var mapOneOrManyArgs_1 = requireMapOneOrManyArgs();
  var createObject_1 = requireCreateObject();
  function forkJoin$1() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args2);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args2), sources = _a.args, keys = _a.keys;
    var result = new Observable_1.Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = function(sourceIndex2) {
        var hasValue = false;
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values[sourceIndex2] = value;
        }, function() {
          return remainingCompletions--;
        }, void 0, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
            }
            subscriber.complete();
          }
        }));
      };
      for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  forkJoin.forkJoin = forkJoin$1;
  return forkJoin;
}
var fromEvent = {};
var hasRequiredFromEvent;
function requireFromEvent() {
  if (hasRequiredFromEvent)
    return fromEvent;
  hasRequiredFromEvent = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(fromEvent, "__esModule", { value: true });
  fromEvent.fromEvent = void 0;
  var innerFrom_1 = requireInnerFrom();
  var Observable_1 = requireObservable();
  var mergeMap_1 = requireMergeMap();
  var isArrayLike_1 = requireIsArrayLike();
  var isFunction_1 = requireIsFunction();
  var mapOneOrManyArgs_1 = requireMapOneOrManyArgs();
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent$1(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent$1(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    var _a = __read2(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike_1.isArrayLike(target)) {
        return mergeMap_1.mergeMap(function(subTarget) {
          return fromEvent$1(subTarget, eventName, options);
        })(innerFrom_1.innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return subscriber.next(1 < args2.length ? args2 : args2[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  fromEvent.fromEvent = fromEvent$1;
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
  }
  return fromEvent;
}
var fromEventPattern = {};
var hasRequiredFromEventPattern;
function requireFromEventPattern() {
  if (hasRequiredFromEventPattern)
    return fromEventPattern;
  hasRequiredFromEventPattern = 1;
  Object.defineProperty(fromEventPattern, "__esModule", { value: true });
  fromEventPattern.fromEventPattern = void 0;
  var Observable_1 = requireObservable();
  var isFunction_1 = requireIsFunction();
  var mapOneOrManyArgs_1 = requireMapOneOrManyArgs();
  function fromEventPattern$1(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern$1(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction_1.isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : void 0;
    });
  }
  fromEventPattern.fromEventPattern = fromEventPattern$1;
  return fromEventPattern;
}
var generate = {};
var hasRequiredGenerate;
function requireGenerate() {
  if (hasRequiredGenerate)
    return generate;
  hasRequiredGenerate = 1;
  var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(generate, "__esModule", { value: true });
  generate.generate = void 0;
  var identity_1 = requireIdentity();
  var isScheduler_1 = requireIsScheduler();
  var defer_12 = requireDefer();
  var scheduleIterable_1 = requireScheduleIterable();
  function generate$1(initialStateOrOptions, condition, iterate2, resultSelectorOrScheduler, scheduler2) {
    var _a, _b;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) {
      _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate2 = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler2 = _a.scheduler;
    } else {
      initialState = initialStateOrOptions;
      if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
        resultSelector = identity_1.identity;
        scheduler2 = resultSelectorOrScheduler;
      } else {
        resultSelector = resultSelectorOrScheduler;
      }
    }
    function gen() {
      var state2;
      return __generator2(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            state2 = initialState;
            _a2.label = 1;
          case 1:
            if (!(!condition || condition(state2)))
              return [3, 4];
            return [4, resultSelector(state2)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            state2 = iterate2(state2);
            return [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return defer_12.defer(scheduler2 ? function() {
      return scheduleIterable_1.scheduleIterable(gen(), scheduler2);
    } : gen);
  }
  generate.generate = generate$1;
  return generate;
}
var iif = {};
var hasRequiredIif;
function requireIif() {
  if (hasRequiredIif)
    return iif;
  hasRequiredIif = 1;
  Object.defineProperty(iif, "__esModule", { value: true });
  iif.iif = void 0;
  var defer_12 = requireDefer();
  function iif$1(condition, trueResult, falseResult) {
    return defer_12.defer(function() {
      return condition() ? trueResult : falseResult;
    });
  }
  iif.iif = iif$1;
  return iif;
}
var interval = {};
var timer = {};
var hasRequiredTimer;
function requireTimer() {
  if (hasRequiredTimer)
    return timer;
  hasRequiredTimer = 1;
  Object.defineProperty(timer, "__esModule", { value: true });
  timer.timer = void 0;
  var Observable_1 = requireObservable();
  var async_12 = requireAsync();
  var isScheduler_1 = requireIsScheduler();
  var isDate_1 = requireIsDate();
  function timer$1(dueTime, intervalOrScheduler, scheduler2) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler2 === void 0) {
      scheduler2 = async_12.async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler_1.isScheduler(intervalOrScheduler)) {
        scheduler2 = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable_1.Observable(function(subscriber) {
      var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler2.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler2.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(void 0, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }
  timer.timer = timer$1;
  return timer;
}
var hasRequiredInterval;
function requireInterval() {
  if (hasRequiredInterval)
    return interval;
  hasRequiredInterval = 1;
  Object.defineProperty(interval, "__esModule", { value: true });
  interval.interval = void 0;
  var async_12 = requireAsync();
  var timer_1 = requireTimer();
  function interval$1(period, scheduler2) {
    if (period === void 0) {
      period = 0;
    }
    if (scheduler2 === void 0) {
      scheduler2 = async_12.asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer_1.timer(period, period, scheduler2);
  }
  interval.interval = interval$1;
  return interval;
}
var merge$2 = {};
var hasRequiredMerge$1;
function requireMerge$1() {
  if (hasRequiredMerge$1)
    return merge$2;
  hasRequiredMerge$1 = 1;
  Object.defineProperty(merge$2, "__esModule", { value: true });
  merge$2.merge = void 0;
  var mergeAll_1 = requireMergeAll();
  var innerFrom_1 = requireInnerFrom();
  var empty_1 = requireEmpty();
  var args_1 = requireArgs();
  var from_1 = requireFrom();
  function merge2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler2 = args_1.popScheduler(args2);
    var concurrent = args_1.popNumber(args2, Infinity);
    var sources = args2;
    return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler2));
  }
  merge$2.merge = merge2;
  return merge$2;
}
var never = {};
var hasRequiredNever;
function requireNever() {
  if (hasRequiredNever)
    return never;
  hasRequiredNever = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.never = exports2.NEVER = void 0;
    var Observable_1 = requireObservable();
    var noop_1 = requireNoop();
    exports2.NEVER = new Observable_1.Observable(noop_1.noop);
    function never2() {
      return exports2.NEVER;
    }
    exports2.never = never2;
  })(never);
  return never;
}
var onErrorResumeNext = {};
var argsOrArgArray = {};
var hasRequiredArgsOrArgArray;
function requireArgsOrArgArray() {
  if (hasRequiredArgsOrArgArray)
    return argsOrArgArray;
  hasRequiredArgsOrArgArray = 1;
  Object.defineProperty(argsOrArgArray, "__esModule", { value: true });
  argsOrArgArray.argsOrArgArray = void 0;
  var isArray2 = Array.isArray;
  function argsOrArgArray$1(args2) {
    return args2.length === 1 && isArray2(args2[0]) ? args2[0] : args2;
  }
  argsOrArgArray.argsOrArgArray = argsOrArgArray$1;
  return argsOrArgArray;
}
var hasRequiredOnErrorResumeNext;
function requireOnErrorResumeNext() {
  if (hasRequiredOnErrorResumeNext)
    return onErrorResumeNext;
  hasRequiredOnErrorResumeNext = 1;
  Object.defineProperty(onErrorResumeNext, "__esModule", { value: true });
  onErrorResumeNext.onErrorResumeNext = void 0;
  var Observable_1 = requireObservable();
  var argsOrArgArray_1 = requireArgsOrArgArray();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var noop_1 = requireNoop();
  var innerFrom_1 = requireInnerFrom();
  function onErrorResumeNext$1() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return new Observable_1.Observable(function(subscriber) {
      var sourceIndex = 0;
      var subscribeNext = function() {
        if (sourceIndex < nextSources.length) {
          var nextSource = void 0;
          try {
            nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
          } catch (err) {
            subscribeNext();
            return;
          }
          var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
          nextSource.subscribe(innerSubscriber);
          innerSubscriber.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      };
      subscribeNext();
    });
  }
  onErrorResumeNext.onErrorResumeNext = onErrorResumeNext$1;
  return onErrorResumeNext;
}
var pairs = {};
var hasRequiredPairs;
function requirePairs() {
  if (hasRequiredPairs)
    return pairs;
  hasRequiredPairs = 1;
  Object.defineProperty(pairs, "__esModule", { value: true });
  pairs.pairs = void 0;
  var from_1 = requireFrom();
  function pairs$1(obj, scheduler2) {
    return from_1.from(Object.entries(obj), scheduler2);
  }
  pairs.pairs = pairs$1;
  return pairs;
}
var partition$1 = {};
var not$2 = {};
var hasRequiredNot;
function requireNot() {
  if (hasRequiredNot)
    return not$2;
  hasRequiredNot = 1;
  Object.defineProperty(not$2, "__esModule", { value: true });
  not$2.not = void 0;
  function not2(pred, thisArg) {
    return function(value, index) {
      return !pred.call(thisArg, value, index);
    };
  }
  not$2.not = not2;
  return not$2;
}
var filter$1 = {};
var hasRequiredFilter$1;
function requireFilter$1() {
  if (hasRequiredFilter$1)
    return filter$1;
  hasRequiredFilter$1 = 1;
  Object.defineProperty(filter$1, "__esModule", { value: true });
  filter$1.filter = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function filter3(predicate, thisArg) {
    return lift_1.operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  filter$1.filter = filter3;
  return filter$1;
}
var hasRequiredPartition$1;
function requirePartition$1() {
  if (hasRequiredPartition$1)
    return partition$1;
  hasRequiredPartition$1 = 1;
  Object.defineProperty(partition$1, "__esModule", { value: true });
  partition$1.partition = void 0;
  var not_12 = requireNot();
  var filter_1 = requireFilter$1();
  var innerFrom_1 = requireInnerFrom();
  function partition2(source2, predicate, thisArg) {
    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source2)), filter_1.filter(not_12.not(predicate, thisArg))(innerFrom_1.innerFrom(source2))];
  }
  partition$1.partition = partition2;
  return partition$1;
}
var race$1 = {};
var hasRequiredRace$1;
function requireRace$1() {
  if (hasRequiredRace$1)
    return race$1;
  hasRequiredRace$1 = 1;
  Object.defineProperty(race$1, "__esModule", { value: true });
  race$1.raceInit = race$1.race = void 0;
  var Observable_1 = requireObservable();
  var innerFrom_1 = requireInnerFrom();
  var argsOrArgArray_1 = requireArgsOrArgArray();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function race2() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray_1.argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
  }
  race$1.race = race2;
  function raceInit(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i2) {
        subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (subscriptions) {
            for (var s = 0; s < subscriptions.length; s++) {
              s !== i2 && subscriptions[s].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
        _loop_1(i);
      }
    };
  }
  race$1.raceInit = raceInit;
  return race$1;
}
var range$2 = {};
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1)
    return range$2;
  hasRequiredRange$1 = 1;
  Object.defineProperty(range$2, "__esModule", { value: true });
  range$2.range = void 0;
  var Observable_1 = requireObservable();
  var empty_1 = requireEmpty();
  function range2(start, count2, scheduler2) {
    if (count2 == null) {
      count2 = start;
      start = 0;
    }
    if (count2 <= 0) {
      return empty_1.EMPTY;
    }
    var end = count2 + start;
    return new Observable_1.Observable(scheduler2 ? function(subscriber) {
      var n = start;
      return scheduler2.schedule(function() {
        if (n < end) {
          subscriber.next(n++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n = start;
      while (n < end && !subscriber.closed) {
        subscriber.next(n++);
      }
      subscriber.complete();
    });
  }
  range$2.range = range2;
  return range$2;
}
var using = {};
var hasRequiredUsing;
function requireUsing() {
  if (hasRequiredUsing)
    return using;
  hasRequiredUsing = 1;
  Object.defineProperty(using, "__esModule", { value: true });
  using.using = void 0;
  var Observable_1 = requireObservable();
  var innerFrom_1 = requireInnerFrom();
  var empty_1 = requireEmpty();
  function using$1(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      var resource = resourceFactory();
      var result = observableFactory(resource);
      var source2 = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
      source2.subscribe(subscriber);
      return function() {
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  }
  using.using = using$1;
  return using;
}
var zip$2 = {};
var hasRequiredZip$2;
function requireZip$2() {
  if (hasRequiredZip$2)
    return zip$2;
  hasRequiredZip$2 = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(zip$2, "__esModule", { value: true });
  zip$2.zip = void 0;
  var Observable_1 = requireObservable();
  var innerFrom_1 = requireInnerFrom();
  var argsOrArgArray_1 = requireArgsOrArgArray();
  var empty_1 = requireEmpty();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var args_1 = requireArgs();
  function zip2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args2);
    var sources = argsOrArgArray_1.argsOrArgArray(args2);
    return sources.length ? new Observable_1.Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffers[sourceIndex2].push(value);
          if (buffers.every(function(buffer2) {
            return buffer2.length;
          })) {
            var result = buffers.map(function(buffer2) {
              return buffer2.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray2([], __read2(result))) : result);
            if (buffers.some(function(buffer2, i) {
              return !buffer2.length && completed[i];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : empty_1.EMPTY;
  }
  zip$2.zip = zip2;
  return zip$2;
}
var types$2 = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types$2;
  hasRequiredTypes = 1;
  Object.defineProperty(types$2, "__esModule", { value: true });
  return types$2;
}
var audit = {};
var hasRequiredAudit;
function requireAudit() {
  if (hasRequiredAudit)
    return audit;
  hasRequiredAudit = 1;
  Object.defineProperty(audit, "__esModule", { value: true });
  audit.audit = void 0;
  var lift_1 = requireLift();
  var innerFrom_1 = requireInnerFrom();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function audit$1(durationSelector) {
    return lift_1.operate(function(source2, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
        if (!durationSubscriber) {
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  }
  audit.audit = audit$1;
  return audit;
}
var auditTime = {};
var hasRequiredAuditTime;
function requireAuditTime() {
  if (hasRequiredAuditTime)
    return auditTime;
  hasRequiredAuditTime = 1;
  Object.defineProperty(auditTime, "__esModule", { value: true });
  auditTime.auditTime = void 0;
  var async_12 = requireAsync();
  var audit_1 = requireAudit();
  var timer_1 = requireTimer();
  function auditTime$1(duration, scheduler2) {
    if (scheduler2 === void 0) {
      scheduler2 = async_12.asyncScheduler;
    }
    return audit_1.audit(function() {
      return timer_1.timer(duration, scheduler2);
    });
  }
  auditTime.auditTime = auditTime$1;
  return auditTime;
}
var buffer = {};
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer)
    return buffer;
  hasRequiredBuffer = 1;
  Object.defineProperty(buffer, "__esModule", { value: true });
  buffer.buffer = void 0;
  var lift_1 = requireLift();
  var noop_1 = requireNoop();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  function buffer$1(closingNotifier) {
    return lift_1.operate(function(source2, subscriber) {
      var currentBuffer = [];
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return currentBuffer.push(value);
      }, function() {
        subscriber.next(currentBuffer);
        subscriber.complete();
      }));
      innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        var b = currentBuffer;
        currentBuffer = [];
        subscriber.next(b);
      }, noop_1.noop));
      return function() {
        currentBuffer = null;
      };
    });
  }
  buffer.buffer = buffer$1;
  return buffer;
}
var bufferCount = {};
var hasRequiredBufferCount;
function requireBufferCount() {
  if (hasRequiredBufferCount)
    return bufferCount;
  hasRequiredBufferCount = 1;
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(bufferCount, "__esModule", { value: true });
  bufferCount.bufferCount = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var arrRemove_1 = requireArrRemove();
  function bufferCount$1(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
    return lift_1.operate(function(source2, subscriber) {
      var buffers = [];
      var count2 = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a, e_2, _b;
        var toEmit = null;
        if (count2++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer2 = buffers_1_1.value;
            buffer2.push(value);
            if (bufferSize <= buffer2.length) {
              toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
              toEmit.push(buffer2);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values2(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer2 = toEmit_1_1.value;
              arrRemove_1.arrRemove(buffers, buffer2);
              subscriber.next(buffer2);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                _b.call(toEmit_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a;
        try {
          for (var buffers_2 = __values2(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer2 = buffers_2_1.value;
            subscriber.next(buffer2);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
              _a.call(buffers_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        subscriber.complete();
      }, void 0, function() {
        buffers = null;
      }));
    });
  }
  bufferCount.bufferCount = bufferCount$1;
  return bufferCount;
}
var bufferTime = {};
var hasRequiredBufferTime;
function requireBufferTime() {
  if (hasRequiredBufferTime)
    return bufferTime;
  hasRequiredBufferTime = 1;
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(bufferTime, "__esModule", { value: true });
  bufferTime.bufferTime = void 0;
  var Subscription_1 = requireSubscription();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var arrRemove_1 = requireArrRemove();
  var async_12 = requireAsync();
  var args_1 = requireArgs();
  var executeSchedule_1 = requireExecuteSchedule();
  function bufferTime$1(bufferTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler2 = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_12.asyncScheduler;
    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source2, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var buffer2 = record.buffer, subs = record.subs;
        subs.unsubscribe();
        arrRemove_1.arrRemove(bufferRecords, record);
        subscriber.next(buffer2);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription_1.Subscription();
          subscriber.add(subs);
          var buffer2 = [];
          var record_1 = {
            buffer: buffer2,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule_1.executeSchedule(subs, scheduler2, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler2, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values2(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer2 = record.buffer;
            buffer2.push(value);
            maxBufferSize <= buffer2.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
              _a2.call(recordsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, void 0, function() {
        return bufferRecords = null;
      });
      source2.subscribe(bufferTimeSubscriber);
    });
  }
  bufferTime.bufferTime = bufferTime$1;
  return bufferTime;
}
var bufferToggle = {};
var hasRequiredBufferToggle;
function requireBufferToggle() {
  if (hasRequiredBufferToggle)
    return bufferToggle;
  hasRequiredBufferToggle = 1;
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(bufferToggle, "__esModule", { value: true });
  bufferToggle.bufferToggle = void 0;
  var Subscription_1 = requireSubscription();
  var lift_1 = requireLift();
  var innerFrom_1 = requireInnerFrom();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var noop_1 = requireNoop();
  var arrRemove_1 = requireArrRemove();
  function bufferToggle$1(openings, closingSelector) {
    return lift_1.operate(function(source2, subscriber) {
      var buffers = [];
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var buffer2 = [];
        buffers.push(buffer2);
        var closingSubscription = new Subscription_1.Subscription();
        var emitBuffer = function() {
          arrRemove_1.arrRemove(buffers, buffer2);
          subscriber.next(buffer2);
          closingSubscription.unsubscribe();
        };
        closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
      }, noop_1.noop));
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        try {
          for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer2 = buffers_1_1.value;
            buffer2.push(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (buffers.length > 0) {
          subscriber.next(buffers.shift());
        }
        subscriber.complete();
      }));
    });
  }
  bufferToggle.bufferToggle = bufferToggle$1;
  return bufferToggle;
}
var bufferWhen = {};
var hasRequiredBufferWhen;
function requireBufferWhen() {
  if (hasRequiredBufferWhen)
    return bufferWhen;
  hasRequiredBufferWhen = 1;
  Object.defineProperty(bufferWhen, "__esModule", { value: true });
  bufferWhen.bufferWhen = void 0;
  var lift_1 = requireLift();
  var noop_1 = requireNoop();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  function bufferWhen$1(closingSelector) {
    return lift_1.operate(function(source2, subscriber) {
      var buffer2 = null;
      var closingSubscriber = null;
      var openBuffer = function() {
        closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
        var b = buffer2;
        buffer2 = [];
        b && subscriber.next(b);
        innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
      };
      openBuffer();
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
      }, function() {
        buffer2 && subscriber.next(buffer2);
        subscriber.complete();
      }, void 0, function() {
        return buffer2 = closingSubscriber = null;
      }));
    });
  }
  bufferWhen.bufferWhen = bufferWhen$1;
  return bufferWhen;
}
var catchError = {};
var hasRequiredCatchError;
function requireCatchError() {
  if (hasRequiredCatchError)
    return catchError;
  hasRequiredCatchError = 1;
  Object.defineProperty(catchError, "__esModule", { value: true });
  catchError.catchError = void 0;
  var innerFrom_1 = requireInnerFrom();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var lift_1 = requireLift();
  function catchError$1(selector) {
    return lift_1.operate(function(source2, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        handledResult = innerFrom_1.innerFrom(selector(err, catchError$1(selector)(source2)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }
  catchError.catchError = catchError$1;
  return catchError;
}
var combineAll = {};
var combineLatestAll = {};
var joinAllInternals = {};
var toArray$1 = {};
var reduce = {};
var scanInternals = {};
var hasRequiredScanInternals;
function requireScanInternals() {
  if (hasRequiredScanInternals)
    return scanInternals;
  hasRequiredScanInternals = 1;
  Object.defineProperty(scanInternals, "__esModule", { value: true });
  scanInternals.scanInternals = void 0;
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function scanInternals$1(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source2, subscriber) {
      var hasState = hasSeed;
      var state2 = seed;
      var index = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        state2 = hasState ? accumulator(state2, value, i) : (hasState = true, value);
        emitOnNext && subscriber.next(state2);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state2);
        subscriber.complete();
      }));
    };
  }
  scanInternals.scanInternals = scanInternals$1;
  return scanInternals;
}
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce)
    return reduce;
  hasRequiredReduce = 1;
  Object.defineProperty(reduce, "__esModule", { value: true });
  reduce.reduce = void 0;
  var scanInternals_1 = requireScanInternals();
  var lift_1 = requireLift();
  function reduce$1(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  }
  reduce.reduce = reduce$1;
  return reduce;
}
var hasRequiredToArray;
function requireToArray() {
  if (hasRequiredToArray)
    return toArray$1;
  hasRequiredToArray = 1;
  Object.defineProperty(toArray$1, "__esModule", { value: true });
  toArray$1.toArray = void 0;
  var reduce_1 = requireReduce();
  var lift_1 = requireLift();
  var arrReducer = function(arr, value) {
    return arr.push(value), arr;
  };
  function toArray2() {
    return lift_1.operate(function(source2, subscriber) {
      reduce_1.reduce(arrReducer, [])(source2).subscribe(subscriber);
    });
  }
  toArray$1.toArray = toArray2;
  return toArray$1;
}
var hasRequiredJoinAllInternals;
function requireJoinAllInternals() {
  if (hasRequiredJoinAllInternals)
    return joinAllInternals;
  hasRequiredJoinAllInternals = 1;
  Object.defineProperty(joinAllInternals, "__esModule", { value: true });
  joinAllInternals.joinAllInternals = void 0;
  var identity_1 = requireIdentity();
  var mapOneOrManyArgs_1 = requireMapOneOrManyArgs();
  var pipe_1 = requirePipe();
  var mergeMap_1 = requireMergeMap();
  var toArray_1 = requireToArray();
  function joinAllInternals$1(joinFn, project) {
    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
      return joinFn(sources);
    }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
  }
  joinAllInternals.joinAllInternals = joinAllInternals$1;
  return joinAllInternals;
}
var hasRequiredCombineLatestAll;
function requireCombineLatestAll() {
  if (hasRequiredCombineLatestAll)
    return combineLatestAll;
  hasRequiredCombineLatestAll = 1;
  Object.defineProperty(combineLatestAll, "__esModule", { value: true });
  combineLatestAll.combineLatestAll = void 0;
  var combineLatest_1 = requireCombineLatest$1();
  var joinAllInternals_1 = requireJoinAllInternals();
  function combineLatestAll$1(project) {
    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
  }
  combineLatestAll.combineLatestAll = combineLatestAll$1;
  return combineLatestAll;
}
var hasRequiredCombineAll;
function requireCombineAll() {
  if (hasRequiredCombineAll)
    return combineAll;
  hasRequiredCombineAll = 1;
  Object.defineProperty(combineAll, "__esModule", { value: true });
  combineAll.combineAll = void 0;
  var combineLatestAll_1 = requireCombineLatestAll();
  combineAll.combineAll = combineLatestAll_1.combineLatestAll;
  return combineAll;
}
var combineLatestWith = {};
var combineLatest = {};
var hasRequiredCombineLatest;
function requireCombineLatest() {
  if (hasRequiredCombineLatest)
    return combineLatest;
  hasRequiredCombineLatest = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(combineLatest, "__esModule", { value: true });
  combineLatest.combineLatest = void 0;
  var combineLatest_1 = requireCombineLatest$1();
  var lift_1 = requireLift();
  var argsOrArgArray_1 = requireArgsOrArgArray();
  var mapOneOrManyArgs_1 = requireMapOneOrManyArgs();
  var pipe_1 = requirePipe();
  var args_1 = requireArgs();
  function combineLatest$12() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args2);
    return resultSelector ? pipe_1.pipe(combineLatest$12.apply(void 0, __spreadArray2([], __read2(args2))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source2, subscriber) {
      combineLatest_1.combineLatestInit(__spreadArray2([source2], __read2(argsOrArgArray_1.argsOrArgArray(args2))))(subscriber);
    });
  }
  combineLatest.combineLatest = combineLatest$12;
  return combineLatest;
}
var hasRequiredCombineLatestWith;
function requireCombineLatestWith() {
  if (hasRequiredCombineLatestWith)
    return combineLatestWith;
  hasRequiredCombineLatestWith = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(combineLatestWith, "__esModule", { value: true });
  combineLatestWith.combineLatestWith = void 0;
  var combineLatest_1 = requireCombineLatest();
  function combineLatestWith$1() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(void 0, __spreadArray2([], __read2(otherSources)));
  }
  combineLatestWith.combineLatestWith = combineLatestWith$1;
  return combineLatestWith;
}
var concatMap = {};
var hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap)
    return concatMap;
  hasRequiredConcatMap = 1;
  Object.defineProperty(concatMap, "__esModule", { value: true });
  concatMap.concatMap = void 0;
  var mergeMap_1 = requireMergeMap();
  var isFunction_1 = requireIsFunction();
  function concatMap$1(project, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
  }
  concatMap.concatMap = concatMap$1;
  return concatMap;
}
var concatMapTo = {};
var hasRequiredConcatMapTo;
function requireConcatMapTo() {
  if (hasRequiredConcatMapTo)
    return concatMapTo;
  hasRequiredConcatMapTo = 1;
  Object.defineProperty(concatMapTo, "__esModule", { value: true });
  concatMapTo.concatMapTo = void 0;
  var concatMap_1 = requireConcatMap();
  var isFunction_1 = requireIsFunction();
  function concatMapTo$1(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
      return innerObservable;
    }, resultSelector) : concatMap_1.concatMap(function() {
      return innerObservable;
    });
  }
  concatMapTo.concatMapTo = concatMapTo$1;
  return concatMapTo;
}
var concatWith = {};
var concat$1 = {};
var hasRequiredConcat$1;
function requireConcat$1() {
  if (hasRequiredConcat$1)
    return concat$1;
  hasRequiredConcat$1 = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(concat$1, "__esModule", { value: true });
  concat$1.concat = void 0;
  var lift_1 = requireLift();
  var concatAll_1 = requireConcatAll();
  var args_1 = requireArgs();
  var from_1 = requireFrom();
  function concat2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler2 = args_1.popScheduler(args2);
    return lift_1.operate(function(source2, subscriber) {
      concatAll_1.concatAll()(from_1.from(__spreadArray2([source2], __read2(args2)), scheduler2)).subscribe(subscriber);
    });
  }
  concat$1.concat = concat2;
  return concat$1;
}
var hasRequiredConcatWith;
function requireConcatWith() {
  if (hasRequiredConcatWith)
    return concatWith;
  hasRequiredConcatWith = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(concatWith, "__esModule", { value: true });
  concatWith.concatWith = void 0;
  var concat_1 = requireConcat$1();
  function concatWith$1() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return concat_1.concat.apply(void 0, __spreadArray2([], __read2(otherSources)));
  }
  concatWith.concatWith = concatWith$1;
  return concatWith;
}
var connect = {};
var fromSubscribable = {};
var hasRequiredFromSubscribable;
function requireFromSubscribable() {
  if (hasRequiredFromSubscribable)
    return fromSubscribable;
  hasRequiredFromSubscribable = 1;
  Object.defineProperty(fromSubscribable, "__esModule", { value: true });
  fromSubscribable.fromSubscribable = void 0;
  var Observable_1 = requireObservable();
  function fromSubscribable$1(subscribable) {
    return new Observable_1.Observable(function(subscriber) {
      return subscribable.subscribe(subscriber);
    });
  }
  fromSubscribable.fromSubscribable = fromSubscribable$1;
  return fromSubscribable;
}
var hasRequiredConnect;
function requireConnect() {
  if (hasRequiredConnect)
    return connect;
  hasRequiredConnect = 1;
  Object.defineProperty(connect, "__esModule", { value: true });
  connect.connect = void 0;
  var Subject_1 = requireSubject();
  var innerFrom_1 = requireInnerFrom();
  var lift_1 = requireLift();
  var fromSubscribable_1 = requireFromSubscribable();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject();
    }
  };
  function connect$1(selector, config2) {
    if (config2 === void 0) {
      config2 = DEFAULT_CONFIG;
    }
    var connector = config2.connector;
    return lift_1.operate(function(source2, subscriber) {
      var subject = connector();
      innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
      subscriber.add(source2.subscribe(subject));
    });
  }
  connect.connect = connect$1;
  return connect;
}
var count = {};
var hasRequiredCount;
function requireCount() {
  if (hasRequiredCount)
    return count;
  hasRequiredCount = 1;
  Object.defineProperty(count, "__esModule", { value: true });
  count.count = void 0;
  var reduce_1 = requireReduce();
  function count$1(predicate) {
    return reduce_1.reduce(function(total, value, i) {
      return !predicate || predicate(value, i) ? total + 1 : total;
    }, 0);
  }
  count.count = count$1;
  return count;
}
var debounce = {};
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce)
    return debounce;
  hasRequiredDebounce = 1;
  Object.defineProperty(debounce, "__esModule", { value: true });
  debounce.debounce = void 0;
  var lift_1 = requireLift();
  var noop_1 = requireNoop();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  function debounce$1(durationSelector) {
    return lift_1.operate(function(source2, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value;
        durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
        innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, void 0, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  }
  debounce.debounce = debounce$1;
  return debounce;
}
var debounceTime = {};
var hasRequiredDebounceTime;
function requireDebounceTime() {
  if (hasRequiredDebounceTime)
    return debounceTime;
  hasRequiredDebounceTime = 1;
  Object.defineProperty(debounceTime, "__esModule", { value: true });
  debounceTime.debounceTime = void 0;
  var async_12 = requireAsync();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function debounceTime$1(dueTime, scheduler2) {
    if (scheduler2 === void 0) {
      scheduler2 = async_12.asyncScheduler;
    }
    return lift_1.operate(function(source2, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler2.now();
        if (now < targetTime) {
          activeTask = this.schedule(void 0, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        lastValue = value;
        lastTime = scheduler2.now();
        if (!activeTask) {
          activeTask = scheduler2.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, void 0, function() {
        lastValue = activeTask = null;
      }));
    });
  }
  debounceTime.debounceTime = debounceTime$1;
  return debounceTime;
}
var defaultIfEmpty = {};
var hasRequiredDefaultIfEmpty;
function requireDefaultIfEmpty() {
  if (hasRequiredDefaultIfEmpty)
    return defaultIfEmpty;
  hasRequiredDefaultIfEmpty = 1;
  Object.defineProperty(defaultIfEmpty, "__esModule", { value: true });
  defaultIfEmpty.defaultIfEmpty = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function defaultIfEmpty$1(defaultValue) {
    return lift_1.operate(function(source2, subscriber) {
      var hasValue = false;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }
  defaultIfEmpty.defaultIfEmpty = defaultIfEmpty$1;
  return defaultIfEmpty;
}
var delay = {};
var delayWhen = {};
var take = {};
var hasRequiredTake;
function requireTake() {
  if (hasRequiredTake)
    return take;
  hasRequiredTake = 1;
  Object.defineProperty(take, "__esModule", { value: true });
  take.take = void 0;
  var empty_1 = requireEmpty();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function take$1(count2) {
    return count2 <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source2, subscriber) {
      var seen = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count2) {
          subscriber.next(value);
          if (count2 <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }
  take.take = take$1;
  return take;
}
var ignoreElements = {};
var hasRequiredIgnoreElements;
function requireIgnoreElements() {
  if (hasRequiredIgnoreElements)
    return ignoreElements;
  hasRequiredIgnoreElements = 1;
  Object.defineProperty(ignoreElements, "__esModule", { value: true });
  ignoreElements.ignoreElements = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var noop_1 = requireNoop();
  function ignoreElements$1() {
    return lift_1.operate(function(source2, subscriber) {
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
    });
  }
  ignoreElements.ignoreElements = ignoreElements$1;
  return ignoreElements;
}
var mapTo = {};
var hasRequiredMapTo;
function requireMapTo() {
  if (hasRequiredMapTo)
    return mapTo;
  hasRequiredMapTo = 1;
  Object.defineProperty(mapTo, "__esModule", { value: true });
  mapTo.mapTo = void 0;
  var map_1 = requireMap$1();
  function mapTo$1(value) {
    return map_1.map(function() {
      return value;
    });
  }
  mapTo.mapTo = mapTo$1;
  return mapTo;
}
var hasRequiredDelayWhen;
function requireDelayWhen() {
  if (hasRequiredDelayWhen)
    return delayWhen;
  hasRequiredDelayWhen = 1;
  Object.defineProperty(delayWhen, "__esModule", { value: true });
  delayWhen.delayWhen = void 0;
  var concat_1 = requireConcat$2();
  var take_1 = requireTake();
  var ignoreElements_1 = requireIgnoreElements();
  var mapTo_1 = requireMapTo();
  var mergeMap_1 = requireMergeMap();
  var innerFrom_1 = requireInnerFrom();
  function delayWhen$1(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source2) {
        return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source2.pipe(delayWhen$1(delayDurationSelector)));
      };
    }
    return mergeMap_1.mergeMap(function(value, index) {
      return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
    });
  }
  delayWhen.delayWhen = delayWhen$1;
  return delayWhen;
}
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1;
  Object.defineProperty(delay, "__esModule", { value: true });
  delay.delay = void 0;
  var async_12 = requireAsync();
  var delayWhen_1 = requireDelayWhen();
  var timer_1 = requireTimer();
  function delay$1(due, scheduler2) {
    if (scheduler2 === void 0) {
      scheduler2 = async_12.asyncScheduler;
    }
    var duration = timer_1.timer(due, scheduler2);
    return delayWhen_1.delayWhen(function() {
      return duration;
    });
  }
  delay.delay = delay$1;
  return delay;
}
var dematerialize = {};
var hasRequiredDematerialize;
function requireDematerialize() {
  if (hasRequiredDematerialize)
    return dematerialize;
  hasRequiredDematerialize = 1;
  Object.defineProperty(dematerialize, "__esModule", { value: true });
  dematerialize.dematerialize = void 0;
  var Notification_1 = requireNotification();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function dematerialize$1() {
    return lift_1.operate(function(source2, subscriber) {
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
        return Notification_1.observeNotification(notification, subscriber);
      }));
    });
  }
  dematerialize.dematerialize = dematerialize$1;
  return dematerialize;
}
var distinct = {};
var hasRequiredDistinct;
function requireDistinct() {
  if (hasRequiredDistinct)
    return distinct;
  hasRequiredDistinct = 1;
  Object.defineProperty(distinct, "__esModule", { value: true });
  distinct.distinct = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var noop_1 = requireNoop();
  var innerFrom_1 = requireInnerFrom();
  function distinct$1(keySelector, flushes) {
    return lift_1.operate(function(source2, subscriber) {
      var distinctKeys = /* @__PURE__ */ new Set();
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var key = keySelector ? keySelector(value) : value;
        if (!distinctKeys.has(key)) {
          distinctKeys.add(key);
          subscriber.next(value);
        }
      }));
      flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return distinctKeys.clear();
      }, noop_1.noop));
    });
  }
  distinct.distinct = distinct$1;
  return distinct;
}
var distinctUntilChanged = {};
var hasRequiredDistinctUntilChanged;
function requireDistinctUntilChanged() {
  if (hasRequiredDistinctUntilChanged)
    return distinctUntilChanged;
  hasRequiredDistinctUntilChanged = 1;
  Object.defineProperty(distinctUntilChanged, "__esModule", { value: true });
  distinctUntilChanged.distinctUntilChanged = void 0;
  var identity_1 = requireIdentity();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function distinctUntilChanged$1(comparator2, keySelector) {
    if (keySelector === void 0) {
      keySelector = identity_1.identity;
    }
    comparator2 = comparator2 !== null && comparator2 !== void 0 ? comparator2 : defaultCompare;
    return lift_1.operate(function(source2, subscriber) {
      var previousKey;
      var first2 = true;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first2 || !comparator2(previousKey, currentKey)) {
          first2 = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }
  distinctUntilChanged.distinctUntilChanged = distinctUntilChanged$1;
  function defaultCompare(a, b) {
    return a === b;
  }
  return distinctUntilChanged;
}
var distinctUntilKeyChanged = {};
var hasRequiredDistinctUntilKeyChanged;
function requireDistinctUntilKeyChanged() {
  if (hasRequiredDistinctUntilKeyChanged)
    return distinctUntilKeyChanged;
  hasRequiredDistinctUntilKeyChanged = 1;
  Object.defineProperty(distinctUntilKeyChanged, "__esModule", { value: true });
  distinctUntilKeyChanged.distinctUntilKeyChanged = void 0;
  var distinctUntilChanged_1 = requireDistinctUntilChanged();
  function distinctUntilKeyChanged$1(key, compare2) {
    return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
      return compare2 ? compare2(x[key], y[key]) : x[key] === y[key];
    });
  }
  distinctUntilKeyChanged.distinctUntilKeyChanged = distinctUntilKeyChanged$1;
  return distinctUntilKeyChanged;
}
var elementAt = {};
var throwIfEmpty = {};
var hasRequiredThrowIfEmpty;
function requireThrowIfEmpty() {
  if (hasRequiredThrowIfEmpty)
    return throwIfEmpty;
  hasRequiredThrowIfEmpty = 1;
  Object.defineProperty(throwIfEmpty, "__esModule", { value: true });
  throwIfEmpty.throwIfEmpty = void 0;
  var EmptyError_1 = requireEmptyError();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function throwIfEmpty$1(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return lift_1.operate(function(source2, subscriber) {
      var hasValue = false;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  throwIfEmpty.throwIfEmpty = throwIfEmpty$1;
  function defaultErrorFactory() {
    return new EmptyError_1.EmptyError();
  }
  return throwIfEmpty;
}
var hasRequiredElementAt;
function requireElementAt() {
  if (hasRequiredElementAt)
    return elementAt;
  hasRequiredElementAt = 1;
  Object.defineProperty(elementAt, "__esModule", { value: true });
  elementAt.elementAt = void 0;
  var ArgumentOutOfRangeError_1 = requireArgumentOutOfRangeError();
  var filter_1 = requireFilter$1();
  var throwIfEmpty_1 = requireThrowIfEmpty();
  var defaultIfEmpty_1 = requireDefaultIfEmpty();
  var take_1 = requireTake();
  function elementAt$1(index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source2) {
      return source2.pipe(filter_1.filter(function(v, i) {
        return i === index;
      }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }));
    };
  }
  elementAt.elementAt = elementAt$1;
  return elementAt;
}
var endWith = {};
var hasRequiredEndWith;
function requireEndWith() {
  if (hasRequiredEndWith)
    return endWith;
  hasRequiredEndWith = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(endWith, "__esModule", { value: true });
  endWith.endWith = void 0;
  var concat_1 = requireConcat$2();
  var of_1 = requireOf();
  function endWith$1() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return function(source2) {
      return concat_1.concat(source2, of_1.of.apply(void 0, __spreadArray2([], __read2(values))));
    };
  }
  endWith.endWith = endWith$1;
  return endWith;
}
var every = {};
var hasRequiredEvery;
function requireEvery() {
  if (hasRequiredEvery)
    return every;
  hasRequiredEvery = 1;
  Object.defineProperty(every, "__esModule", { value: true });
  every.every = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function every$1(predicate, thisArg) {
    return lift_1.operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (!predicate.call(thisArg, value, index++, source2)) {
          subscriber.next(false);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  every.every = every$1;
  return every;
}
var exhaust = {};
var exhaustAll = {};
var exhaustMap = {};
var hasRequiredExhaustMap;
function requireExhaustMap() {
  if (hasRequiredExhaustMap)
    return exhaustMap;
  hasRequiredExhaustMap = 1;
  Object.defineProperty(exhaustMap, "__esModule", { value: true });
  exhaustMap.exhaustMap = void 0;
  var map_1 = requireMap$1();
  var innerFrom_1 = requireInnerFrom();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function exhaustMap$1(project, resultSelector) {
    if (resultSelector) {
      return function(source2) {
        return source2.pipe(exhaustMap$1(function(a, i) {
          return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          }));
        }));
      };
    }
    return lift_1.operate(function(source2, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  }
  exhaustMap.exhaustMap = exhaustMap$1;
  return exhaustMap;
}
var hasRequiredExhaustAll;
function requireExhaustAll() {
  if (hasRequiredExhaustAll)
    return exhaustAll;
  hasRequiredExhaustAll = 1;
  Object.defineProperty(exhaustAll, "__esModule", { value: true });
  exhaustAll.exhaustAll = void 0;
  var exhaustMap_1 = requireExhaustMap();
  var identity_1 = requireIdentity();
  function exhaustAll$1() {
    return exhaustMap_1.exhaustMap(identity_1.identity);
  }
  exhaustAll.exhaustAll = exhaustAll$1;
  return exhaustAll;
}
var hasRequiredExhaust;
function requireExhaust() {
  if (hasRequiredExhaust)
    return exhaust;
  hasRequiredExhaust = 1;
  Object.defineProperty(exhaust, "__esModule", { value: true });
  exhaust.exhaust = void 0;
  var exhaustAll_1 = requireExhaustAll();
  exhaust.exhaust = exhaustAll_1.exhaustAll;
  return exhaust;
}
var expand = {};
var hasRequiredExpand;
function requireExpand() {
  if (hasRequiredExpand)
    return expand;
  hasRequiredExpand = 1;
  Object.defineProperty(expand, "__esModule", { value: true });
  expand.expand = void 0;
  var lift_1 = requireLift();
  var mergeInternals_1 = requireMergeInternals();
  function expand$1(project, concurrent, scheduler2) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return lift_1.operate(function(source2, subscriber) {
      return mergeInternals_1.mergeInternals(source2, subscriber, project, concurrent, void 0, true, scheduler2);
    });
  }
  expand.expand = expand$1;
  return expand;
}
var finalize = {};
var hasRequiredFinalize;
function requireFinalize() {
  if (hasRequiredFinalize)
    return finalize;
  hasRequiredFinalize = 1;
  Object.defineProperty(finalize, "__esModule", { value: true });
  finalize.finalize = void 0;
  var lift_1 = requireLift();
  function finalize$1(callback) {
    return lift_1.operate(function(source2, subscriber) {
      try {
        source2.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  }
  finalize.finalize = finalize$1;
  return finalize;
}
var find = {};
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind)
    return find;
  hasRequiredFind = 1;
  Object.defineProperty(find, "__esModule", { value: true });
  find.createFind = find.find = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function find$1(predicate, thisArg) {
    return lift_1.operate(createFind(predicate, thisArg, "value"));
  }
  find.find = find$1;
  function createFind(predicate, thisArg, emit) {
    var findIndex2 = emit === "index";
    return function(source2, subscriber) {
      var index = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        if (predicate.call(thisArg, value, i, source2)) {
          subscriber.next(findIndex2 ? i : value);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(findIndex2 ? -1 : void 0);
        subscriber.complete();
      }));
    };
  }
  find.createFind = createFind;
  return find;
}
var findIndex = {};
var hasRequiredFindIndex;
function requireFindIndex() {
  if (hasRequiredFindIndex)
    return findIndex;
  hasRequiredFindIndex = 1;
  Object.defineProperty(findIndex, "__esModule", { value: true });
  findIndex.findIndex = void 0;
  var lift_1 = requireLift();
  var find_1 = requireFind();
  function findIndex$1(predicate, thisArg) {
    return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
  }
  findIndex.findIndex = findIndex$1;
  return findIndex;
}
var first = {};
var hasRequiredFirst;
function requireFirst() {
  if (hasRequiredFirst)
    return first;
  hasRequiredFirst = 1;
  Object.defineProperty(first, "__esModule", { value: true });
  first.first = void 0;
  var EmptyError_1 = requireEmptyError();
  var filter_1 = requireFilter$1();
  var take_1 = requireTake();
  var defaultIfEmpty_1 = requireDefaultIfEmpty();
  var throwIfEmpty_1 = requireThrowIfEmpty();
  var identity_1 = requireIdentity();
  function first$1(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source2) {
      return source2.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source2);
      }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError();
      }));
    };
  }
  first.first = first$1;
  return first;
}
var groupBy = {};
var hasRequiredGroupBy;
function requireGroupBy() {
  if (hasRequiredGroupBy)
    return groupBy;
  hasRequiredGroupBy = 1;
  Object.defineProperty(groupBy, "__esModule", { value: true });
  groupBy.groupBy = void 0;
  var Observable_1 = requireObservable();
  var innerFrom_1 = requireInnerFrom();
  var Subject_1 = requireSubject();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function groupBy$1(keySelector, elementOrOptions, duration, connector) {
    return lift_1.operate(function(source2, subscriber) {
      var element;
      if (!elementOrOptions || typeof elementOrOptions === "function") {
        element = elementOrOptions;
      } else {
        duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
      }
      var groups = /* @__PURE__ */ new Map();
      var notify = function(cb) {
        groups.forEach(cb);
        cb(subscriber);
      };
      var handleError = function(err) {
        return notify(function(consumer) {
          return consumer.error(err);
        });
      };
      var activeGroups = 0;
      var teardownAttempted = false;
      var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
        try {
          var key_1 = keySelector(value);
          var group_1 = groups.get(key_1);
          if (!group_1) {
            groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
            var grouped = createGroupedObservable(key_1, group_1);
            subscriber.next(grouped);
            if (duration) {
              var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                group_1.complete();
                durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
              }, void 0, void 0, function() {
                return groups.delete(key_1);
              });
              groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
            }
          }
          group_1.next(element ? element(value) : value);
        } catch (err) {
          handleError(err);
        }
      }, function() {
        return notify(function(consumer) {
          return consumer.complete();
        });
      }, handleError, function() {
        return groups.clear();
      }, function() {
        teardownAttempted = true;
        return activeGroups === 0;
      });
      source2.subscribe(groupBySourceSubscriber);
      function createGroupedObservable(key, groupSubject) {
        var result = new Observable_1.Observable(function(groupSubscriber) {
          activeGroups++;
          var innerSub = groupSubject.subscribe(groupSubscriber);
          return function() {
            innerSub.unsubscribe();
            --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
          };
        });
        result.key = key;
        return result;
      }
    });
  }
  groupBy.groupBy = groupBy$1;
  return groupBy;
}
var isEmpty = {};
var hasRequiredIsEmpty;
function requireIsEmpty() {
  if (hasRequiredIsEmpty)
    return isEmpty;
  hasRequiredIsEmpty = 1;
  Object.defineProperty(isEmpty, "__esModule", { value: true });
  isEmpty.isEmpty = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function isEmpty$1() {
    return lift_1.operate(function(source2, subscriber) {
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        subscriber.next(false);
        subscriber.complete();
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  isEmpty.isEmpty = isEmpty$1;
  return isEmpty;
}
var last = {};
var takeLast = {};
var hasRequiredTakeLast;
function requireTakeLast() {
  if (hasRequiredTakeLast)
    return takeLast;
  hasRequiredTakeLast = 1;
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(takeLast, "__esModule", { value: true });
  takeLast.takeLast = void 0;
  var empty_1 = requireEmpty();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function takeLast$1(count2) {
    return count2 <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source2, subscriber) {
      var buffer2 = [];
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        buffer2.push(value);
        count2 < buffer2.length && buffer2.shift();
      }, function() {
        var e_1, _a;
        try {
          for (var buffer_1 = __values2(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            subscriber.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
              _a.call(buffer_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      }, void 0, function() {
        buffer2 = null;
      }));
    });
  }
  takeLast.takeLast = takeLast$1;
  return takeLast;
}
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast)
    return last;
  hasRequiredLast = 1;
  Object.defineProperty(last, "__esModule", { value: true });
  last.last = void 0;
  var EmptyError_1 = requireEmptyError();
  var filter_1 = requireFilter$1();
  var takeLast_1 = requireTakeLast();
  var throwIfEmpty_1 = requireThrowIfEmpty();
  var defaultIfEmpty_1 = requireDefaultIfEmpty();
  var identity_1 = requireIdentity();
  function last$1(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source2) {
      return source2.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source2);
      }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError();
      }));
    };
  }
  last.last = last$1;
  return last;
}
var materialize = {};
var hasRequiredMaterialize;
function requireMaterialize() {
  if (hasRequiredMaterialize)
    return materialize;
  hasRequiredMaterialize = 1;
  Object.defineProperty(materialize, "__esModule", { value: true });
  materialize.materialize = void 0;
  var Notification_1 = requireNotification();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function materialize$1() {
    return lift_1.operate(function(source2, subscriber) {
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(Notification_1.Notification.createNext(value));
      }, function() {
        subscriber.next(Notification_1.Notification.createComplete());
        subscriber.complete();
      }, function(err) {
        subscriber.next(Notification_1.Notification.createError(err));
        subscriber.complete();
      }));
    });
  }
  materialize.materialize = materialize$1;
  return materialize;
}
var max$3 = {};
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax)
    return max$3;
  hasRequiredMax = 1;
  Object.defineProperty(max$3, "__esModule", { value: true });
  max$3.max = void 0;
  var reduce_1 = requireReduce();
  var isFunction_1 = requireIsFunction();
  function max2(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
      return comparer(x, y) > 0 ? x : y;
    } : function(x, y) {
      return x > y ? x : y;
    });
  }
  max$3.max = max2;
  return max$3;
}
var flatMap = {};
var hasRequiredFlatMap;
function requireFlatMap() {
  if (hasRequiredFlatMap)
    return flatMap;
  hasRequiredFlatMap = 1;
  Object.defineProperty(flatMap, "__esModule", { value: true });
  flatMap.flatMap = void 0;
  var mergeMap_1 = requireMergeMap();
  flatMap.flatMap = mergeMap_1.mergeMap;
  return flatMap;
}
var mergeMapTo = {};
var hasRequiredMergeMapTo;
function requireMergeMapTo() {
  if (hasRequiredMergeMapTo)
    return mergeMapTo;
  hasRequiredMergeMapTo = 1;
  Object.defineProperty(mergeMapTo, "__esModule", { value: true });
  mergeMapTo.mergeMapTo = void 0;
  var mergeMap_1 = requireMergeMap();
  var isFunction_1 = requireIsFunction();
  function mergeMapTo$1(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, concurrent);
  }
  mergeMapTo.mergeMapTo = mergeMapTo$1;
  return mergeMapTo;
}
var mergeScan = {};
var hasRequiredMergeScan;
function requireMergeScan() {
  if (hasRequiredMergeScan)
    return mergeScan;
  hasRequiredMergeScan = 1;
  Object.defineProperty(mergeScan, "__esModule", { value: true });
  mergeScan.mergeScan = void 0;
  var lift_1 = requireLift();
  var mergeInternals_1 = requireMergeInternals();
  function mergeScan$1(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return lift_1.operate(function(source2, subscriber) {
      var state2 = seed;
      return mergeInternals_1.mergeInternals(source2, subscriber, function(value, index) {
        return accumulator(state2, value, index);
      }, concurrent, function(value) {
        state2 = value;
      }, false, void 0, function() {
        return state2 = null;
      });
    });
  }
  mergeScan.mergeScan = mergeScan$1;
  return mergeScan;
}
var mergeWith = {};
var merge$1 = {};
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge)
    return merge$1;
  hasRequiredMerge = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(merge$1, "__esModule", { value: true });
  merge$1.merge = void 0;
  var lift_1 = requireLift();
  var mergeAll_1 = requireMergeAll();
  var args_1 = requireArgs();
  var from_1 = requireFrom();
  function merge2() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var scheduler2 = args_1.popScheduler(args2);
    var concurrent = args_1.popNumber(args2, Infinity);
    return lift_1.operate(function(source2, subscriber) {
      mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray2([source2], __read2(args2)), scheduler2)).subscribe(subscriber);
    });
  }
  merge$1.merge = merge2;
  return merge$1;
}
var hasRequiredMergeWith;
function requireMergeWith() {
  if (hasRequiredMergeWith)
    return mergeWith;
  hasRequiredMergeWith = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(mergeWith, "__esModule", { value: true });
  mergeWith.mergeWith = void 0;
  var merge_1 = requireMerge();
  function mergeWith$1() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return merge_1.merge.apply(void 0, __spreadArray2([], __read2(otherSources)));
  }
  mergeWith.mergeWith = mergeWith$1;
  return mergeWith;
}
var min$2 = {};
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin)
    return min$2;
  hasRequiredMin = 1;
  Object.defineProperty(min$2, "__esModule", { value: true });
  min$2.min = void 0;
  var reduce_1 = requireReduce();
  var isFunction_1 = requireIsFunction();
  function min2(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
      return comparer(x, y) < 0 ? x : y;
    } : function(x, y) {
      return x < y ? x : y;
    });
  }
  min$2.min = min2;
  return min$2;
}
var multicast = {};
var hasRequiredMulticast;
function requireMulticast() {
  if (hasRequiredMulticast)
    return multicast;
  hasRequiredMulticast = 1;
  Object.defineProperty(multicast, "__esModule", { value: true });
  multicast.multicast = void 0;
  var ConnectableObservable_1 = requireConnectableObservable();
  var isFunction_1 = requireIsFunction();
  var connect_1 = requireConnect();
  function multicast$1(subjectOrSubjectFactory, selector) {
    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
      return subjectOrSubjectFactory;
    };
    if (isFunction_1.isFunction(selector)) {
      return connect_1.connect(selector, {
        connector: subjectFactory
      });
    }
    return function(source2) {
      return new ConnectableObservable_1.ConnectableObservable(source2, subjectFactory);
    };
  }
  multicast.multicast = multicast$1;
  return multicast;
}
var onErrorResumeNextWith = {};
var hasRequiredOnErrorResumeNextWith;
function requireOnErrorResumeNextWith() {
  if (hasRequiredOnErrorResumeNextWith)
    return onErrorResumeNextWith;
  hasRequiredOnErrorResumeNextWith = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(onErrorResumeNextWith, "__esModule", { value: true });
  onErrorResumeNextWith.onErrorResumeNext = onErrorResumeNextWith.onErrorResumeNextWith = void 0;
  var argsOrArgArray_1 = requireArgsOrArgArray();
  var onErrorResumeNext_1 = requireOnErrorResumeNext();
  function onErrorResumeNextWith$1() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return function(source2) {
      return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray2([source2], __read2(nextSources)));
    };
  }
  onErrorResumeNextWith.onErrorResumeNextWith = onErrorResumeNextWith$1;
  onErrorResumeNextWith.onErrorResumeNext = onErrorResumeNextWith$1;
  return onErrorResumeNextWith;
}
var pairwise = {};
var hasRequiredPairwise;
function requirePairwise() {
  if (hasRequiredPairwise)
    return pairwise;
  hasRequiredPairwise = 1;
  Object.defineProperty(pairwise, "__esModule", { value: true });
  pairwise.pairwise = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function pairwise$1() {
    return lift_1.operate(function(source2, subscriber) {
      var prev;
      var hasPrev = false;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var p = prev;
        prev = value;
        hasPrev && subscriber.next([p, value]);
        hasPrev = true;
      }));
    });
  }
  pairwise.pairwise = pairwise$1;
  return pairwise;
}
var pluck = {};
var hasRequiredPluck;
function requirePluck() {
  if (hasRequiredPluck)
    return pluck;
  hasRequiredPluck = 1;
  Object.defineProperty(pluck, "__esModule", { value: true });
  pluck.pluck = void 0;
  var map_1 = requireMap$1();
  function pluck$1() {
    var properties2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      properties2[_i] = arguments[_i];
    }
    var length = properties2.length;
    if (length === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return map_1.map(function(x) {
      var currentProp = x;
      for (var i = 0; i < length; i++) {
        var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties2[i]];
        if (typeof p !== "undefined") {
          currentProp = p;
        } else {
          return void 0;
        }
      }
      return currentProp;
    });
  }
  pluck.pluck = pluck$1;
  return pluck;
}
var publish = {};
var hasRequiredPublish;
function requirePublish() {
  if (hasRequiredPublish)
    return publish;
  hasRequiredPublish = 1;
  Object.defineProperty(publish, "__esModule", { value: true });
  publish.publish = void 0;
  var Subject_1 = requireSubject();
  var multicast_1 = requireMulticast();
  var connect_1 = requireConnect();
  function publish$1(selector) {
    return selector ? function(source2) {
      return connect_1.connect(selector)(source2);
    } : function(source2) {
      return multicast_1.multicast(new Subject_1.Subject())(source2);
    };
  }
  publish.publish = publish$1;
  return publish;
}
var publishBehavior = {};
var hasRequiredPublishBehavior;
function requirePublishBehavior() {
  if (hasRequiredPublishBehavior)
    return publishBehavior;
  hasRequiredPublishBehavior = 1;
  Object.defineProperty(publishBehavior, "__esModule", { value: true });
  publishBehavior.publishBehavior = void 0;
  var BehaviorSubject_1 = requireBehaviorSubject();
  var ConnectableObservable_1 = requireConnectableObservable();
  function publishBehavior$1(initialValue) {
    return function(source2) {
      var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
      return new ConnectableObservable_1.ConnectableObservable(source2, function() {
        return subject;
      });
    };
  }
  publishBehavior.publishBehavior = publishBehavior$1;
  return publishBehavior;
}
var publishLast = {};
var hasRequiredPublishLast;
function requirePublishLast() {
  if (hasRequiredPublishLast)
    return publishLast;
  hasRequiredPublishLast = 1;
  Object.defineProperty(publishLast, "__esModule", { value: true });
  publishLast.publishLast = void 0;
  var AsyncSubject_1 = requireAsyncSubject();
  var ConnectableObservable_1 = requireConnectableObservable();
  function publishLast$1() {
    return function(source2) {
      var subject = new AsyncSubject_1.AsyncSubject();
      return new ConnectableObservable_1.ConnectableObservable(source2, function() {
        return subject;
      });
    };
  }
  publishLast.publishLast = publishLast$1;
  return publishLast;
}
var publishReplay = {};
var hasRequiredPublishReplay;
function requirePublishReplay() {
  if (hasRequiredPublishReplay)
    return publishReplay;
  hasRequiredPublishReplay = 1;
  Object.defineProperty(publishReplay, "__esModule", { value: true });
  publishReplay.publishReplay = void 0;
  var ReplaySubject_1 = requireReplaySubject();
  var multicast_1 = requireMulticast();
  var isFunction_1 = requireIsFunction();
  function publishReplay$1(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
      timestampProvider = selectorOrScheduler;
    }
    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
    return function(source2) {
      return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source2);
    };
  }
  publishReplay.publishReplay = publishReplay$1;
  return publishReplay;
}
var raceWith = {};
var hasRequiredRaceWith;
function requireRaceWith() {
  if (hasRequiredRaceWith)
    return raceWith;
  hasRequiredRaceWith = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(raceWith, "__esModule", { value: true });
  raceWith.raceWith = void 0;
  var race_1 = requireRace$1();
  var lift_1 = requireLift();
  var identity_1 = requireIdentity();
  function raceWith$1() {
    var otherSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity_1.identity : lift_1.operate(function(source2, subscriber) {
      race_1.raceInit(__spreadArray2([source2], __read2(otherSources)))(subscriber);
    });
  }
  raceWith.raceWith = raceWith$1;
  return raceWith;
}
var repeat = {};
var hasRequiredRepeat;
function requireRepeat() {
  if (hasRequiredRepeat)
    return repeat;
  hasRequiredRepeat = 1;
  Object.defineProperty(repeat, "__esModule", { value: true });
  repeat.repeat = void 0;
  var empty_1 = requireEmpty();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  var timer_1 = requireTimer();
  function repeat$1(countOrConfig) {
    var _a;
    var count2 = Infinity;
    var delay2;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
      } else {
        count2 = countOrConfig;
      }
    }
    return count2 <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source2, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
        sourceSub = null;
        if (delay2 != null) {
          var notifier = typeof delay2 === "number" ? timer_1.timer(delay2) : innerFrom_1.innerFrom(delay2(soFar));
          var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
          if (++soFar < count2) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  }
  repeat.repeat = repeat$1;
  return repeat;
}
var repeatWhen = {};
var hasRequiredRepeatWhen;
function requireRepeatWhen() {
  if (hasRequiredRepeatWhen)
    return repeatWhen;
  hasRequiredRepeatWhen = 1;
  Object.defineProperty(repeatWhen, "__esModule", { value: true });
  repeatWhen.repeatWhen = void 0;
  var innerFrom_1 = requireInnerFrom();
  var Subject_1 = requireSubject();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function repeatWhen$1(notifier) {
    return lift_1.operate(function(source2, subscriber) {
      var innerSub;
      var syncResub = false;
      var completions$;
      var isNotifierComplete = false;
      var isMainComplete = false;
      var checkComplete = function() {
        return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
      };
      var getCompletionSubject = function() {
        if (!completions$) {
          completions$ = new Subject_1.Subject();
          innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (innerSub) {
              subscribeForRepeatWhen();
            } else {
              syncResub = true;
            }
          }, function() {
            isNotifierComplete = true;
            checkComplete();
          }));
        }
        return completions$;
      };
      var subscribeForRepeatWhen = function() {
        isMainComplete = false;
        innerSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
          isMainComplete = true;
          !checkComplete() && getCompletionSubject().next();
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRepeatWhen();
        }
      };
      subscribeForRepeatWhen();
    });
  }
  repeatWhen.repeatWhen = repeatWhen$1;
  return repeatWhen;
}
var retry = {};
var hasRequiredRetry;
function requireRetry() {
  if (hasRequiredRetry)
    return retry;
  hasRequiredRetry = 1;
  Object.defineProperty(retry, "__esModule", { value: true });
  retry.retry = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var identity_1 = requireIdentity();
  var timer_1 = requireTimer();
  var innerFrom_1 = requireInnerFrom();
  function retry$1(configOrCount) {
    if (configOrCount === void 0) {
      configOrCount = Infinity;
    }
    var config2;
    if (configOrCount && typeof configOrCount === "object") {
      config2 = configOrCount;
    } else {
      config2 = {
        count: configOrCount
      };
    }
    var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
    return count2 <= 0 ? identity_1.identity : lift_1.operate(function(source2, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, void 0, function(err) {
          if (soFar++ < count2) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay2 != null) {
              var notifier = typeof delay2 === "number" ? timer_1.timer(delay2) : innerFrom_1.innerFrom(delay2(err, soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  }
  retry.retry = retry$1;
  return retry;
}
var retryWhen = {};
var hasRequiredRetryWhen;
function requireRetryWhen() {
  if (hasRequiredRetryWhen)
    return retryWhen;
  hasRequiredRetryWhen = 1;
  Object.defineProperty(retryWhen, "__esModule", { value: true });
  retryWhen.retryWhen = void 0;
  var innerFrom_1 = requireInnerFrom();
  var Subject_1 = requireSubject();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function retryWhen$1(notifier) {
    return lift_1.operate(function(source2, subscriber) {
      var innerSub;
      var syncResub = false;
      var errors$;
      var subscribeForRetryWhen = function() {
        innerSub = source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          if (!errors$) {
            errors$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              return innerSub ? subscribeForRetryWhen() : syncResub = true;
            }));
          }
          if (errors$) {
            errors$.next(err);
          }
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRetryWhen();
        }
      };
      subscribeForRetryWhen();
    });
  }
  retryWhen.retryWhen = retryWhen$1;
  return retryWhen;
}
var sample = {};
var hasRequiredSample;
function requireSample() {
  if (hasRequiredSample)
    return sample;
  hasRequiredSample = 1;
  Object.defineProperty(sample, "__esModule", { value: true });
  sample.sample = void 0;
  var innerFrom_1 = requireInnerFrom();
  var lift_1 = requireLift();
  var noop_1 = requireNoop();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function sample$1(notifier) {
    return lift_1.operate(function(source2, subscriber) {
      var hasValue = false;
      var lastValue = null;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
      }));
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      }, noop_1.noop));
    });
  }
  sample.sample = sample$1;
  return sample;
}
var sampleTime = {};
var hasRequiredSampleTime;
function requireSampleTime() {
  if (hasRequiredSampleTime)
    return sampleTime;
  hasRequiredSampleTime = 1;
  Object.defineProperty(sampleTime, "__esModule", { value: true });
  sampleTime.sampleTime = void 0;
  var async_12 = requireAsync();
  var sample_1 = requireSample();
  var interval_1 = requireInterval();
  function sampleTime$1(period, scheduler2) {
    if (scheduler2 === void 0) {
      scheduler2 = async_12.asyncScheduler;
    }
    return sample_1.sample(interval_1.interval(period, scheduler2));
  }
  sampleTime.sampleTime = sampleTime$1;
  return sampleTime;
}
var scan = {};
var hasRequiredScan;
function requireScan() {
  if (hasRequiredScan)
    return scan;
  hasRequiredScan = 1;
  Object.defineProperty(scan, "__esModule", { value: true });
  scan.scan = void 0;
  var lift_1 = requireLift();
  var scanInternals_1 = requireScanInternals();
  function scan$1(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
  }
  scan.scan = scan$1;
  return scan;
}
var sequenceEqual = {};
var hasRequiredSequenceEqual;
function requireSequenceEqual() {
  if (hasRequiredSequenceEqual)
    return sequenceEqual;
  hasRequiredSequenceEqual = 1;
  Object.defineProperty(sequenceEqual, "__esModule", { value: true });
  sequenceEqual.sequenceEqual = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  function sequenceEqual$1(compareTo, comparator2) {
    if (comparator2 === void 0) {
      comparator2 = function(a, b) {
        return a === b;
      };
    }
    return lift_1.operate(function(source2, subscriber) {
      var aState = createState();
      var bState = createState();
      var emit = function(isEqual) {
        subscriber.next(isEqual);
        subscriber.complete();
      };
      var createSubscriber = function(selfState, otherState) {
        var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
          var buffer2 = otherState.buffer, complete = otherState.complete;
          if (buffer2.length === 0) {
            complete ? emit(false) : selfState.buffer.push(a);
          } else {
            !comparator2(a, buffer2.shift()) && emit(false);
          }
        }, function() {
          selfState.complete = true;
          var complete = otherState.complete, buffer2 = otherState.buffer;
          complete && emit(buffer2.length === 0);
          sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
        });
        return sequenceEqualSubscriber;
      };
      source2.subscribe(createSubscriber(aState, bState));
      innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
  }
  sequenceEqual.sequenceEqual = sequenceEqual$1;
  function createState() {
    return {
      buffer: [],
      complete: false
    };
  }
  return sequenceEqual;
}
var share = {};
var hasRequiredShare;
function requireShare() {
  if (hasRequiredShare)
    return share;
  hasRequiredShare = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(share, "__esModule", { value: true });
  share.share = void 0;
  var innerFrom_1 = requireInnerFrom();
  var Subject_1 = requireSubject();
  var Subscriber_1 = requireSubscriber();
  var lift_1 = requireLift();
  function share$1(options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.connector, connector = _a === void 0 ? function() {
      return new Subject_1.Subject();
    } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount2 = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
        resetConnection = void 0;
      };
      var reset = function() {
        cancelReset();
        connection = subject = void 0;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
      };
      return lift_1.operate(function(source2, subscriber) {
        refCount2++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
        subscriber.add(function() {
          refCount2--;
          if (refCount2 === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount2 > 0) {
          connection = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom_1.innerFrom(source2).subscribe(connection);
        }
      })(wrapperSource);
    };
  }
  share.share = share$1;
  function handleReset(reset, on) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new Subscriber_1.SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray2([], __read2(args2)))).subscribe(onSubscriber);
  }
  return share;
}
var shareReplay = {};
var hasRequiredShareReplay;
function requireShareReplay() {
  if (hasRequiredShareReplay)
    return shareReplay;
  hasRequiredShareReplay = 1;
  Object.defineProperty(shareReplay, "__esModule", { value: true });
  shareReplay.shareReplay = void 0;
  var ReplaySubject_1 = requireReplaySubject();
  var share_1 = requireShare();
  function shareReplay$1(configOrBufferSize, windowTime2, scheduler2) {
    var _a, _b, _c;
    var bufferSize;
    var refCount2 = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler2 = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
    }
    return share_1.share({
      connector: function() {
        return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, scheduler2);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount2
    });
  }
  shareReplay.shareReplay = shareReplay$1;
  return shareReplay;
}
var single = {};
var hasRequiredSingle;
function requireSingle() {
  if (hasRequiredSingle)
    return single;
  hasRequiredSingle = 1;
  Object.defineProperty(single, "__esModule", { value: true });
  single.single = void 0;
  var EmptyError_1 = requireEmptyError();
  var SequenceError_1 = requireSequenceError();
  var NotFoundError_1 = requireNotFoundError();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function single$1(predicate) {
    return lift_1.operate(function(source2, subscriber) {
      var hasValue = false;
      var singleValue;
      var seenValue = false;
      var index = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        seenValue = true;
        if (!predicate || predicate(value, index++, source2)) {
          hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
          hasValue = true;
          singleValue = value;
        }
      }, function() {
        if (hasValue) {
          subscriber.next(singleValue);
          subscriber.complete();
        } else {
          subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
        }
      }));
    });
  }
  single.single = single$1;
  return single;
}
var skip = {};
var hasRequiredSkip;
function requireSkip() {
  if (hasRequiredSkip)
    return skip;
  hasRequiredSkip = 1;
  Object.defineProperty(skip, "__esModule", { value: true });
  skip.skip = void 0;
  var filter_1 = requireFilter$1();
  function skip$1(count2) {
    return filter_1.filter(function(_, index) {
      return count2 <= index;
    });
  }
  skip.skip = skip$1;
  return skip;
}
var skipLast = {};
var hasRequiredSkipLast;
function requireSkipLast() {
  if (hasRequiredSkipLast)
    return skipLast;
  hasRequiredSkipLast = 1;
  Object.defineProperty(skipLast, "__esModule", { value: true });
  skipLast.skipLast = void 0;
  var identity_1 = requireIdentity();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function skipLast$1(skipCount) {
    return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source2, subscriber) {
      var ring = new Array(skipCount);
      var seen = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var valueIndex = seen++;
        if (valueIndex < skipCount) {
          ring[valueIndex] = value;
        } else {
          var index = valueIndex % skipCount;
          var oldValue = ring[index];
          ring[index] = value;
          subscriber.next(oldValue);
        }
      }));
      return function() {
        ring = null;
      };
    });
  }
  skipLast.skipLast = skipLast$1;
  return skipLast;
}
var skipUntil = {};
var hasRequiredSkipUntil;
function requireSkipUntil() {
  if (hasRequiredSkipUntil)
    return skipUntil;
  hasRequiredSkipUntil = 1;
  Object.defineProperty(skipUntil, "__esModule", { value: true });
  skipUntil.skipUntil = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  var noop_1 = requireNoop();
  function skipUntil$1(notifier) {
    return lift_1.operate(function(source2, subscriber) {
      var taking = false;
      var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
        taking = true;
      }, noop_1.noop);
      innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return taking && subscriber.next(value);
      }));
    });
  }
  skipUntil.skipUntil = skipUntil$1;
  return skipUntil;
}
var skipWhile = {};
var hasRequiredSkipWhile;
function requireSkipWhile() {
  if (hasRequiredSkipWhile)
    return skipWhile;
  hasRequiredSkipWhile = 1;
  Object.defineProperty(skipWhile, "__esModule", { value: true });
  skipWhile.skipWhile = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function skipWhile$1(predicate) {
    return lift_1.operate(function(source2, subscriber) {
      var taking = false;
      var index = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
      }));
    });
  }
  skipWhile.skipWhile = skipWhile$1;
  return skipWhile;
}
var startWith = {};
var hasRequiredStartWith;
function requireStartWith() {
  if (hasRequiredStartWith)
    return startWith;
  hasRequiredStartWith = 1;
  Object.defineProperty(startWith, "__esModule", { value: true });
  startWith.startWith = void 0;
  var concat_1 = requireConcat$2();
  var args_1 = requireArgs();
  var lift_1 = requireLift();
  function startWith$1() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler2 = args_1.popScheduler(values);
    return lift_1.operate(function(source2, subscriber) {
      (scheduler2 ? concat_1.concat(values, source2, scheduler2) : concat_1.concat(values, source2)).subscribe(subscriber);
    });
  }
  startWith.startWith = startWith$1;
  return startWith;
}
var switchAll = {};
var switchMap = {};
var hasRequiredSwitchMap;
function requireSwitchMap() {
  if (hasRequiredSwitchMap)
    return switchMap;
  hasRequiredSwitchMap = 1;
  Object.defineProperty(switchMap, "__esModule", { value: true });
  switchMap.switchMap = void 0;
  var innerFrom_1 = requireInnerFrom();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function switchMap$1(project, resultSelector) {
    return lift_1.operate(function(source2, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  switchMap.switchMap = switchMap$1;
  return switchMap;
}
var hasRequiredSwitchAll;
function requireSwitchAll() {
  if (hasRequiredSwitchAll)
    return switchAll;
  hasRequiredSwitchAll = 1;
  Object.defineProperty(switchAll, "__esModule", { value: true });
  switchAll.switchAll = void 0;
  var switchMap_1 = requireSwitchMap();
  var identity_1 = requireIdentity();
  function switchAll$1() {
    return switchMap_1.switchMap(identity_1.identity);
  }
  switchAll.switchAll = switchAll$1;
  return switchAll;
}
var switchMapTo = {};
var hasRequiredSwitchMapTo;
function requireSwitchMapTo() {
  if (hasRequiredSwitchMapTo)
    return switchMapTo;
  hasRequiredSwitchMapTo = 1;
  Object.defineProperty(switchMapTo, "__esModule", { value: true });
  switchMapTo.switchMapTo = void 0;
  var switchMap_1 = requireSwitchMap();
  var isFunction_1 = requireIsFunction();
  function switchMapTo$1(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap_1.switchMap(function() {
      return innerObservable;
    });
  }
  switchMapTo.switchMapTo = switchMapTo$1;
  return switchMapTo;
}
var switchScan = {};
var hasRequiredSwitchScan;
function requireSwitchScan() {
  if (hasRequiredSwitchScan)
    return switchScan;
  hasRequiredSwitchScan = 1;
  Object.defineProperty(switchScan, "__esModule", { value: true });
  switchScan.switchScan = void 0;
  var switchMap_1 = requireSwitchMap();
  var lift_1 = requireLift();
  function switchScan$1(accumulator, seed) {
    return lift_1.operate(function(source2, subscriber) {
      var state2 = seed;
      switchMap_1.switchMap(function(value, index) {
        return accumulator(state2, value, index);
      }, function(_, innerValue) {
        return state2 = innerValue, innerValue;
      })(source2).subscribe(subscriber);
      return function() {
        state2 = null;
      };
    });
  }
  switchScan.switchScan = switchScan$1;
  return switchScan;
}
var takeUntil = {};
var hasRequiredTakeUntil;
function requireTakeUntil() {
  if (hasRequiredTakeUntil)
    return takeUntil;
  hasRequiredTakeUntil = 1;
  Object.defineProperty(takeUntil, "__esModule", { value: true });
  takeUntil.takeUntil = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  var noop_1 = requireNoop();
  function takeUntil$1(notifier) {
    return lift_1.operate(function(source2, subscriber) {
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop_1.noop));
      !subscriber.closed && source2.subscribe(subscriber);
    });
  }
  takeUntil.takeUntil = takeUntil$1;
  return takeUntil;
}
var takeWhile = {};
var hasRequiredTakeWhile;
function requireTakeWhile() {
  if (hasRequiredTakeWhile)
    return takeWhile;
  hasRequiredTakeWhile = 1;
  Object.defineProperty(takeWhile, "__esModule", { value: true });
  takeWhile.takeWhile = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function takeWhile$1(predicate, inclusive) {
    if (inclusive === void 0) {
      inclusive = false;
    }
    return lift_1.operate(function(source2, subscriber) {
      var index = 0;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var result = predicate(value, index++);
        (result || inclusive) && subscriber.next(value);
        !result && subscriber.complete();
      }));
    });
  }
  takeWhile.takeWhile = takeWhile$1;
  return takeWhile;
}
var tap = {};
var hasRequiredTap;
function requireTap() {
  if (hasRequiredTap)
    return tap;
  hasRequiredTap = 1;
  Object.defineProperty(tap, "__esModule", { value: true });
  tap.tap = void 0;
  var isFunction_1 = requireIsFunction();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var identity_1 = requireIdentity();
  function tap$1(observerOrNext, error2, complete) {
    var tapObserver = isFunction_1.isFunction(observerOrNext) || error2 || complete ? { next: observerOrNext, error: error2, complete } : observerOrNext;
    return tapObserver ? lift_1.operate(function(source2, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity_1.identity;
  }
  tap.tap = tap$1;
  return tap;
}
var throttle$1 = {};
var hasRequiredThrottle;
function requireThrottle() {
  if (hasRequiredThrottle)
    return throttle$1;
  hasRequiredThrottle = 1;
  Object.defineProperty(throttle$1, "__esModule", { value: true });
  throttle$1.throttle = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  function throttle2(durationSelector, config2) {
    return lift_1.operate(function(source2, subscriber) {
      var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send2();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value) {
        return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send2 = function() {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send2() : startThrottle(value));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  }
  throttle$1.throttle = throttle2;
  return throttle$1;
}
var throttleTime = {};
var hasRequiredThrottleTime;
function requireThrottleTime() {
  if (hasRequiredThrottleTime)
    return throttleTime;
  hasRequiredThrottleTime = 1;
  Object.defineProperty(throttleTime, "__esModule", { value: true });
  throttleTime.throttleTime = void 0;
  var async_12 = requireAsync();
  var throttle_1 = requireThrottle();
  var timer_1 = requireTimer();
  function throttleTime$1(duration, scheduler2, config2) {
    if (scheduler2 === void 0) {
      scheduler2 = async_12.asyncScheduler;
    }
    var duration$ = timer_1.timer(duration, scheduler2);
    return throttle_1.throttle(function() {
      return duration$;
    }, config2);
  }
  throttleTime.throttleTime = throttleTime$1;
  return throttleTime;
}
var timeInterval = {};
var hasRequiredTimeInterval;
function requireTimeInterval() {
  if (hasRequiredTimeInterval)
    return timeInterval;
  hasRequiredTimeInterval = 1;
  Object.defineProperty(timeInterval, "__esModule", { value: true });
  timeInterval.TimeInterval = timeInterval.timeInterval = void 0;
  var async_12 = requireAsync();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function timeInterval$1(scheduler2) {
    if (scheduler2 === void 0) {
      scheduler2 = async_12.asyncScheduler;
    }
    return lift_1.operate(function(source2, subscriber) {
      var last2 = scheduler2.now();
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var now = scheduler2.now();
        var interval2 = now - last2;
        last2 = now;
        subscriber.next(new TimeInterval(value, interval2));
      }));
    });
  }
  timeInterval.timeInterval = timeInterval$1;
  var TimeInterval = function() {
    function TimeInterval2(value, interval2) {
      this.value = value;
      this.interval = interval2;
    }
    return TimeInterval2;
  }();
  timeInterval.TimeInterval = TimeInterval;
  return timeInterval;
}
var timeoutWith = {};
var hasRequiredTimeoutWith;
function requireTimeoutWith() {
  if (hasRequiredTimeoutWith)
    return timeoutWith;
  hasRequiredTimeoutWith = 1;
  Object.defineProperty(timeoutWith, "__esModule", { value: true });
  timeoutWith.timeoutWith = void 0;
  var async_12 = requireAsync();
  var isDate_1 = requireIsDate();
  var timeout_1 = requireTimeout();
  function timeoutWith$1(due, withObservable, scheduler2) {
    var first2;
    var each;
    var _with;
    scheduler2 = scheduler2 !== null && scheduler2 !== void 0 ? scheduler2 : async_12.async;
    if (isDate_1.isValidDate(due)) {
      first2 = due;
    } else if (typeof due === "number") {
      each = due;
    }
    if (withObservable) {
      _with = function() {
        return withObservable;
      };
    } else {
      throw new TypeError("No observable provided to switch to");
    }
    if (first2 == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return timeout_1.timeout({
      first: first2,
      each,
      scheduler: scheduler2,
      with: _with
    });
  }
  timeoutWith.timeoutWith = timeoutWith$1;
  return timeoutWith;
}
var timestamp = {};
var hasRequiredTimestamp;
function requireTimestamp() {
  if (hasRequiredTimestamp)
    return timestamp;
  hasRequiredTimestamp = 1;
  Object.defineProperty(timestamp, "__esModule", { value: true });
  timestamp.timestamp = void 0;
  var dateTimestampProvider_1 = requireDateTimestampProvider();
  var map_1 = requireMap$1();
  function timestamp$1(timestampProvider) {
    if (timestampProvider === void 0) {
      timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
    }
    return map_1.map(function(value) {
      return { value, timestamp: timestampProvider.now() };
    });
  }
  timestamp.timestamp = timestamp$1;
  return timestamp;
}
var window$1 = {};
var hasRequiredWindow;
function requireWindow() {
  if (hasRequiredWindow)
    return window$1;
  hasRequiredWindow = 1;
  Object.defineProperty(window$1, "__esModule", { value: true });
  window$1.window = void 0;
  var Subject_1 = requireSubject();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var noop_1 = requireNoop();
  var innerFrom_1 = requireInnerFrom();
  function window2(windowBoundaries) {
    return lift_1.operate(function(source2, subscriber) {
      var windowSubject = new Subject_1.Subject();
      subscriber.next(windowSubject.asObservable());
      var errorHandler = function(err) {
        windowSubject.error(err);
        subscriber.error(err);
      };
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
      }, function() {
        windowSubject.complete();
        subscriber.complete();
      }, errorHandler));
      innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        windowSubject.complete();
        subscriber.next(windowSubject = new Subject_1.Subject());
      }, noop_1.noop, errorHandler));
      return function() {
        windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
        windowSubject = null;
      };
    });
  }
  window$1.window = window2;
  return window$1;
}
var windowCount = {};
var hasRequiredWindowCount;
function requireWindowCount() {
  if (hasRequiredWindowCount)
    return windowCount;
  hasRequiredWindowCount = 1;
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(windowCount, "__esModule", { value: true });
  windowCount.windowCount = void 0;
  var Subject_1 = requireSubject();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  function windowCount$1(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
      startWindowEvery = 0;
    }
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return lift_1.operate(function(source2, subscriber) {
      var windows2 = [new Subject_1.Subject()];
      var count2 = 0;
      subscriber.next(windows2[0].asObservable());
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        try {
          for (var windows_1 = __values2(windows2), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
            var window_1 = windows_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
              _a.call(windows_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var c = count2 - windowSize + 1;
        if (c >= 0 && c % startEvery === 0) {
          windows2.shift().complete();
        }
        if (++count2 % startEvery === 0) {
          var window_2 = new Subject_1.Subject();
          windows2.push(window_2);
          subscriber.next(window_2.asObservable());
        }
      }, function() {
        while (windows2.length > 0) {
          windows2.shift().complete();
        }
        subscriber.complete();
      }, function(err) {
        while (windows2.length > 0) {
          windows2.shift().error(err);
        }
        subscriber.error(err);
      }, function() {
        windows2 = null;
      }));
    });
  }
  windowCount.windowCount = windowCount$1;
  return windowCount;
}
var windowTime = {};
var hasRequiredWindowTime;
function requireWindowTime() {
  if (hasRequiredWindowTime)
    return windowTime;
  hasRequiredWindowTime = 1;
  Object.defineProperty(windowTime, "__esModule", { value: true });
  windowTime.windowTime = void 0;
  var Subject_1 = requireSubject();
  var async_12 = requireAsync();
  var Subscription_1 = requireSubscription();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var arrRemove_1 = requireArrRemove();
  var args_1 = requireArgs();
  var executeSchedule_1 = requireExecuteSchedule();
  function windowTime$1(windowTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler2 = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_12.asyncScheduler;
    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source2, subscriber) {
      var windowRecords = [];
      var restartOnClose = false;
      var closeWindow = function(record) {
        var window2 = record.window, subs = record.subs;
        window2.complete();
        subs.unsubscribe();
        arrRemove_1.arrRemove(windowRecords, record);
        restartOnClose && startWindow();
      };
      var startWindow = function() {
        if (windowRecords) {
          var subs = new Subscription_1.Subscription();
          subscriber.add(subs);
          var window_1 = new Subject_1.Subject();
          var record_1 = {
            window: window_1,
            subs,
            seen: 0
          };
          windowRecords.push(record_1);
          subscriber.next(window_1.asObservable());
          executeSchedule_1.executeSchedule(subs, scheduler2, function() {
            return closeWindow(record_1);
          }, windowTimeSpan);
        }
      };
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler2, startWindow, windowCreationInterval, true);
      } else {
        restartOnClose = true;
      }
      startWindow();
      var loop = function(cb) {
        return windowRecords.slice().forEach(cb);
      };
      var terminate = function(cb) {
        loop(function(_a2) {
          var window2 = _a2.window;
          return cb(window2);
        });
        cb(subscriber);
        subscriber.unsubscribe();
      };
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        loop(function(record) {
          record.window.next(value);
          maxWindowSize <= ++record.seen && closeWindow(record);
        });
      }, function() {
        return terminate(function(consumer) {
          return consumer.complete();
        });
      }, function(err) {
        return terminate(function(consumer) {
          return consumer.error(err);
        });
      }));
      return function() {
        windowRecords = null;
      };
    });
  }
  windowTime.windowTime = windowTime$1;
  return windowTime;
}
var windowToggle = {};
var hasRequiredWindowToggle;
function requireWindowToggle() {
  if (hasRequiredWindowToggle)
    return windowToggle;
  hasRequiredWindowToggle = 1;
  var __values2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(windowToggle, "__esModule", { value: true });
  windowToggle.windowToggle = void 0;
  var Subject_1 = requireSubject();
  var Subscription_1 = requireSubscription();
  var lift_1 = requireLift();
  var innerFrom_1 = requireInnerFrom();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var noop_1 = requireNoop();
  var arrRemove_1 = requireArrRemove();
  function windowToggle$1(openings, closingSelector) {
    return lift_1.operate(function(source2, subscriber) {
      var windows2 = [];
      var handleError = function(err) {
        while (0 < windows2.length) {
          windows2.shift().error(err);
        }
        subscriber.error(err);
      };
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var window2 = new Subject_1.Subject();
        windows2.push(window2);
        var closingSubscription = new Subscription_1.Subscription();
        var closeWindow = function() {
          arrRemove_1.arrRemove(windows2, window2);
          window2.complete();
          closingSubscription.unsubscribe();
        };
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
        } catch (err) {
          handleError(err);
          return;
        }
        subscriber.next(window2.asObservable());
        closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
      }, noop_1.noop));
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        var windowsCopy = windows2.slice();
        try {
          for (var windowsCopy_1 = __values2(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
            var window_1 = windowsCopy_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
              _a.call(windowsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (0 < windows2.length) {
          windows2.shift().complete();
        }
        subscriber.complete();
      }, handleError, function() {
        while (0 < windows2.length) {
          windows2.shift().unsubscribe();
        }
      }));
    });
  }
  windowToggle.windowToggle = windowToggle$1;
  return windowToggle;
}
var windowWhen = {};
var hasRequiredWindowWhen;
function requireWindowWhen() {
  if (hasRequiredWindowWhen)
    return windowWhen;
  hasRequiredWindowWhen = 1;
  Object.defineProperty(windowWhen, "__esModule", { value: true });
  windowWhen.windowWhen = void 0;
  var Subject_1 = requireSubject();
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  function windowWhen$1(closingSelector) {
    return lift_1.operate(function(source2, subscriber) {
      var window2;
      var closingSubscriber;
      var handleError = function(err) {
        window2.error(err);
        subscriber.error(err);
      };
      var openWindow = function() {
        closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
        window2 === null || window2 === void 0 ? void 0 : window2.complete();
        window2 = new Subject_1.Subject();
        subscriber.next(window2.asObservable());
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector());
        } catch (err) {
          handleError(err);
          return;
        }
        closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
      };
      openWindow();
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return window2.next(value);
      }, function() {
        window2.complete();
        subscriber.complete();
      }, handleError, function() {
        closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
        window2 = null;
      }));
    });
  }
  windowWhen.windowWhen = windowWhen$1;
  return windowWhen;
}
var withLatestFrom = {};
var hasRequiredWithLatestFrom;
function requireWithLatestFrom() {
  if (hasRequiredWithLatestFrom)
    return withLatestFrom;
  hasRequiredWithLatestFrom = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(withLatestFrom, "__esModule", { value: true });
  withLatestFrom.withLatestFrom = void 0;
  var lift_1 = requireLift();
  var OperatorSubscriber_1 = requireOperatorSubscriber();
  var innerFrom_1 = requireInnerFrom();
  var identity_1 = requireIdentity();
  var noop_1 = requireNoop();
  var args_1 = requireArgs();
  function withLatestFrom$1() {
    var inputs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = args_1.popResultSelector(inputs);
    return lift_1.operate(function(source2, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i2) {
        innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          otherValues[i2] = value;
          if (!ready && !hasValue[i2]) {
            hasValue[i2] = true;
            (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
          }
        }, noop_1.noop));
      };
      for (var i = 0; i < len; i++) {
        _loop_1(i);
      }
      source2.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values = __spreadArray2([value], __read2(otherValues));
          subscriber.next(project ? project.apply(void 0, __spreadArray2([], __read2(values))) : values);
        }
      }));
    });
  }
  withLatestFrom.withLatestFrom = withLatestFrom$1;
  return withLatestFrom;
}
var zipAll = {};
var hasRequiredZipAll;
function requireZipAll() {
  if (hasRequiredZipAll)
    return zipAll;
  hasRequiredZipAll = 1;
  Object.defineProperty(zipAll, "__esModule", { value: true });
  zipAll.zipAll = void 0;
  var zip_1 = requireZip$2();
  var joinAllInternals_1 = requireJoinAllInternals();
  function zipAll$1(project) {
    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
  }
  zipAll.zipAll = zipAll$1;
  return zipAll;
}
var zipWith = {};
var zip$1 = {};
var hasRequiredZip$1;
function requireZip$1() {
  if (hasRequiredZip$1)
    return zip$1;
  hasRequiredZip$1 = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(zip$1, "__esModule", { value: true });
  zip$1.zip = void 0;
  var zip_1 = requireZip$2();
  var lift_1 = requireLift();
  function zip2() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return lift_1.operate(function(source2, subscriber) {
      zip_1.zip.apply(void 0, __spreadArray2([source2], __read2(sources))).subscribe(subscriber);
    });
  }
  zip$1.zip = zip2;
  return zip$1;
}
var hasRequiredZipWith;
function requireZipWith() {
  if (hasRequiredZipWith)
    return zipWith;
  hasRequiredZipWith = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(zipWith, "__esModule", { value: true });
  zipWith.zipWith = void 0;
  var zip_1 = requireZip$1();
  function zipWith$1() {
    var otherInputs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      otherInputs[_i] = arguments[_i];
    }
    return zip_1.zip.apply(void 0, __spreadArray2([], __read2(otherInputs)));
  }
  zipWith.zipWith = zipWith$1;
  return zipWith;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs)
    return cjs;
  hasRequiredCjs = 1;
  (function(exports2) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interval = exports2.iif = exports2.generate = exports2.fromEventPattern = exports2.fromEvent = exports2.from = exports2.forkJoin = exports2.empty = exports2.defer = exports2.connectable = exports2.concat = exports2.combineLatest = exports2.bindNodeCallback = exports2.bindCallback = exports2.UnsubscriptionError = exports2.TimeoutError = exports2.SequenceError = exports2.ObjectUnsubscribedError = exports2.NotFoundError = exports2.EmptyError = exports2.ArgumentOutOfRangeError = exports2.firstValueFrom = exports2.lastValueFrom = exports2.isObservable = exports2.identity = exports2.noop = exports2.pipe = exports2.NotificationKind = exports2.Notification = exports2.Subscriber = exports2.Subscription = exports2.Scheduler = exports2.VirtualAction = exports2.VirtualTimeScheduler = exports2.animationFrameScheduler = exports2.animationFrame = exports2.queueScheduler = exports2.queue = exports2.asyncScheduler = exports2.async = exports2.asapScheduler = exports2.asap = exports2.AsyncSubject = exports2.ReplaySubject = exports2.BehaviorSubject = exports2.Subject = exports2.animationFrames = exports2.observable = exports2.ConnectableObservable = exports2.Observable = void 0;
    exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.combineLatestWith = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = exports2.config = exports2.NEVER = exports2.EMPTY = exports2.scheduled = exports2.zip = exports2.using = exports2.timer = exports2.throwError = exports2.range = exports2.race = exports2.partition = exports2.pairs = exports2.onErrorResumeNext = exports2.of = exports2.never = exports2.merge = void 0;
    exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.pairwise = exports2.onErrorResumeNextWith = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = exports2.mergeAll = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = void 0;
    exports2.zipWith = exports2.zipAll = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = void 0;
    var Observable_1 = requireObservable();
    Object.defineProperty(exports2, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = requireConnectableObservable();
    Object.defineProperty(exports2, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = requireObservable$1();
    Object.defineProperty(exports2, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = requireAnimationFrames();
    Object.defineProperty(exports2, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = requireSubject();
    Object.defineProperty(exports2, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = requireBehaviorSubject();
    Object.defineProperty(exports2, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = requireReplaySubject();
    Object.defineProperty(exports2, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = requireAsyncSubject();
    Object.defineProperty(exports2, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = requireAsap();
    Object.defineProperty(exports2, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports2, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_12 = requireAsync();
    Object.defineProperty(exports2, "async", { enumerable: true, get: function() {
      return async_12.async;
    } });
    Object.defineProperty(exports2, "asyncScheduler", { enumerable: true, get: function() {
      return async_12.asyncScheduler;
    } });
    var queue_1 = requireQueue();
    Object.defineProperty(exports2, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports2, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = requireAnimationFrame();
    Object.defineProperty(exports2, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports2, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = requireVirtualTimeScheduler();
    Object.defineProperty(exports2, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports2, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = requireScheduler();
    Object.defineProperty(exports2, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = requireSubscription();
    Object.defineProperty(exports2, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = requireSubscriber();
    Object.defineProperty(exports2, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = requireNotification();
    Object.defineProperty(exports2, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports2, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = requirePipe();
    Object.defineProperty(exports2, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = requireNoop();
    Object.defineProperty(exports2, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = requireIdentity();
    Object.defineProperty(exports2, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = requireIsObservable();
    Object.defineProperty(exports2, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = requireLastValueFrom();
    Object.defineProperty(exports2, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = requireFirstValueFrom();
    Object.defineProperty(exports2, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = requireArgumentOutOfRangeError();
    Object.defineProperty(exports2, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = requireEmptyError();
    Object.defineProperty(exports2, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = requireNotFoundError();
    Object.defineProperty(exports2, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = requireObjectUnsubscribedError();
    Object.defineProperty(exports2, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = requireSequenceError();
    Object.defineProperty(exports2, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = requireTimeout();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = requireUnsubscriptionError();
    Object.defineProperty(exports2, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = requireBindCallback();
    Object.defineProperty(exports2, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = requireBindNodeCallback();
    Object.defineProperty(exports2, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = requireCombineLatest$1();
    Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = requireConcat$2();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = requireConnectable();
    Object.defineProperty(exports2, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_12 = requireDefer();
    Object.defineProperty(exports2, "defer", { enumerable: true, get: function() {
      return defer_12.defer;
    } });
    var empty_1 = requireEmpty();
    Object.defineProperty(exports2, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = requireForkJoin();
    Object.defineProperty(exports2, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = requireFrom();
    Object.defineProperty(exports2, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = requireFromEvent();
    Object.defineProperty(exports2, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = requireFromEventPattern();
    Object.defineProperty(exports2, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = requireGenerate();
    Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = requireIif();
    Object.defineProperty(exports2, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = requireInterval();
    Object.defineProperty(exports2, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = requireMerge$1();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = requireNever();
    Object.defineProperty(exports2, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = requireOf();
    Object.defineProperty(exports2, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = requireOnErrorResumeNext();
    Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = requirePairs();
    Object.defineProperty(exports2, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = requirePartition$1();
    Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = requireRace$1();
    Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = requireRange$1();
    Object.defineProperty(exports2, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = requireThrowError();
    Object.defineProperty(exports2, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = requireTimer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = requireUsing();
    Object.defineProperty(exports2, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = requireZip$2();
    Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = requireScheduled();
    Object.defineProperty(exports2, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = requireEmpty();
    Object.defineProperty(exports2, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = requireNever();
    Object.defineProperty(exports2, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar2(requireTypes(), exports2);
    var config_1 = requireConfig();
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = requireAudit();
    Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = requireAuditTime();
    Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = requireBuffer();
    Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = requireBufferCount();
    Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = requireBufferTime();
    Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = requireBufferToggle();
    Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = requireBufferWhen();
    Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = requireCatchError();
    Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = requireCombineAll();
    Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = requireCombineLatestAll();
    Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = requireCombineLatestWith();
    Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = requireConcatAll();
    Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = requireConcatMap();
    Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = requireConcatMapTo();
    Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = requireConcatWith();
    Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = requireConnect();
    Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = requireCount();
    Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = requireDebounce();
    Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = requireDebounceTime();
    Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = requireDefaultIfEmpty();
    Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = requireDelay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = requireDelayWhen();
    Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = requireDematerialize();
    Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = requireDistinct();
    Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = requireDistinctUntilChanged();
    Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = requireDistinctUntilKeyChanged();
    Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = requireElementAt();
    Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = requireEndWith();
    Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = requireEvery();
    Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = requireExhaust();
    Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = requireExhaustAll();
    Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = requireExhaustMap();
    Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = requireExpand();
    Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = requireFilter$1();
    Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = requireFinalize();
    Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = requireFind();
    Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = requireFindIndex();
    Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = requireFirst();
    Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = requireGroupBy();
    Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = requireIgnoreElements();
    Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = requireIsEmpty();
    Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = requireLast();
    Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = requireMap$1();
    Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = requireMapTo();
    Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = requireMaterialize();
    Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = requireMax();
    Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = requireMergeAll();
    Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = requireFlatMap();
    Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = requireMergeMap();
    Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = requireMergeMapTo();
    Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = requireMergeScan();
    Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = requireMergeWith();
    Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = requireMin();
    Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = requireMulticast();
    Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = requireObserveOn();
    Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = requireOnErrorResumeNextWith();
    Object.defineProperty(exports2, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = requirePairwise();
    Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = requirePluck();
    Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = requirePublish();
    Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = requirePublishBehavior();
    Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = requirePublishLast();
    Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = requirePublishReplay();
    Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = requireRaceWith();
    Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = requireReduce();
    Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = requireRepeat();
    Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = requireRepeatWhen();
    Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = requireRetry();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = requireRetryWhen();
    Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = requireRefCount();
    Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = requireSample();
    Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = requireSampleTime();
    Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = requireScan();
    Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = requireSequenceEqual();
    Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = requireShare();
    Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = requireShareReplay();
    Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = requireSingle();
    Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = requireSkip();
    Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = requireSkipLast();
    Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = requireSkipUntil();
    Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = requireSkipWhile();
    Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = requireStartWith();
    Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = requireSubscribeOn();
    Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = requireSwitchAll();
    Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = requireSwitchMap();
    Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = requireSwitchMapTo();
    Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = requireSwitchScan();
    Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = requireTake();
    Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = requireTakeLast();
    Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = requireTakeUntil();
    Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = requireTakeWhile();
    Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = requireTap();
    Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = requireThrottle();
    Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = requireThrottleTime();
    Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = requireThrowIfEmpty();
    Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = requireTimeInterval();
    Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = requireTimeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = requireTimeoutWith();
    Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = requireTimestamp();
    Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = requireToArray();
    Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = requireWindow();
    Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = requireWindowCount();
    Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = requireWindowTime();
    Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = requireWindowToggle();
    Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = requireWindowWhen();
    Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = requireWithLatestFrom();
    Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = requireZipAll();
    Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = requireZipWith();
    Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  })(cjs);
  return cjs;
}
var operators = {};
var partition = {};
var hasRequiredPartition;
function requirePartition() {
  if (hasRequiredPartition)
    return partition;
  hasRequiredPartition = 1;
  Object.defineProperty(partition, "__esModule", { value: true });
  partition.partition = void 0;
  var not_12 = requireNot();
  var filter_1 = requireFilter$1();
  function partition$12(predicate, thisArg) {
    return function(source2) {
      return [filter_1.filter(predicate, thisArg)(source2), filter_1.filter(not_12.not(predicate, thisArg))(source2)];
    };
  }
  partition.partition = partition$12;
  return partition;
}
var race = {};
var hasRequiredRace;
function requireRace() {
  if (hasRequiredRace)
    return race;
  hasRequiredRace = 1;
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(race, "__esModule", { value: true });
  race.race = void 0;
  var argsOrArgArray_1 = requireArgsOrArgArray();
  var raceWith_1 = requireRaceWith();
  function race$12() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    return raceWith_1.raceWith.apply(void 0, __spreadArray2([], __read2(argsOrArgArray_1.argsOrArgArray(args2))));
  }
  race.race = race$12;
  return race;
}
var hasRequiredOperators;
function requireOperators() {
  if (hasRequiredOperators)
    return operators;
  hasRequiredOperators = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeAll = exports2.merge = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.concat = exports2.combineLatestWith = exports2.combineLatest = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = void 0;
    exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.race = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.partition = exports2.pairwise = exports2.onErrorResumeNext = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = void 0;
    exports2.zipWith = exports2.zipAll = exports2.zip = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = void 0;
    var audit_1 = requireAudit();
    Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = requireAuditTime();
    Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = requireBuffer();
    Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = requireBufferCount();
    Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = requireBufferTime();
    Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = requireBufferToggle();
    Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = requireBufferWhen();
    Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = requireCatchError();
    Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = requireCombineAll();
    Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = requireCombineLatestAll();
    Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatest_1 = requireCombineLatest();
    Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var combineLatestWith_1 = requireCombineLatestWith();
    Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concat_1 = requireConcat$1();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var concatAll_1 = requireConcatAll();
    Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = requireConcatMap();
    Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = requireConcatMapTo();
    Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = requireConcatWith();
    Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = requireConnect();
    Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = requireCount();
    Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = requireDebounce();
    Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = requireDebounceTime();
    Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = requireDefaultIfEmpty();
    Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = requireDelay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = requireDelayWhen();
    Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = requireDematerialize();
    Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = requireDistinct();
    Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = requireDistinctUntilChanged();
    Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = requireDistinctUntilKeyChanged();
    Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = requireElementAt();
    Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = requireEndWith();
    Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = requireEvery();
    Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = requireExhaust();
    Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = requireExhaustAll();
    Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = requireExhaustMap();
    Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = requireExpand();
    Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = requireFilter$1();
    Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = requireFinalize();
    Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = requireFind();
    Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = requireFindIndex();
    Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = requireFirst();
    Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = requireGroupBy();
    Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = requireIgnoreElements();
    Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = requireIsEmpty();
    Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = requireLast();
    Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = requireMap$1();
    Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = requireMapTo();
    Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = requireMaterialize();
    Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = requireMax();
    Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var merge_1 = requireMerge();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var mergeAll_1 = requireMergeAll();
    Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = requireFlatMap();
    Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = requireMergeMap();
    Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = requireMergeMapTo();
    Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = requireMergeScan();
    Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = requireMergeWith();
    Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = requireMin();
    Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = requireMulticast();
    Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = requireObserveOn();
    Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = requireOnErrorResumeNextWith();
    Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNext;
    } });
    var pairwise_1 = requirePairwise();
    Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var partition_1 = requirePartition();
    Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var pluck_1 = requirePluck();
    Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = requirePublish();
    Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = requirePublishBehavior();
    Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = requirePublishLast();
    Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = requirePublishReplay();
    Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var race_1 = requireRace();
    Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var raceWith_1 = requireRaceWith();
    Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = requireReduce();
    Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = requireRepeat();
    Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = requireRepeatWhen();
    Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = requireRetry();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = requireRetryWhen();
    Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = requireRefCount();
    Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = requireSample();
    Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = requireSampleTime();
    Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = requireScan();
    Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = requireSequenceEqual();
    Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = requireShare();
    Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = requireShareReplay();
    Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = requireSingle();
    Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = requireSkip();
    Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = requireSkipLast();
    Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = requireSkipUntil();
    Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = requireSkipWhile();
    Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = requireStartWith();
    Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = requireSubscribeOn();
    Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = requireSwitchAll();
    Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = requireSwitchMap();
    Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = requireSwitchMapTo();
    Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = requireSwitchScan();
    Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = requireTake();
    Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = requireTakeLast();
    Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = requireTakeUntil();
    Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = requireTakeWhile();
    Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = requireTap();
    Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = requireThrottle();
    Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = requireThrottleTime();
    Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = requireThrowIfEmpty();
    Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = requireTimeInterval();
    Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_1 = requireTimeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var timeoutWith_1 = requireTimeoutWith();
    Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = requireTimestamp();
    Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = requireToArray();
    Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = requireWindow();
    Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = requireWindowCount();
    Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = requireWindowTime();
    Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = requireWindowToggle();
    Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = requireWindowWhen();
    Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = requireWithLatestFrom();
    Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zip_1 = requireZip$1();
    Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var zipAll_1 = requireZipAll();
    Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = requireZipWith();
    Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  })(operators);
  return operators;
}
var fileStream = {};
var streamableFile = {};
var enums = {};
var httpStatus_enum = {};
var hasRequiredHttpStatus_enum;
function requireHttpStatus_enum() {
  if (hasRequiredHttpStatus_enum)
    return httpStatus_enum;
  hasRequiredHttpStatus_enum = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpStatus = void 0;
    (function(HttpStatus) {
      HttpStatus[HttpStatus["CONTINUE"] = 100] = "CONTINUE";
      HttpStatus[HttpStatus["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
      HttpStatus[HttpStatus["PROCESSING"] = 102] = "PROCESSING";
      HttpStatus[HttpStatus["EARLYHINTS"] = 103] = "EARLYHINTS";
      HttpStatus[HttpStatus["OK"] = 200] = "OK";
      HttpStatus[HttpStatus["CREATED"] = 201] = "CREATED";
      HttpStatus[HttpStatus["ACCEPTED"] = 202] = "ACCEPTED";
      HttpStatus[HttpStatus["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
      HttpStatus[HttpStatus["NO_CONTENT"] = 204] = "NO_CONTENT";
      HttpStatus[HttpStatus["RESET_CONTENT"] = 205] = "RESET_CONTENT";
      HttpStatus[HttpStatus["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
      HttpStatus[HttpStatus["AMBIGUOUS"] = 300] = "AMBIGUOUS";
      HttpStatus[HttpStatus["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
      HttpStatus[HttpStatus["FOUND"] = 302] = "FOUND";
      HttpStatus[HttpStatus["SEE_OTHER"] = 303] = "SEE_OTHER";
      HttpStatus[HttpStatus["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
      HttpStatus[HttpStatus["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
      HttpStatus[HttpStatus["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
      HttpStatus[HttpStatus["BAD_REQUEST"] = 400] = "BAD_REQUEST";
      HttpStatus[HttpStatus["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
      HttpStatus[HttpStatus["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
      HttpStatus[HttpStatus["FORBIDDEN"] = 403] = "FORBIDDEN";
      HttpStatus[HttpStatus["NOT_FOUND"] = 404] = "NOT_FOUND";
      HttpStatus[HttpStatus["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
      HttpStatus[HttpStatus["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
      HttpStatus[HttpStatus["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
      HttpStatus[HttpStatus["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
      HttpStatus[HttpStatus["CONFLICT"] = 409] = "CONFLICT";
      HttpStatus[HttpStatus["GONE"] = 410] = "GONE";
      HttpStatus[HttpStatus["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
      HttpStatus[HttpStatus["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
      HttpStatus[HttpStatus["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
      HttpStatus[HttpStatus["URI_TOO_LONG"] = 414] = "URI_TOO_LONG";
      HttpStatus[HttpStatus["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
      HttpStatus[HttpStatus["REQUESTED_RANGE_NOT_SATISFIABLE"] = 416] = "REQUESTED_RANGE_NOT_SATISFIABLE";
      HttpStatus[HttpStatus["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
      HttpStatus[HttpStatus["I_AM_A_TEAPOT"] = 418] = "I_AM_A_TEAPOT";
      HttpStatus[HttpStatus["MISDIRECTED"] = 421] = "MISDIRECTED";
      HttpStatus[HttpStatus["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
      HttpStatus[HttpStatus["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
      HttpStatus[HttpStatus["PRECONDITION_REQUIRED"] = 428] = "PRECONDITION_REQUIRED";
      HttpStatus[HttpStatus["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
      HttpStatus[HttpStatus["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
      HttpStatus[HttpStatus["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
      HttpStatus[HttpStatus["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
      HttpStatus[HttpStatus["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
      HttpStatus[HttpStatus["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
      HttpStatus[HttpStatus["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
    })(exports2.HttpStatus || (exports2.HttpStatus = {}));
  })(httpStatus_enum);
  return httpStatus_enum;
}
var shutdownSignal_enum = {};
var hasRequiredShutdownSignal_enum;
function requireShutdownSignal_enum() {
  if (hasRequiredShutdownSignal_enum)
    return shutdownSignal_enum;
  hasRequiredShutdownSignal_enum = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShutdownSignal = void 0;
    (function(ShutdownSignal) {
      ShutdownSignal["SIGHUP"] = "SIGHUP";
      ShutdownSignal["SIGINT"] = "SIGINT";
      ShutdownSignal["SIGQUIT"] = "SIGQUIT";
      ShutdownSignal["SIGILL"] = "SIGILL";
      ShutdownSignal["SIGTRAP"] = "SIGTRAP";
      ShutdownSignal["SIGABRT"] = "SIGABRT";
      ShutdownSignal["SIGBUS"] = "SIGBUS";
      ShutdownSignal["SIGFPE"] = "SIGFPE";
      ShutdownSignal["SIGSEGV"] = "SIGSEGV";
      ShutdownSignal["SIGUSR2"] = "SIGUSR2";
      ShutdownSignal["SIGTERM"] = "SIGTERM";
    })(exports2.ShutdownSignal || (exports2.ShutdownSignal = {}));
  })(shutdownSignal_enum);
  return shutdownSignal_enum;
}
var versionType_enum = {};
var hasRequiredVersionType_enum;
function requireVersionType_enum() {
  if (hasRequiredVersionType_enum)
    return versionType_enum;
  hasRequiredVersionType_enum = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VersioningType = void 0;
    (function(VersioningType) {
      VersioningType[VersioningType["URI"] = 0] = "URI";
      VersioningType[VersioningType["HEADER"] = 1] = "HEADER";
      VersioningType[VersioningType["MEDIA_TYPE"] = 2] = "MEDIA_TYPE";
      VersioningType[VersioningType["CUSTOM"] = 3] = "CUSTOM";
    })(exports2.VersioningType || (exports2.VersioningType = {}));
  })(versionType_enum);
  return versionType_enum;
}
var hasRequiredEnums;
function requireEnums() {
  if (hasRequiredEnums)
    return enums;
  hasRequiredEnums = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireRequestMethod_enum(), exports2);
    tslib_1.__exportStar(requireHttpStatus_enum(), exports2);
    tslib_1.__exportStar(requireShutdownSignal_enum(), exports2);
    tslib_1.__exportStar(requireVersionType_enum(), exports2);
  })(enums);
  return enums;
}
var hasRequiredStreamableFile;
function requireStreamableFile() {
  if (hasRequiredStreamableFile)
    return streamableFile;
  hasRequiredStreamableFile = 1;
  Object.defineProperty(streamableFile, "__esModule", { value: true });
  streamableFile.StreamableFile = void 0;
  const stream_12 = require$$0$4;
  const util_12 = require$$1$1;
  const enums_1 = requireEnums();
  const shared_utils_1 = requireShared_utils();
  class StreamableFile {
    constructor(bufferOrReadStream, options = {}) {
      var _a;
      var _b;
      this.options = options;
      this.handleError = (err, res) => {
        if (res.destroyed) {
          return;
        }
        if (res.headersSent) {
          res.end();
          return;
        }
        res.statusCode = enums_1.HttpStatus.BAD_REQUEST;
        res.send(err.message);
      };
      if (util_12.types.isUint8Array(bufferOrReadStream)) {
        this.stream = new stream_12.Readable();
        this.stream.push(bufferOrReadStream);
        this.stream.push(null);
        (_a = (_b = this.options).length) !== null && _a !== void 0 ? _a : _b.length = bufferOrReadStream.length;
      } else if (bufferOrReadStream.pipe && (0, shared_utils_1.isFunction)(bufferOrReadStream.pipe)) {
        this.stream = bufferOrReadStream;
      }
    }
    getStream() {
      return this.stream;
    }
    getHeaders() {
      const { type: type2 = "application/octet-stream", disposition = void 0, length = void 0 } = this.options;
      return {
        type: type2,
        disposition,
        length
      };
    }
    get errorHandler() {
      return this.handleError;
    }
    setErrorHandler(handler) {
      this.handleError = handler;
      return this;
    }
  }
  streamableFile.StreamableFile = StreamableFile;
  return streamableFile;
}
var hasRequiredFileStream;
function requireFileStream() {
  if (hasRequiredFileStream)
    return fileStream;
  hasRequiredFileStream = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireStreamableFile(), exports2);
  })(fileStream);
  return fileStream;
}
var hasRequiredCache_interceptor;
function requireCache_interceptor() {
  if (hasRequiredCache_interceptor)
    return cache_interceptor;
  hasRequiredCache_interceptor = 1;
  Object.defineProperty(cache_interceptor, "__esModule", { value: true });
  cache_interceptor.CacheInterceptor = void 0;
  const tslib_1 = require$$0$3;
  const rxjs_1 = requireCjs();
  const operators_1 = requireOperators();
  const decorators_1 = requireDecorators$2();
  const file_stream_1 = requireFileStream();
  const logger_service_1 = requireLogger_service();
  const load_package_util_1 = requireLoadPackage_util();
  const shared_utils_1 = requireShared_utils();
  const cache_constants_1 = requireCache_constants();
  const HTTP_ADAPTER_HOST = "HttpAdapterHost";
  const REFLECTOR = "Reflector";
  let CacheInterceptor = class CacheInterceptor {
    constructor(cacheManager, reflector) {
      this.cacheManager = cacheManager;
      this.reflector = reflector;
      this.allowedMethods = ["GET"];
      const cacheManagerPackage = (0, load_package_util_1.loadPackage)("cache-manager", "CacheModule", () => require$$9$3);
      this.cacheManagerIsv5OrGreater = "memoryStore" in cacheManagerPackage;
      logger_service_1.Logger.warn('DEPRECATED! "CacheModule" (from the "@nestjs/common" package) is deprecated and will be removed in the next major release. Please, use the "@nestjs/cache-manager" package instead.');
    }
    async intercept(context, next) {
      var _a;
      const key = this.trackBy(context);
      const ttlValueOrFactory = (_a = this.reflector.get(cache_constants_1.CACHE_TTL_METADATA, context.getHandler())) !== null && _a !== void 0 ? _a : null;
      if (!key) {
        return next.handle();
      }
      try {
        const value = await this.cacheManager.get(key);
        if (!(0, shared_utils_1.isNil)(value)) {
          return (0, rxjs_1.of)(value);
        }
        const ttl = (0, shared_utils_1.isFunction)(ttlValueOrFactory) ? await ttlValueOrFactory(context) : ttlValueOrFactory;
        return next.handle().pipe((0, operators_1.tap)(async (response2) => {
          if (response2 instanceof file_stream_1.StreamableFile) {
            return;
          }
          const args2 = [key, response2];
          if (!(0, shared_utils_1.isNil)(ttl)) {
            args2.push(this.cacheManagerIsv5OrGreater ? ttl : { ttl });
          }
          try {
            await this.cacheManager.set(...args2);
          } catch (err) {
            logger_service_1.Logger.error(`An error has occurred when inserting "key: ${key}", "value: ${response2}"`, "CacheInterceptor");
          }
        }));
      } catch (_b) {
        return next.handle();
      }
    }
    trackBy(context) {
      const httpAdapter3 = this.httpAdapterHost.httpAdapter;
      const isHttpApp = httpAdapter3 && !!httpAdapter3.getRequestMethod;
      const cacheMetadata = this.reflector.get(cache_constants_1.CACHE_KEY_METADATA, context.getHandler());
      if (!isHttpApp || cacheMetadata) {
        return cacheMetadata;
      }
      const request2 = context.getArgByIndex(0);
      if (!this.isRequestCacheable(context)) {
        return void 0;
      }
      return httpAdapter3.getRequestUrl(request2);
    }
    isRequestCacheable(context) {
      const req = context.switchToHttp().getRequest();
      return this.allowedMethods.includes(req.method);
    }
  };
  tslib_1.__decorate([
    (0, decorators_1.Optional)(),
    (0, decorators_1.Inject)(HTTP_ADAPTER_HOST),
    tslib_1.__metadata("design:type", Object)
  ], CacheInterceptor.prototype, "httpAdapterHost", void 0);
  CacheInterceptor = tslib_1.__decorate([
    (0, decorators_1.Injectable)(),
    tslib_1.__param(0, (0, decorators_1.Inject)(cache_constants_1.CACHE_MANAGER)),
    tslib_1.__param(1, (0, decorators_1.Inject)(REFLECTOR)),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
  ], CacheInterceptor);
  cache_interceptor.CacheInterceptor = CacheInterceptor;
  return cache_interceptor;
}
var hasRequiredInterceptors$2;
function requireInterceptors$2() {
  if (hasRequiredInterceptors$2)
    return interceptors$2;
  hasRequiredInterceptors$2 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireCache_interceptor(), exports2);
  })(interceptors$2);
  return interceptors$2;
}
var interfaces$4 = {};
var cacheManager_interface = {};
var hasRequiredCacheManager_interface;
function requireCacheManager_interface() {
  if (hasRequiredCacheManager_interface)
    return cacheManager_interface;
  hasRequiredCacheManager_interface = 1;
  Object.defineProperty(cacheManager_interface, "__esModule", { value: true });
  return cacheManager_interface;
}
var cacheModule_interface = {};
var hasRequiredCacheModule_interface;
function requireCacheModule_interface() {
  if (hasRequiredCacheModule_interface)
    return cacheModule_interface;
  hasRequiredCacheModule_interface = 1;
  Object.defineProperty(cacheModule_interface, "__esModule", { value: true });
  return cacheModule_interface;
}
var hasRequiredInterfaces$4;
function requireInterfaces$4() {
  if (hasRequiredInterfaces$4)
    return interfaces$4;
  hasRequiredInterfaces$4 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireCacheManager_interface(), exports2);
    tslib_1.__exportStar(requireCacheModule_interface(), exports2);
  })(interfaces$4);
  return interfaces$4;
}
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache)
    return cache;
  hasRequiredCache = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireCache_constants(), exports2);
    tslib_1.__exportStar(requireCache_module(), exports2);
    tslib_1.__exportStar(requireDecorators$1(), exports2);
    tslib_1.__exportStar(requireInterceptors$2(), exports2);
    tslib_1.__exportStar(requireInterfaces$4(), exports2);
  })(cache);
  return cache;
}
var exceptions$2 = {};
var badRequest_exception = {};
var http_exception = {};
var services$1 = {};
var hasRequiredServices$1;
function requireServices$1() {
  if (hasRequiredServices$1)
    return services$1;
  hasRequiredServices$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireConsoleLogger_service(), exports2);
    tslib_1.__exportStar(requireLogger_service(), exports2);
  })(services$1);
  return services$1;
}
var hasRequiredHttp_exception;
function requireHttp_exception() {
  if (hasRequiredHttp_exception)
    return http_exception;
  hasRequiredHttp_exception = 1;
  Object.defineProperty(http_exception, "__esModule", { value: true });
  http_exception.HttpException = void 0;
  const services_1 = requireServices$1();
  const shared_utils_1 = requireShared_utils();
  class HttpException extends Error {
    /**
     * Instantiate a plain HTTP Exception.
     *
     * @example
     * throw new HttpException()
     * throw new HttpException('message', HttpStatus.BAD_REQUEST)
     * throw new HttpException({ reason: 'this can be a human readable reason' }, HttpStatus.BAD_REQUEST)
     * throw new HttpException(new Error('Cause Error'), HttpStatus.BAD_REQUEST)
     * throw new HttpException('custom message', HttpStatus.BAD_REQUEST, {
     *  cause: new Error('Cause Error'),
     * })
     *
     *
     * @usageNotes
     * The constructor arguments define the response and the HTTP response status code.
     * - The `response` argument (required) defines the JSON response body. alternatively, it can also be
     *  an error object that is used to define an error [cause](https://nodejs.org/en/blog/release/v16.9.0/#error-cause).
     * - The `status` argument (required) defines the HTTP Status Code.
     * - The `options` argument (optional) defines additional error options. Currently, it supports the `cause` attribute,
     *  and can be used as an alternative way to specify the error cause: `const error = new HttpException('description', 400, { cause: new Error() });`
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: the Http Status Code.
     * - `message`: a short description of the HTTP error by default; override this
     * by supplying a string in the `response` parameter.
     *
     * To override the entire JSON response body, pass an object to the `createBody`
     * method. Nest will serialize the object and return it as the JSON response body.
     *
     * The `status` argument is required, and should be a valid HTTP status code.
     * Best practice is to use the `HttpStatus` enum imported from `nestjs/common`.
     *
     * @param response string, object describing the error condition or the error cause.
     * @param status HTTP response status code.
     * @param options An object used to add an error cause.
     */
    constructor(response2, status, options) {
      super();
      this.response = response2;
      this.status = status;
      this.options = options;
      this.initMessage();
      this.initName();
      this.initCause();
    }
    /**
     * Configures error chaining support
     *
     * See:
     * - https://nodejs.org/en/blog/release/v16.9.0/#error-cause
     * - https://github.com/microsoft/TypeScript/issues/45167
     */
    initCause() {
      var _a;
      if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.cause) {
        this.cause = this.options.cause;
        return;
      }
      if (this.response instanceof Error) {
        services_1.Logger.warn('DEPRECATED! Passing the error cause as the first argument to HttpException constructor is deprecated. You should use the "options" parameter instead: new HttpException("message", 400, { cause: new Error("Some Error") }) ');
        this.cause = this.response;
      }
    }
    initMessage() {
      var _a, _b;
      if ((0, shared_utils_1.isString)(this.response)) {
        this.message = this.response;
      } else if ((0, shared_utils_1.isObject)(this.response) && (0, shared_utils_1.isString)(this.response.message)) {
        this.message = this.response.message;
      } else if (this.constructor) {
        this.message = (_b = (_a = this.constructor.name.match(/[A-Z][a-z]+|[0-9]+/g)) === null || _a === void 0 ? void 0 : _a.join(" ")) !== null && _b !== void 0 ? _b : "Error";
      }
    }
    initName() {
      this.name = this.constructor.name;
    }
    getResponse() {
      return this.response;
    }
    getStatus() {
      return this.status;
    }
    static createBody(objectOrErrorMessage, description2, statusCode) {
      if (!objectOrErrorMessage) {
        return { statusCode, message: description2 };
      }
      return (0, shared_utils_1.isObject)(objectOrErrorMessage) && !Array.isArray(objectOrErrorMessage) ? objectOrErrorMessage : { statusCode, message: objectOrErrorMessage, error: description2 };
    }
    static getDescriptionFrom(descriptionOrOptions) {
      return (0, shared_utils_1.isString)(descriptionOrOptions) ? descriptionOrOptions : descriptionOrOptions === null || descriptionOrOptions === void 0 ? void 0 : descriptionOrOptions.description;
    }
    static getHttpExceptionOptionsFrom(descriptionOrOptions) {
      return (0, shared_utils_1.isString)(descriptionOrOptions) ? {} : descriptionOrOptions;
    }
    /**
     * Utility method used to extract the error description and httpExceptionOptions from the given argument.
     * This is used by inheriting classes to correctly parse both options.
     * @returns the error description and the httpExceptionOptions as an object.
     */
    static extractDescriptionAndOptionsFrom(descriptionOrOptions) {
      const description2 = (0, shared_utils_1.isString)(descriptionOrOptions) ? descriptionOrOptions : descriptionOrOptions === null || descriptionOrOptions === void 0 ? void 0 : descriptionOrOptions.description;
      const httpExceptionOptions = (0, shared_utils_1.isString)(descriptionOrOptions) ? {} : descriptionOrOptions;
      return {
        description: description2,
        httpExceptionOptions
      };
    }
  }
  http_exception.HttpException = HttpException;
  return http_exception;
}
var hasRequiredBadRequest_exception;
function requireBadRequest_exception() {
  if (hasRequiredBadRequest_exception)
    return badRequest_exception;
  hasRequiredBadRequest_exception = 1;
  Object.defineProperty(badRequest_exception, "__esModule", { value: true });
  badRequest_exception.BadRequestException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class BadRequestException extends http_exception_1.HttpException {
    /**
     * Instantiate a `BadRequestException` Exception.
     *
     * @example
     * `throw new BadRequestException()`
     *
     * @usageNotes
     * The HTTP response status code will be 400.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 400.
     * - `message`: the string `'Bad Request'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Bad Request") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.BAD_REQUEST), http_status_enum_1.HttpStatus.BAD_REQUEST, httpExceptionOptions);
    }
  }
  badRequest_exception.BadRequestException = BadRequestException;
  return badRequest_exception;
}
var unauthorized_exception = {};
var hasRequiredUnauthorized_exception;
function requireUnauthorized_exception() {
  if (hasRequiredUnauthorized_exception)
    return unauthorized_exception;
  hasRequiredUnauthorized_exception = 1;
  Object.defineProperty(unauthorized_exception, "__esModule", { value: true });
  unauthorized_exception.UnauthorizedException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class UnauthorizedException extends http_exception_1.HttpException {
    /**
     * Instantiate an `UnauthorizedException` Exception.
     *
     * @example
     * `throw new UnauthorizedException()`
     *
     * @usageNotes
     * The HTTP response status code will be 401.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 401.
     * - `message`: the string `'Unauthorized'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Unauthorized") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.UNAUTHORIZED), http_status_enum_1.HttpStatus.UNAUTHORIZED, httpExceptionOptions);
    }
  }
  unauthorized_exception.UnauthorizedException = UnauthorizedException;
  return unauthorized_exception;
}
var methodNotAllowed_exception = {};
var hasRequiredMethodNotAllowed_exception;
function requireMethodNotAllowed_exception() {
  if (hasRequiredMethodNotAllowed_exception)
    return methodNotAllowed_exception;
  hasRequiredMethodNotAllowed_exception = 1;
  Object.defineProperty(methodNotAllowed_exception, "__esModule", { value: true });
  methodNotAllowed_exception.MethodNotAllowedException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class MethodNotAllowedException extends http_exception_1.HttpException {
    /**
     * Instantiate a `MethodNotAllowedException` Exception.
     *
     * @example
     * `throw new MethodNotAllowedException()`
     *
     * @usageNotes
     * The HTTP response status code will be 405.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 405.
     * - `message`: the string `'Method Not Allowed'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Method Not Allowed") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.METHOD_NOT_ALLOWED), http_status_enum_1.HttpStatus.METHOD_NOT_ALLOWED, httpExceptionOptions);
    }
  }
  methodNotAllowed_exception.MethodNotAllowedException = MethodNotAllowedException;
  return methodNotAllowed_exception;
}
var notFound_exception = {};
var hasRequiredNotFound_exception;
function requireNotFound_exception() {
  if (hasRequiredNotFound_exception)
    return notFound_exception;
  hasRequiredNotFound_exception = 1;
  Object.defineProperty(notFound_exception, "__esModule", { value: true });
  notFound_exception.NotFoundException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class NotFoundException extends http_exception_1.HttpException {
    /**
     * Instantiate a `NotFoundException` Exception.
     *
     * @example
     * `throw new NotFoundException()`
     *
     * @usageNotes
     * The HTTP response status code will be 404.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 404.
     * - `message`: the string `'Not Found'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Not Found") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.NOT_FOUND), http_status_enum_1.HttpStatus.NOT_FOUND, httpExceptionOptions);
    }
  }
  notFound_exception.NotFoundException = NotFoundException;
  return notFound_exception;
}
var forbidden_exception = {};
var hasRequiredForbidden_exception;
function requireForbidden_exception() {
  if (hasRequiredForbidden_exception)
    return forbidden_exception;
  hasRequiredForbidden_exception = 1;
  Object.defineProperty(forbidden_exception, "__esModule", { value: true });
  forbidden_exception.ForbiddenException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class ForbiddenException extends http_exception_1.HttpException {
    /**
     * Instantiate a `ForbiddenException` Exception.
     *
     * @example
     * `throw new ForbiddenException()`
     *
     * @usageNotes
     * The HTTP response status code will be 403.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 403.
     * - `message`: the string `'Forbidden'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Forbidden") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.FORBIDDEN), http_status_enum_1.HttpStatus.FORBIDDEN, httpExceptionOptions);
    }
  }
  forbidden_exception.ForbiddenException = ForbiddenException;
  return forbidden_exception;
}
var notAcceptable_exception = {};
var hasRequiredNotAcceptable_exception;
function requireNotAcceptable_exception() {
  if (hasRequiredNotAcceptable_exception)
    return notAcceptable_exception;
  hasRequiredNotAcceptable_exception = 1;
  Object.defineProperty(notAcceptable_exception, "__esModule", { value: true });
  notAcceptable_exception.NotAcceptableException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class NotAcceptableException extends http_exception_1.HttpException {
    /**
     * Instantiate a `NotAcceptableException` Exception.
     *
     * @example
     * `throw new NotAcceptableException()`
     *
     * @usageNotes
     * The HTTP response status code will be 406.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 406.
     * - `error`: the string `'Not Acceptable'` by default; override this by supplying
     * a string in the `error` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Not Acceptable") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.NOT_ACCEPTABLE), http_status_enum_1.HttpStatus.NOT_ACCEPTABLE, httpExceptionOptions);
    }
  }
  notAcceptable_exception.NotAcceptableException = NotAcceptableException;
  return notAcceptable_exception;
}
var requestTimeout_exception = {};
var hasRequiredRequestTimeout_exception;
function requireRequestTimeout_exception() {
  if (hasRequiredRequestTimeout_exception)
    return requestTimeout_exception;
  hasRequiredRequestTimeout_exception = 1;
  Object.defineProperty(requestTimeout_exception, "__esModule", { value: true });
  requestTimeout_exception.RequestTimeoutException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class RequestTimeoutException extends http_exception_1.HttpException {
    /**
     * Instantiate a `RequestTimeoutException` Exception.
     *
     * @example
     * `throw new RequestTimeoutException()`
     *
     * @usageNotes
     * The HTTP response status code will be 408.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 408.
     * - `message`: the string `'Request Timeout'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Request Timeout") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.REQUEST_TIMEOUT), http_status_enum_1.HttpStatus.REQUEST_TIMEOUT, httpExceptionOptions);
    }
  }
  requestTimeout_exception.RequestTimeoutException = RequestTimeoutException;
  return requestTimeout_exception;
}
var conflict_exception = {};
var hasRequiredConflict_exception;
function requireConflict_exception() {
  if (hasRequiredConflict_exception)
    return conflict_exception;
  hasRequiredConflict_exception = 1;
  Object.defineProperty(conflict_exception, "__esModule", { value: true });
  conflict_exception.ConflictException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class ConflictException extends http_exception_1.HttpException {
    /**
     * Instantiate a `ConflictException` Exception.
     *
     * @example
     * `throw new ConflictException()`
     *
     * @usageNotes
     * The HTTP response status code will be 409.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 409.
     * - `message`: the string `'Conflict'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Conflict") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.CONFLICT), http_status_enum_1.HttpStatus.CONFLICT, httpExceptionOptions);
    }
  }
  conflict_exception.ConflictException = ConflictException;
  return conflict_exception;
}
var gone_exception = {};
var hasRequiredGone_exception;
function requireGone_exception() {
  if (hasRequiredGone_exception)
    return gone_exception;
  hasRequiredGone_exception = 1;
  Object.defineProperty(gone_exception, "__esModule", { value: true });
  gone_exception.GoneException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class GoneException extends http_exception_1.HttpException {
    /**
     * Instantiate a `GoneException` Exception.
     *
     * @example
     * `throw new GoneException()`
     *
     * @usageNotes
     * The HTTP response status code will be 410.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 410.
     * - `message`: the string `'Gone'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Gone") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.GONE), http_status_enum_1.HttpStatus.GONE, httpExceptionOptions);
    }
  }
  gone_exception.GoneException = GoneException;
  return gone_exception;
}
var payloadTooLarge_exception = {};
var hasRequiredPayloadTooLarge_exception;
function requirePayloadTooLarge_exception() {
  if (hasRequiredPayloadTooLarge_exception)
    return payloadTooLarge_exception;
  hasRequiredPayloadTooLarge_exception = 1;
  Object.defineProperty(payloadTooLarge_exception, "__esModule", { value: true });
  payloadTooLarge_exception.PayloadTooLargeException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class PayloadTooLargeException extends http_exception_1.HttpException {
    /**
     * Instantiate a `PayloadTooLargeException` Exception.
     *
     * @example
     * `throw new PayloadTooLargeException()`
     *
     * @usageNotes
     * The HTTP response status code will be 413.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 413.
     * - `message`: the string `'Payload Too Large'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Payload Too Large") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.PAYLOAD_TOO_LARGE), http_status_enum_1.HttpStatus.PAYLOAD_TOO_LARGE, httpExceptionOptions);
    }
  }
  payloadTooLarge_exception.PayloadTooLargeException = PayloadTooLargeException;
  return payloadTooLarge_exception;
}
var unsupportedMediaType_exception = {};
var hasRequiredUnsupportedMediaType_exception;
function requireUnsupportedMediaType_exception() {
  if (hasRequiredUnsupportedMediaType_exception)
    return unsupportedMediaType_exception;
  hasRequiredUnsupportedMediaType_exception = 1;
  Object.defineProperty(unsupportedMediaType_exception, "__esModule", { value: true });
  unsupportedMediaType_exception.UnsupportedMediaTypeException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class UnsupportedMediaTypeException extends http_exception_1.HttpException {
    /**
     * Instantiate an `UnsupportedMediaTypeException` Exception.
     *
     * @example
     * `throw new UnsupportedMediaTypeException()`
     *
     * @usageNotes
     * The HTTP response status code will be 415.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 415.
     * - `message`: the string `'Unsupported Media Type'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Unsupported Media Type") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.UNSUPPORTED_MEDIA_TYPE), http_status_enum_1.HttpStatus.UNSUPPORTED_MEDIA_TYPE, httpExceptionOptions);
    }
  }
  unsupportedMediaType_exception.UnsupportedMediaTypeException = UnsupportedMediaTypeException;
  return unsupportedMediaType_exception;
}
var unprocessableEntity_exception = {};
var hasRequiredUnprocessableEntity_exception;
function requireUnprocessableEntity_exception() {
  if (hasRequiredUnprocessableEntity_exception)
    return unprocessableEntity_exception;
  hasRequiredUnprocessableEntity_exception = 1;
  Object.defineProperty(unprocessableEntity_exception, "__esModule", { value: true });
  unprocessableEntity_exception.UnprocessableEntityException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class UnprocessableEntityException extends http_exception_1.HttpException {
    /**
     * Instantiate an `UnprocessableEntityException` Exception.
     *
     * @example
     * `throw new UnprocessableEntityException()`
     *
     * @usageNotes
     * The HTTP response status code will be 422.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 422.
     * - `message`: the string `'Unprocessable Entity'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Unprocessable Entity") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.UNPROCESSABLE_ENTITY), http_status_enum_1.HttpStatus.UNPROCESSABLE_ENTITY, httpExceptionOptions);
    }
  }
  unprocessableEntity_exception.UnprocessableEntityException = UnprocessableEntityException;
  return unprocessableEntity_exception;
}
var internalServerError_exception = {};
var hasRequiredInternalServerError_exception;
function requireInternalServerError_exception() {
  if (hasRequiredInternalServerError_exception)
    return internalServerError_exception;
  hasRequiredInternalServerError_exception = 1;
  Object.defineProperty(internalServerError_exception, "__esModule", { value: true });
  internalServerError_exception.InternalServerErrorException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class InternalServerErrorException extends http_exception_1.HttpException {
    /**
     * Instantiate an `InternalServerErrorException` Exception.
     *
     * @example
     * `throw new InternalServerErrorException()`
     *
     * @usageNotes
     * The HTTP response status code will be 500.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 500.
     * - `message`: the string `'Internal Server Error'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Internal Server Error") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.INTERNAL_SERVER_ERROR), http_status_enum_1.HttpStatus.INTERNAL_SERVER_ERROR, httpExceptionOptions);
    }
  }
  internalServerError_exception.InternalServerErrorException = InternalServerErrorException;
  return internalServerError_exception;
}
var notImplemented_exception = {};
var hasRequiredNotImplemented_exception;
function requireNotImplemented_exception() {
  if (hasRequiredNotImplemented_exception)
    return notImplemented_exception;
  hasRequiredNotImplemented_exception = 1;
  Object.defineProperty(notImplemented_exception, "__esModule", { value: true });
  notImplemented_exception.NotImplementedException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class NotImplementedException extends http_exception_1.HttpException {
    /**
     * Instantiate a `NotImplementedException` Exception.
     *
     * @example
     * `throw new NotImplementedException()`
     *
     * @usageNotes
     * The HTTP response status code will be 501.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 501.
     * - `message`: the string `'Not Implemented'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     * @param error a short description of the HTTP error.
     */
    constructor(objectOrError, descriptionOrOptions = "Not Implemented") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.NOT_IMPLEMENTED), http_status_enum_1.HttpStatus.NOT_IMPLEMENTED, httpExceptionOptions);
    }
  }
  notImplemented_exception.NotImplementedException = NotImplementedException;
  return notImplemented_exception;
}
var httpVersionNotSupported_exception = {};
var hasRequiredHttpVersionNotSupported_exception;
function requireHttpVersionNotSupported_exception() {
  if (hasRequiredHttpVersionNotSupported_exception)
    return httpVersionNotSupported_exception;
  hasRequiredHttpVersionNotSupported_exception = 1;
  Object.defineProperty(httpVersionNotSupported_exception, "__esModule", { value: true });
  httpVersionNotSupported_exception.HttpVersionNotSupportedException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class HttpVersionNotSupportedException extends http_exception_1.HttpException {
    /**
     * Instantiate a `HttpVersionNotSupportedException` Exception.
     *
     * @example
     * `throw new HttpVersionNotSupportedException()`
     *
     * @usageNotes
     * The HTTP response status code will be 505.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 505.
     * - `message`: the string `'HTTP Version Not Supported'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "HTTP Version Not Supported") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.HTTP_VERSION_NOT_SUPPORTED), http_status_enum_1.HttpStatus.HTTP_VERSION_NOT_SUPPORTED, httpExceptionOptions);
    }
  }
  httpVersionNotSupported_exception.HttpVersionNotSupportedException = HttpVersionNotSupportedException;
  return httpVersionNotSupported_exception;
}
var badGateway_exception = {};
var hasRequiredBadGateway_exception;
function requireBadGateway_exception() {
  if (hasRequiredBadGateway_exception)
    return badGateway_exception;
  hasRequiredBadGateway_exception = 1;
  Object.defineProperty(badGateway_exception, "__esModule", { value: true });
  badGateway_exception.BadGatewayException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class BadGatewayException extends http_exception_1.HttpException {
    /**
     * Instantiate a `BadGatewayException` Exception.
     *
     * @example
     * `throw new BadGatewayException()`
     *
     * @usageNotes
     * The HTTP response status code will be 502.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 502.
     * - `message`: the string `'Bad Gateway'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Bad Gateway") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.BAD_GATEWAY), http_status_enum_1.HttpStatus.BAD_GATEWAY, httpExceptionOptions);
    }
  }
  badGateway_exception.BadGatewayException = BadGatewayException;
  return badGateway_exception;
}
var serviceUnavailable_exception = {};
var hasRequiredServiceUnavailable_exception;
function requireServiceUnavailable_exception() {
  if (hasRequiredServiceUnavailable_exception)
    return serviceUnavailable_exception;
  hasRequiredServiceUnavailable_exception = 1;
  Object.defineProperty(serviceUnavailable_exception, "__esModule", { value: true });
  serviceUnavailable_exception.ServiceUnavailableException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class ServiceUnavailableException extends http_exception_1.HttpException {
    /**
     * Instantiate a `ServiceUnavailableException` Exception.
     *
     * @example
     * `throw new ServiceUnavailableException()`
     *
     * @usageNotes
     * The HTTP response status code will be 503.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 503.
     * - `message`: the string `'Service Unavailable'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Service Unavailable") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.SERVICE_UNAVAILABLE), http_status_enum_1.HttpStatus.SERVICE_UNAVAILABLE, httpExceptionOptions);
    }
  }
  serviceUnavailable_exception.ServiceUnavailableException = ServiceUnavailableException;
  return serviceUnavailable_exception;
}
var gatewayTimeout_exception = {};
var hasRequiredGatewayTimeout_exception;
function requireGatewayTimeout_exception() {
  if (hasRequiredGatewayTimeout_exception)
    return gatewayTimeout_exception;
  hasRequiredGatewayTimeout_exception = 1;
  Object.defineProperty(gatewayTimeout_exception, "__esModule", { value: true });
  gatewayTimeout_exception.GatewayTimeoutException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class GatewayTimeoutException extends http_exception_1.HttpException {
    /**
     * Instantiate a `GatewayTimeoutException` Exception.
     *
     * @example
     * `throw new GatewayTimeoutException()`
     *
     * @usageNotes
     * The HTTP response status code will be 504.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 504.
     * - `message`: the string `'Gateway Timeout'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Gateway Timeout") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.GATEWAY_TIMEOUT), http_status_enum_1.HttpStatus.GATEWAY_TIMEOUT, httpExceptionOptions);
    }
  }
  gatewayTimeout_exception.GatewayTimeoutException = GatewayTimeoutException;
  return gatewayTimeout_exception;
}
var imATeapot_exception = {};
var hasRequiredImATeapot_exception;
function requireImATeapot_exception() {
  if (hasRequiredImATeapot_exception)
    return imATeapot_exception;
  hasRequiredImATeapot_exception = 1;
  Object.defineProperty(imATeapot_exception, "__esModule", { value: true });
  imATeapot_exception.ImATeapotException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class ImATeapotException extends http_exception_1.HttpException {
    /**
     * Instantiate an `ImATeapotException` Exception.
     *
     * @example
     * `throw new ImATeapotException()`
     *
     * @usageNotes
     * The HTTP response status code will be 418.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 418.
     * - `message`: the string `"I'm a Teapot"` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = `I'm a teapot`) {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.I_AM_A_TEAPOT), http_status_enum_1.HttpStatus.I_AM_A_TEAPOT, httpExceptionOptions);
    }
  }
  imATeapot_exception.ImATeapotException = ImATeapotException;
  return imATeapot_exception;
}
var preconditionFailed_exception = {};
var hasRequiredPreconditionFailed_exception;
function requirePreconditionFailed_exception() {
  if (hasRequiredPreconditionFailed_exception)
    return preconditionFailed_exception;
  hasRequiredPreconditionFailed_exception = 1;
  Object.defineProperty(preconditionFailed_exception, "__esModule", { value: true });
  preconditionFailed_exception.PreconditionFailedException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class PreconditionFailedException extends http_exception_1.HttpException {
    /**
     * Instantiate a `PreconditionFailedException` Exception.
     *
     * @example
     * `throw new PreconditionFailedException()`
     *
     * @usageNotes
     * The HTTP response status code will be 412.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 412.
     * - `message`: the string `'Precondition Failed'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Precondition Failed") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.PRECONDITION_FAILED), http_status_enum_1.HttpStatus.PRECONDITION_FAILED, httpExceptionOptions);
    }
  }
  preconditionFailed_exception.PreconditionFailedException = PreconditionFailedException;
  return preconditionFailed_exception;
}
var misdirected_exception = {};
var hasRequiredMisdirected_exception;
function requireMisdirected_exception() {
  if (hasRequiredMisdirected_exception)
    return misdirected_exception;
  hasRequiredMisdirected_exception = 1;
  Object.defineProperty(misdirected_exception, "__esModule", { value: true });
  misdirected_exception.MisdirectedException = void 0;
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_exception_1 = requireHttp_exception();
  class MisdirectedException extends http_exception_1.HttpException {
    /**
     * Instantiate a `MisdirectedException` Exception.
     *
     * @example
     * `throw new MisdirectedException()`
     *
     * @usageNotes
     * The HTTP response status code will be 421.
     * - The `objectOrError` argument defines the JSON response body or the message string.
     * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
     *
     * By default, the JSON response body contains two properties:
     * - `statusCode`: this will be the value 421.
     * - `message`: the string `'Bad Gateway'` by default; override this by supplying
     * a string in the `objectOrError` parameter.
     *
     * If the parameter `objectOrError` is a string, the response body will contain an
     * additional property, `error`, with a short description of the HTTP error. To override the
     * entire JSON response body, pass an object instead. Nest will serialize the object
     * and return it as the JSON response body.
     *
     * @param objectOrError string or object describing the error condition.
     * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
     */
    constructor(objectOrError, descriptionOrOptions = "Misdirected") {
      const { description: description2, httpExceptionOptions } = http_exception_1.HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);
      super(http_exception_1.HttpException.createBody(objectOrError, description2, http_status_enum_1.HttpStatus.MISDIRECTED), http_status_enum_1.HttpStatus.MISDIRECTED, httpExceptionOptions);
    }
  }
  misdirected_exception.MisdirectedException = MisdirectedException;
  return misdirected_exception;
}
var hasRequiredExceptions$2;
function requireExceptions$2() {
  if (hasRequiredExceptions$2)
    return exceptions$2;
  hasRequiredExceptions$2 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireBadRequest_exception(), exports2);
    tslib_1.__exportStar(requireHttp_exception(), exports2);
    tslib_1.__exportStar(requireUnauthorized_exception(), exports2);
    tslib_1.__exportStar(requireMethodNotAllowed_exception(), exports2);
    tslib_1.__exportStar(requireNotFound_exception(), exports2);
    tslib_1.__exportStar(requireForbidden_exception(), exports2);
    tslib_1.__exportStar(requireNotAcceptable_exception(), exports2);
    tslib_1.__exportStar(requireRequestTimeout_exception(), exports2);
    tslib_1.__exportStar(requireConflict_exception(), exports2);
    tslib_1.__exportStar(requireGone_exception(), exports2);
    tslib_1.__exportStar(requirePayloadTooLarge_exception(), exports2);
    tslib_1.__exportStar(requireUnsupportedMediaType_exception(), exports2);
    tslib_1.__exportStar(requireUnprocessableEntity_exception(), exports2);
    tslib_1.__exportStar(requireInternalServerError_exception(), exports2);
    tslib_1.__exportStar(requireNotImplemented_exception(), exports2);
    tslib_1.__exportStar(requireHttpVersionNotSupported_exception(), exports2);
    tslib_1.__exportStar(requireBadGateway_exception(), exports2);
    tslib_1.__exportStar(requireServiceUnavailable_exception(), exports2);
    tslib_1.__exportStar(requireGatewayTimeout_exception(), exports2);
    tslib_1.__exportStar(requireImATeapot_exception(), exports2);
    tslib_1.__exportStar(requirePreconditionFailed_exception(), exports2);
    tslib_1.__exportStar(requireMisdirected_exception(), exports2);
  })(exceptions$2);
  return exceptions$2;
}
var interfaces$3 = {};
var abstract_interface = {};
var hasRequiredAbstract_interface;
function requireAbstract_interface() {
  if (hasRequiredAbstract_interface)
    return abstract_interface;
  hasRequiredAbstract_interface = 1;
  Object.defineProperty(abstract_interface, "__esModule", { value: true });
  return abstract_interface;
}
var controllerMetadata_interface = {};
var hasRequiredControllerMetadata_interface;
function requireControllerMetadata_interface() {
  if (hasRequiredControllerMetadata_interface)
    return controllerMetadata_interface;
  hasRequiredControllerMetadata_interface = 1;
  Object.defineProperty(controllerMetadata_interface, "__esModule", { value: true });
  return controllerMetadata_interface;
}
var controller_interface = {};
var hasRequiredController_interface;
function requireController_interface() {
  if (hasRequiredController_interface)
    return controller_interface;
  hasRequiredController_interface = 1;
  Object.defineProperty(controller_interface, "__esModule", { value: true });
  return controller_interface;
}
var exceptionFilter_interface = {};
var hasRequiredExceptionFilter_interface;
function requireExceptionFilter_interface() {
  if (hasRequiredExceptionFilter_interface)
    return exceptionFilter_interface;
  hasRequiredExceptionFilter_interface = 1;
  Object.defineProperty(exceptionFilter_interface, "__esModule", { value: true });
  return exceptionFilter_interface;
}
var rpcExceptionFilter_interface = {};
var hasRequiredRpcExceptionFilter_interface;
function requireRpcExceptionFilter_interface() {
  if (hasRequiredRpcExceptionFilter_interface)
    return rpcExceptionFilter_interface;
  hasRequiredRpcExceptionFilter_interface = 1;
  Object.defineProperty(rpcExceptionFilter_interface, "__esModule", { value: true });
  return rpcExceptionFilter_interface;
}
var wsExceptionFilter_interface = {};
var hasRequiredWsExceptionFilter_interface;
function requireWsExceptionFilter_interface() {
  if (hasRequiredWsExceptionFilter_interface)
    return wsExceptionFilter_interface;
  hasRequiredWsExceptionFilter_interface = 1;
  Object.defineProperty(wsExceptionFilter_interface, "__esModule", { value: true });
  return wsExceptionFilter_interface;
}
var validationError_interface = {};
var hasRequiredValidationError_interface;
function requireValidationError_interface() {
  if (hasRequiredValidationError_interface)
    return validationError_interface;
  hasRequiredValidationError_interface = 1;
  Object.defineProperty(validationError_interface, "__esModule", { value: true });
  return validationError_interface;
}
var argumentsHost_interface = {};
var hasRequiredArgumentsHost_interface;
function requireArgumentsHost_interface() {
  if (hasRequiredArgumentsHost_interface)
    return argumentsHost_interface;
  hasRequiredArgumentsHost_interface = 1;
  Object.defineProperty(argumentsHost_interface, "__esModule", { value: true });
  return argumentsHost_interface;
}
var canActivate_interface = {};
var hasRequiredCanActivate_interface;
function requireCanActivate_interface() {
  if (hasRequiredCanActivate_interface)
    return canActivate_interface;
  hasRequiredCanActivate_interface = 1;
  Object.defineProperty(canActivate_interface, "__esModule", { value: true });
  return canActivate_interface;
}
var customRouteParamFactory_interface = {};
var hasRequiredCustomRouteParamFactory_interface;
function requireCustomRouteParamFactory_interface() {
  if (hasRequiredCustomRouteParamFactory_interface)
    return customRouteParamFactory_interface;
  hasRequiredCustomRouteParamFactory_interface = 1;
  Object.defineProperty(customRouteParamFactory_interface, "__esModule", { value: true });
  return customRouteParamFactory_interface;
}
var executionContext_interface = {};
var hasRequiredExecutionContext_interface;
function requireExecutionContext_interface() {
  if (hasRequiredExecutionContext_interface)
    return executionContext_interface;
  hasRequiredExecutionContext_interface = 1;
  Object.defineProperty(executionContext_interface, "__esModule", { value: true });
  return executionContext_interface;
}
var nestInterceptor_interface = {};
var hasRequiredNestInterceptor_interface;
function requireNestInterceptor_interface() {
  if (hasRequiredNestInterceptor_interface)
    return nestInterceptor_interface;
  hasRequiredNestInterceptor_interface = 1;
  Object.defineProperty(nestInterceptor_interface, "__esModule", { value: true });
  return nestInterceptor_interface;
}
var paramtype_interface = {};
var hasRequiredParamtype_interface;
function requireParamtype_interface() {
  if (hasRequiredParamtype_interface)
    return paramtype_interface;
  hasRequiredParamtype_interface = 1;
  Object.defineProperty(paramtype_interface, "__esModule", { value: true });
  return paramtype_interface;
}
var pipeTransform_interface = {};
var hasRequiredPipeTransform_interface;
function requirePipeTransform_interface() {
  if (hasRequiredPipeTransform_interface)
    return pipeTransform_interface;
  hasRequiredPipeTransform_interface = 1;
  Object.defineProperty(pipeTransform_interface, "__esModule", { value: true });
  return pipeTransform_interface;
}
var globalPrefixOptions_interface = {};
var hasRequiredGlobalPrefixOptions_interface;
function requireGlobalPrefixOptions_interface() {
  if (hasRequiredGlobalPrefixOptions_interface)
    return globalPrefixOptions_interface;
  hasRequiredGlobalPrefixOptions_interface = 1;
  Object.defineProperty(globalPrefixOptions_interface, "__esModule", { value: true });
  return globalPrefixOptions_interface;
}
var hooks$1 = {};
var beforeApplicationShutdown_interface = {};
var hasRequiredBeforeApplicationShutdown_interface;
function requireBeforeApplicationShutdown_interface() {
  if (hasRequiredBeforeApplicationShutdown_interface)
    return beforeApplicationShutdown_interface;
  hasRequiredBeforeApplicationShutdown_interface = 1;
  Object.defineProperty(beforeApplicationShutdown_interface, "__esModule", { value: true });
  return beforeApplicationShutdown_interface;
}
var onApplicationBootstrap_interface = {};
var hasRequiredOnApplicationBootstrap_interface;
function requireOnApplicationBootstrap_interface() {
  if (hasRequiredOnApplicationBootstrap_interface)
    return onApplicationBootstrap_interface;
  hasRequiredOnApplicationBootstrap_interface = 1;
  Object.defineProperty(onApplicationBootstrap_interface, "__esModule", { value: true });
  return onApplicationBootstrap_interface;
}
var onApplicationShutdown_interface = {};
var hasRequiredOnApplicationShutdown_interface;
function requireOnApplicationShutdown_interface() {
  if (hasRequiredOnApplicationShutdown_interface)
    return onApplicationShutdown_interface;
  hasRequiredOnApplicationShutdown_interface = 1;
  Object.defineProperty(onApplicationShutdown_interface, "__esModule", { value: true });
  return onApplicationShutdown_interface;
}
var onDestroy_interface = {};
var hasRequiredOnDestroy_interface;
function requireOnDestroy_interface() {
  if (hasRequiredOnDestroy_interface)
    return onDestroy_interface;
  hasRequiredOnDestroy_interface = 1;
  Object.defineProperty(onDestroy_interface, "__esModule", { value: true });
  return onDestroy_interface;
}
var onInit_interface = {};
var hasRequiredOnInit_interface;
function requireOnInit_interface() {
  if (hasRequiredOnInit_interface)
    return onInit_interface;
  hasRequiredOnInit_interface = 1;
  Object.defineProperty(onInit_interface, "__esModule", { value: true });
  return onInit_interface;
}
var hasRequiredHooks$1;
function requireHooks$1() {
  if (hasRequiredHooks$1)
    return hooks$1;
  hasRequiredHooks$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireBeforeApplicationShutdown_interface(), exports2);
    tslib_1.__exportStar(requireOnApplicationBootstrap_interface(), exports2);
    tslib_1.__exportStar(requireOnApplicationShutdown_interface(), exports2);
    tslib_1.__exportStar(requireOnDestroy_interface(), exports2);
    tslib_1.__exportStar(requireOnInit_interface(), exports2);
  })(hooks$1);
  return hooks$1;
}
var http$3 = {};
var httpServer_interface = {};
var hasRequiredHttpServer_interface;
function requireHttpServer_interface() {
  if (hasRequiredHttpServer_interface)
    return httpServer_interface;
  hasRequiredHttpServer_interface = 1;
  Object.defineProperty(httpServer_interface, "__esModule", { value: true });
  return httpServer_interface;
}
var messageEvent_interface = {};
var hasRequiredMessageEvent_interface;
function requireMessageEvent_interface() {
  if (hasRequiredMessageEvent_interface)
    return messageEvent_interface;
  hasRequiredMessageEvent_interface = 1;
  Object.defineProperty(messageEvent_interface, "__esModule", { value: true });
  return messageEvent_interface;
}
var rawBodyRequest_interface = {};
var hasRequiredRawBodyRequest_interface;
function requireRawBodyRequest_interface() {
  if (hasRequiredRawBodyRequest_interface)
    return rawBodyRequest_interface;
  hasRequiredRawBodyRequest_interface = 1;
  Object.defineProperty(rawBodyRequest_interface, "__esModule", { value: true });
  return rawBodyRequest_interface;
}
var hasRequiredHttp;
function requireHttp() {
  if (hasRequiredHttp)
    return http$3;
  hasRequiredHttp = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireHttpServer_interface(), exports2);
    tslib_1.__exportStar(requireMessageEvent_interface(), exports2);
    tslib_1.__exportStar(requireRawBodyRequest_interface(), exports2);
  })(http$3);
  return http$3;
}
var injectable_interface = {};
var hasRequiredInjectable_interface;
function requireInjectable_interface() {
  if (hasRequiredInjectable_interface)
    return injectable_interface;
  hasRequiredInjectable_interface = 1;
  Object.defineProperty(injectable_interface, "__esModule", { value: true });
  return injectable_interface;
}
var nestHybridApplicationOptions_interface = {};
var hasRequiredNestHybridApplicationOptions_interface;
function requireNestHybridApplicationOptions_interface() {
  if (hasRequiredNestHybridApplicationOptions_interface)
    return nestHybridApplicationOptions_interface;
  hasRequiredNestHybridApplicationOptions_interface = 1;
  Object.defineProperty(nestHybridApplicationOptions_interface, "__esModule", { value: true });
  return nestHybridApplicationOptions_interface;
}
var middleware$1 = {};
var middlewareConfigProxy_interface = {};
var hasRequiredMiddlewareConfigProxy_interface;
function requireMiddlewareConfigProxy_interface() {
  if (hasRequiredMiddlewareConfigProxy_interface)
    return middlewareConfigProxy_interface;
  hasRequiredMiddlewareConfigProxy_interface = 1;
  Object.defineProperty(middlewareConfigProxy_interface, "__esModule", { value: true });
  return middlewareConfigProxy_interface;
}
var middlewareConfiguration_interface = {};
var hasRequiredMiddlewareConfiguration_interface;
function requireMiddlewareConfiguration_interface() {
  if (hasRequiredMiddlewareConfiguration_interface)
    return middlewareConfiguration_interface;
  hasRequiredMiddlewareConfiguration_interface = 1;
  Object.defineProperty(middlewareConfiguration_interface, "__esModule", { value: true });
  return middlewareConfiguration_interface;
}
var middlewareConsumer_interface = {};
var hasRequiredMiddlewareConsumer_interface;
function requireMiddlewareConsumer_interface() {
  if (hasRequiredMiddlewareConsumer_interface)
    return middlewareConsumer_interface;
  hasRequiredMiddlewareConsumer_interface = 1;
  Object.defineProperty(middlewareConsumer_interface, "__esModule", { value: true });
  return middlewareConsumer_interface;
}
var nestMiddleware_interface = {};
var hasRequiredNestMiddleware_interface;
function requireNestMiddleware_interface() {
  if (hasRequiredNestMiddleware_interface)
    return nestMiddleware_interface;
  hasRequiredNestMiddleware_interface = 1;
  Object.defineProperty(nestMiddleware_interface, "__esModule", { value: true });
  return nestMiddleware_interface;
}
var hasRequiredMiddleware$1;
function requireMiddleware$1() {
  if (hasRequiredMiddleware$1)
    return middleware$1;
  hasRequiredMiddleware$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireMiddlewareConfigProxy_interface(), exports2);
    tslib_1.__exportStar(requireMiddlewareConfiguration_interface(), exports2);
    tslib_1.__exportStar(requireMiddlewareConsumer_interface(), exports2);
    tslib_1.__exportStar(requireNestMiddleware_interface(), exports2);
  })(middleware$1);
  return middleware$1;
}
var modules = {};
var dynamicModule_interface = {};
var hasRequiredDynamicModule_interface;
function requireDynamicModule_interface() {
  if (hasRequiredDynamicModule_interface)
    return dynamicModule_interface;
  hasRequiredDynamicModule_interface = 1;
  Object.defineProperty(dynamicModule_interface, "__esModule", { value: true });
  return dynamicModule_interface;
}
var forwardReference_interface = {};
var hasRequiredForwardReference_interface;
function requireForwardReference_interface() {
  if (hasRequiredForwardReference_interface)
    return forwardReference_interface;
  hasRequiredForwardReference_interface = 1;
  Object.defineProperty(forwardReference_interface, "__esModule", { value: true });
  return forwardReference_interface;
}
var injectionToken_interface = {};
var hasRequiredInjectionToken_interface;
function requireInjectionToken_interface() {
  if (hasRequiredInjectionToken_interface)
    return injectionToken_interface;
  hasRequiredInjectionToken_interface = 1;
  Object.defineProperty(injectionToken_interface, "__esModule", { value: true });
  return injectionToken_interface;
}
var introspectionResult_interface = {};
var hasRequiredIntrospectionResult_interface;
function requireIntrospectionResult_interface() {
  if (hasRequiredIntrospectionResult_interface)
    return introspectionResult_interface;
  hasRequiredIntrospectionResult_interface = 1;
  Object.defineProperty(introspectionResult_interface, "__esModule", { value: true });
  return introspectionResult_interface;
}
var moduleMetadata_interface = {};
var hasRequiredModuleMetadata_interface;
function requireModuleMetadata_interface() {
  if (hasRequiredModuleMetadata_interface)
    return moduleMetadata_interface;
  hasRequiredModuleMetadata_interface = 1;
  Object.defineProperty(moduleMetadata_interface, "__esModule", { value: true });
  return moduleMetadata_interface;
}
var nestModule_interface = {};
var hasRequiredNestModule_interface;
function requireNestModule_interface() {
  if (hasRequiredNestModule_interface)
    return nestModule_interface;
  hasRequiredNestModule_interface = 1;
  Object.defineProperty(nestModule_interface, "__esModule", { value: true });
  return nestModule_interface;
}
var optionalFactoryDependency_interface = {};
var hasRequiredOptionalFactoryDependency_interface;
function requireOptionalFactoryDependency_interface() {
  if (hasRequiredOptionalFactoryDependency_interface)
    return optionalFactoryDependency_interface;
  hasRequiredOptionalFactoryDependency_interface = 1;
  Object.defineProperty(optionalFactoryDependency_interface, "__esModule", { value: true });
  return optionalFactoryDependency_interface;
}
var provider_interface = {};
var hasRequiredProvider_interface;
function requireProvider_interface() {
  if (hasRequiredProvider_interface)
    return provider_interface;
  hasRequiredProvider_interface = 1;
  Object.defineProperty(provider_interface, "__esModule", { value: true });
  return provider_interface;
}
var hasRequiredModules;
function requireModules() {
  if (hasRequiredModules)
    return modules;
  hasRequiredModules = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireDynamicModule_interface(), exports2);
    tslib_1.__exportStar(requireForwardReference_interface(), exports2);
    tslib_1.__exportStar(requireInjectionToken_interface(), exports2);
    tslib_1.__exportStar(requireIntrospectionResult_interface(), exports2);
    tslib_1.__exportStar(requireModuleMetadata_interface(), exports2);
    tslib_1.__exportStar(requireNestModule_interface(), exports2);
    tslib_1.__exportStar(requireOptionalFactoryDependency_interface(), exports2);
    tslib_1.__exportStar(requireProvider_interface(), exports2);
  })(modules);
  return modules;
}
var nestApplicationContext_interface = {};
var hasRequiredNestApplicationContext_interface;
function requireNestApplicationContext_interface() {
  if (hasRequiredNestApplicationContext_interface)
    return nestApplicationContext_interface;
  hasRequiredNestApplicationContext_interface = 1;
  Object.defineProperty(nestApplicationContext_interface, "__esModule", { value: true });
  return nestApplicationContext_interface;
}
var nestApplicationOptions_interface = {};
var hasRequiredNestApplicationOptions_interface;
function requireNestApplicationOptions_interface() {
  if (hasRequiredNestApplicationOptions_interface)
    return nestApplicationOptions_interface;
  hasRequiredNestApplicationOptions_interface = 1;
  Object.defineProperty(nestApplicationOptions_interface, "__esModule", { value: true });
  return nestApplicationOptions_interface;
}
var nestApplication_interface = {};
var hasRequiredNestApplication_interface;
function requireNestApplication_interface() {
  if (hasRequiredNestApplication_interface)
    return nestApplication_interface;
  hasRequiredNestApplication_interface = 1;
  Object.defineProperty(nestApplication_interface, "__esModule", { value: true });
  return nestApplication_interface;
}
var nestMicroservice_interface = {};
var hasRequiredNestMicroservice_interface;
function requireNestMicroservice_interface() {
  if (hasRequiredNestMicroservice_interface)
    return nestMicroservice_interface;
  hasRequiredNestMicroservice_interface = 1;
  Object.defineProperty(nestMicroservice_interface, "__esModule", { value: true });
  return nestMicroservice_interface;
}
var scopeOptions_interface = {};
var hasRequiredScopeOptions_interface;
function requireScopeOptions_interface() {
  if (hasRequiredScopeOptions_interface)
    return scopeOptions_interface;
  hasRequiredScopeOptions_interface = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Scope = void 0;
    (function(Scope) {
      Scope[Scope["DEFAULT"] = 0] = "DEFAULT";
      Scope[Scope["TRANSIENT"] = 1] = "TRANSIENT";
      Scope[Scope["REQUEST"] = 2] = "REQUEST";
    })(exports2.Scope || (exports2.Scope = {}));
  })(scopeOptions_interface);
  return scopeOptions_interface;
}
var type_interface = {};
var hasRequiredType_interface;
function requireType_interface() {
  if (hasRequiredType_interface)
    return type_interface;
  hasRequiredType_interface = 1;
  Object.defineProperty(type_interface, "__esModule", { value: true });
  return type_interface;
}
var versionOptions_interface = {};
var hasRequiredVersionOptions_interface;
function requireVersionOptions_interface() {
  if (hasRequiredVersionOptions_interface)
    return versionOptions_interface;
  hasRequiredVersionOptions_interface = 1;
  Object.defineProperty(versionOptions_interface, "__esModule", { value: true });
  versionOptions_interface.VERSION_NEUTRAL = void 0;
  versionOptions_interface.VERSION_NEUTRAL = Symbol("VERSION_NEUTRAL");
  return versionOptions_interface;
}
var webSocketAdapter_interface = {};
var hasRequiredWebSocketAdapter_interface;
function requireWebSocketAdapter_interface() {
  if (hasRequiredWebSocketAdapter_interface)
    return webSocketAdapter_interface;
  hasRequiredWebSocketAdapter_interface = 1;
  Object.defineProperty(webSocketAdapter_interface, "__esModule", { value: true });
  return webSocketAdapter_interface;
}
var hasRequiredInterfaces$3;
function requireInterfaces$3() {
  if (hasRequiredInterfaces$3)
    return interfaces$3;
  hasRequiredInterfaces$3 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireAbstract_interface(), exports2);
    tslib_1.__exportStar(requireControllerMetadata_interface(), exports2);
    tslib_1.__exportStar(requireController_interface(), exports2);
    tslib_1.__exportStar(requireExceptionFilter_interface(), exports2);
    tslib_1.__exportStar(requireRpcExceptionFilter_interface(), exports2);
    tslib_1.__exportStar(requireWsExceptionFilter_interface(), exports2);
    tslib_1.__exportStar(requireValidationError_interface(), exports2);
    tslib_1.__exportStar(requireArgumentsHost_interface(), exports2);
    tslib_1.__exportStar(requireCanActivate_interface(), exports2);
    tslib_1.__exportStar(requireCustomRouteParamFactory_interface(), exports2);
    tslib_1.__exportStar(requireExecutionContext_interface(), exports2);
    tslib_1.__exportStar(requireNestInterceptor_interface(), exports2);
    tslib_1.__exportStar(requireParamtype_interface(), exports2);
    tslib_1.__exportStar(requirePipeTransform_interface(), exports2);
    tslib_1.__exportStar(requireGlobalPrefixOptions_interface(), exports2);
    tslib_1.__exportStar(requireHooks$1(), exports2);
    tslib_1.__exportStar(requireHttp(), exports2);
    tslib_1.__exportStar(requireInjectable_interface(), exports2);
    tslib_1.__exportStar(requireNestHybridApplicationOptions_interface(), exports2);
    tslib_1.__exportStar(requireMiddleware$1(), exports2);
    tslib_1.__exportStar(requireModules(), exports2);
    tslib_1.__exportStar(requireNestApplicationContext_interface(), exports2);
    tslib_1.__exportStar(requireNestApplicationOptions_interface(), exports2);
    tslib_1.__exportStar(requireNestApplication_interface(), exports2);
    tslib_1.__exportStar(requireNestMicroservice_interface(), exports2);
    tslib_1.__exportStar(requireScopeOptions_interface(), exports2);
    tslib_1.__exportStar(requireType_interface(), exports2);
    tslib_1.__exportStar(requireVersionOptions_interface(), exports2);
    tslib_1.__exportStar(requireWebSocketAdapter_interface(), exports2);
  })(interfaces$3);
  return interfaces$3;
}
var pipes$1 = {};
var defaultValue_pipe = {};
var hasRequiredDefaultValue_pipe;
function requireDefaultValue_pipe() {
  if (hasRequiredDefaultValue_pipe)
    return defaultValue_pipe;
  hasRequiredDefaultValue_pipe = 1;
  Object.defineProperty(defaultValue_pipe, "__esModule", { value: true });
  defaultValue_pipe.DefaultValuePipe = void 0;
  const tslib_1 = require$$0$3;
  const injectable_decorator_1 = requireInjectable_decorator();
  const shared_utils_1 = requireShared_utils();
  let DefaultValuePipe = class DefaultValuePipe {
    constructor(defaultValue) {
      this.defaultValue = defaultValue;
    }
    transform(value, _metadata) {
      if ((0, shared_utils_1.isNil)(value) || (0, shared_utils_1.isNumber)(value) && isNaN(value)) {
        return this.defaultValue;
      }
      return value;
    }
  };
  DefaultValuePipe = tslib_1.__decorate([
    (0, injectable_decorator_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [Object])
  ], DefaultValuePipe);
  defaultValue_pipe.DefaultValuePipe = DefaultValuePipe;
  return defaultValue_pipe;
}
var parseArray_pipe = {};
var httpErrorByCode_util = {};
var hasRequiredHttpErrorByCode_util;
function requireHttpErrorByCode_util() {
  if (hasRequiredHttpErrorByCode_util)
    return httpErrorByCode_util;
  hasRequiredHttpErrorByCode_util = 1;
  Object.defineProperty(httpErrorByCode_util, "__esModule", { value: true });
  httpErrorByCode_util.HttpErrorByCode = void 0;
  const enums_1 = requireEnums();
  const exceptions_1 = requireExceptions$2();
  httpErrorByCode_util.HttpErrorByCode = {
    [enums_1.HttpStatus.BAD_GATEWAY]: exceptions_1.BadGatewayException,
    [enums_1.HttpStatus.BAD_REQUEST]: exceptions_1.BadRequestException,
    [enums_1.HttpStatus.CONFLICT]: exceptions_1.ConflictException,
    [enums_1.HttpStatus.FORBIDDEN]: exceptions_1.ForbiddenException,
    [enums_1.HttpStatus.GATEWAY_TIMEOUT]: exceptions_1.GatewayTimeoutException,
    [enums_1.HttpStatus.GONE]: exceptions_1.GoneException,
    [enums_1.HttpStatus.I_AM_A_TEAPOT]: exceptions_1.ImATeapotException,
    [enums_1.HttpStatus.INTERNAL_SERVER_ERROR]: exceptions_1.InternalServerErrorException,
    [enums_1.HttpStatus.METHOD_NOT_ALLOWED]: exceptions_1.MethodNotAllowedException,
    [enums_1.HttpStatus.NOT_ACCEPTABLE]: exceptions_1.NotAcceptableException,
    [enums_1.HttpStatus.NOT_FOUND]: exceptions_1.NotFoundException,
    [enums_1.HttpStatus.NOT_IMPLEMENTED]: exceptions_1.NotImplementedException,
    [enums_1.HttpStatus.PAYLOAD_TOO_LARGE]: exceptions_1.PayloadTooLargeException,
    [enums_1.HttpStatus.PRECONDITION_FAILED]: exceptions_1.PreconditionFailedException,
    [enums_1.HttpStatus.REQUEST_TIMEOUT]: exceptions_1.RequestTimeoutException,
    [enums_1.HttpStatus.SERVICE_UNAVAILABLE]: exceptions_1.ServiceUnavailableException,
    [enums_1.HttpStatus.UNAUTHORIZED]: exceptions_1.UnauthorizedException,
    [enums_1.HttpStatus.UNPROCESSABLE_ENTITY]: exceptions_1.UnprocessableEntityException,
    [enums_1.HttpStatus.UNSUPPORTED_MEDIA_TYPE]: exceptions_1.UnsupportedMediaTypeException
  };
  return httpErrorByCode_util;
}
var validation_pipe = {};
var lib$4 = {};
var iterate$3 = {};
var concat = {};
var hasRequiredConcat;
function requireConcat() {
  if (hasRequiredConcat)
    return concat;
  hasRequiredConcat = 1;
  Object.defineProperty(concat, "__esModule", { value: true });
  class ConcatIterator {
    constructor(toConcat) {
      this.toConcat = toConcat;
    }
    next() {
      if (this.toConcat.length === 0) {
        return { done: true };
      }
      const result = this.toConcat[0].next();
      if (!result.done) {
        return result;
      }
      this.toConcat.shift();
      return this.next();
    }
  }
  concat.ConcatIterator = ConcatIterator;
  return concat;
}
var filter = {};
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter)
    return filter;
  hasRequiredFilter = 1;
  Object.defineProperty(filter, "__esModule", { value: true });
  class FilterIterator {
    constructor(source2, predicate) {
      this.source = source2;
      this.predicate = predicate;
    }
    next() {
      let result;
      do {
        result = this.source.next();
      } while (!result.done && !this.predicate(result.value));
      return result;
    }
  }
  filter.FilterIterator = FilterIterator;
  return filter;
}
var flatten = {};
var utils$a = {};
var hasRequiredUtils$6;
function requireUtils$6() {
  if (hasRequiredUtils$6)
    return utils$a;
  hasRequiredUtils$6 = 1;
  Object.defineProperty(utils$a, "__esModule", { value: true });
  function isIterator(candidate) {
    return typeof candidate === "object" && candidate !== null && typeof candidate.next === "function";
  }
  utils$a.isIterator = isIterator;
  function isIterable2(candidate) {
    return typeof candidate === "object" && candidate !== null && typeof candidate[Symbol.iterator] === "function";
  }
  utils$a.isIterable = isIterable2;
  function toIterator(collection) {
    if (isIterator(collection)) {
      return collection;
    }
    if (isIterable2(collection)) {
      return collection[Symbol.iterator]();
    }
    throw new Error("Passed collection is neither an Iterator nor an Iterable");
  }
  utils$a.toIterator = toIterator;
  return utils$a;
}
var hasRequiredFlatten;
function requireFlatten() {
  if (hasRequiredFlatten)
    return flatten;
  hasRequiredFlatten = 1;
  Object.defineProperty(flatten, "__esModule", { value: true });
  const utils_12 = requireUtils$6();
  class FlattenIterator {
    constructor(outer) {
      this.outer = outer;
    }
    next() {
      if (this.inner) {
        const result = this.inner.next();
        if (!result.done) {
          return result;
        }
        this.inner = void 0;
      }
      const { value, done } = this.outer.next();
      if (utils_12.isIterable(value)) {
        this.inner = value[Symbol.iterator]();
        return this.next();
      }
      return { value, done };
    }
  }
  flatten.FlattenIterator = FlattenIterator;
  return flatten;
}
var map = {};
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap)
    return map;
  hasRequiredMap = 1;
  Object.defineProperty(map, "__esModule", { value: true });
  class MapIterator {
    constructor(source2, iteratee) {
      this.source = source2;
      this.iteratee = iteratee;
    }
    next() {
      const { value, done } = this.source.next();
      return { value: !done && this.iteratee(value), done };
    }
  }
  map.MapIterator = MapIterator;
  return map;
}
var slice = {};
var hasRequiredSlice;
function requireSlice() {
  if (hasRequiredSlice)
    return slice;
  hasRequiredSlice = 1;
  Object.defineProperty(slice, "__esModule", { value: true });
  class SliceIterator {
    /**
     * @param {Iterator<T>} source Source Iterator
     * @param {number} start Zero-based positive start index, inclusive
     * @param {number} end Zero-based positive end index, exclusive, defaults to end of iterator
     */
    constructor(source2, start, end = Infinity) {
      this.source = source2;
      this.start = start;
      this.end = end;
      this.i = 0;
    }
    next() {
      while (this.i < this.start) {
        const result = this.source.next();
        if (result.done) {
          return result;
        }
        this.i++;
      }
      this.i++;
      if (this.i >= this.end) {
        return { done: true };
      }
      return this.source.next();
    }
  }
  slice.SliceIterator = SliceIterator;
  return slice;
}
var zip = {};
var hasRequiredZip;
function requireZip() {
  if (hasRequiredZip)
    return zip;
  hasRequiredZip = 1;
  Object.defineProperty(zip, "__esModule", { value: true });
  class ZipIterator {
    constructor(a, b) {
      this.a = a;
      this.b = b;
    }
    next() {
      const a = this.a.next();
      if (a.done) {
        return { done: true };
      }
      const b = this.b.next();
      if (b.done) {
        return { done: true };
      }
      return { value: [a.value, b.value], done: false };
    }
  }
  zip.ZipIterator = ZipIterator;
  return zip;
}
var hasRequiredIterate;
function requireIterate() {
  if (hasRequiredIterate)
    return iterate$3;
  hasRequiredIterate = 1;
  Object.defineProperty(iterate$3, "__esModule", { value: true });
  const concat_1 = requireConcat();
  const filter_1 = requireFilter();
  const flatten_1 = requireFlatten();
  const map_1 = requireMap();
  const slice_1 = requireSlice();
  const utils_12 = requireUtils$6();
  const zip_1 = requireZip();
  class IteratorWithOperators {
    /**
     * @param source Iterator to wrap
     */
    constructor(source2) {
      this.source = source2;
    }
    /**
     * Returns a `{ value, done }` object that adheres to the Iterator protocol
     */
    next() {
      return this.source.next();
    }
    /**
     * The presence of this method makes the Iterator itself Iterable.
     * This makes it possible to pass it to `for of` and Iterable-accepting functions like `Array.from()`
     */
    [Symbol.iterator]() {
      return this;
    }
    /**
     * Returns a new Iterator by running each element thru iteratee
     */
    map(iteratee) {
      return new IteratorWithOperators(new map_1.MapIterator(this.source, iteratee));
    }
    filter(predicate) {
      return new IteratorWithOperators(new filter_1.FilterIterator(this.source, predicate));
    }
    /**
     * Returns a new Iterator concatenating the Iterator with an additional Iterator or Iterable
     */
    concat(collection) {
      return new IteratorWithOperators(new concat_1.ConcatIterator([this.source, utils_12.toIterator(collection)]));
    }
    /**
     * Returns a new Iterator that emits slice of the source with n elements taken from the beginning
     *
     * @param limit The number of elements to take.
     */
    take(limit2) {
      return new IteratorWithOperators(new slice_1.SliceIterator(this.source, 0, limit2 + 1));
    }
    /**
     * Returns a new Iterator that emits slice of the source with n elements dropped from the beginning
     *
     * @param n The number of elements to drop.
     */
    drop(n) {
      return new IteratorWithOperators(new slice_1.SliceIterator(this.source, n, Infinity));
    }
    /**
     * Returns a new Iterator that emits a slice of the source
     *
     * @param {number} start Zero-based positive start index, inclusive
     * @param {number} end Zero-based positive end index, exclusive, defaults to end of iterator
     */
    slice(start, end = Infinity) {
      return new IteratorWithOperators(new slice_1.SliceIterator(this.source, start, end));
    }
    /**
     * Returns a new Iterator that flattens items emitted by the Iterator a single level deep
     */
    flatten() {
      return new IteratorWithOperators(new flatten_1.FlattenIterator(this.source));
    }
    reduce(iteratee, accumulator) {
      let result;
      if (accumulator === void 0) {
        result = this.source.next();
        if (result.done) {
          throw new TypeError("Reduce of empty Iterator with no initial value");
        }
        accumulator = result.value;
      }
      while (true) {
        result = this.source.next();
        if (result.done) {
          break;
        }
        accumulator = iteratee(accumulator, result.value);
      }
      return accumulator;
    }
    find(predicate) {
      let result;
      while (true) {
        result = this.source.next();
        if (result.done) {
          return void 0;
        }
        if (predicate(result.value)) {
          return result.value;
        }
      }
    }
    /**
     * Iterates and checks if `value` is emitted by the Iterator
     *
     * @param value The value to search
     */
    includes(value) {
      let result;
      do {
        result = this.source.next();
        if (!result.done && result.value === value) {
          return true;
        }
      } while (!result.done);
      return false;
    }
    /**
     * Iterates and checks if `predicate` returns truthy for any element emitted by the Iterator
     */
    some(predicate) {
      let result;
      do {
        result = this.source.next();
        if (!result.done && predicate(result.value)) {
          return true;
        }
      } while (!result.done);
      return false;
    }
    /**
     * Iterates and checks if `predicate` returns truthy for all elements emitted by the Iterator
     */
    every(predicate) {
      let result;
      do {
        result = this.source.next();
        if (!result.done && !predicate(result.value)) {
          return false;
        }
      } while (!result.done);
      return true;
    }
    /**
     * Iterates and invokes `iteratee` for every element emitted by the Iterator
     */
    forEach(iteratee) {
      let result;
      while (true) {
        result = this.source.next();
        if (result.done) {
          break;
        }
        iteratee(result.value);
      }
    }
    /**
     * Iterates and joins all elements emitted by the Iterator together as a string separated by an optional separator
     */
    join(separator = ",") {
      let joined = "";
      let result;
      while (true) {
        result = this.source.next();
        if (result.done) {
          break;
        }
        joined += separator + result.value;
      }
      return joined.substr(separator.length);
    }
    /**
     * Iterates and returns all items emitted by the Iterator as an array.
     * Equivalent to passing the Iterator to `Array.from()`
     */
    toArray() {
      return Array.from(this);
    }
    /**
     * Iterates and returns all items emitted by the Iterator as an ES6 Set.
     * Equivalent to passing the Iterator to `new Set()`
     */
    toSet() {
      const set = /* @__PURE__ */ new Set();
      while (true) {
        const { value, done } = this.next();
        if (done) {
          return set;
        }
        set.add(value);
      }
    }
    /**
     * Iterates and returns all `[key, value]` paris emitted by the Iterator as an ES6 Map.
     * Equivalent to passing the Iterator to `new Map()`
     */
    toMap() {
      return new Map(this);
    }
  }
  iterate$3.IteratorWithOperators = IteratorWithOperators;
  function iterate2(collection) {
    return new IteratorWithOperators(utils_12.toIterator(collection));
  }
  iterate$3.iterate = iterate2;
  function zip2(a, b) {
    return new IteratorWithOperators(new zip_1.ZipIterator(utils_12.toIterator(a), utils_12.toIterator(b)));
  }
  iterate$3.zip = zip2;
  iterate$3.default = iterate2;
  return iterate$3;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4)
    return lib$4;
  hasRequiredLib$4 = 1;
  Object.defineProperty(lib$4, "__esModule", { value: true });
  const iterate_12 = requireIterate();
  lib$4.iterate = iterate_12.iterate;
  lib$4.zip = iterate_12.zip;
  lib$4.default = iterate_12.iterate;
  return lib$4;
}
const common$5 = {};
const common$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: common$5
}, Symbol.toStringTag, { value: "Module" }));
const require$$9$2 = /* @__PURE__ */ getAugmentedNamespace(common$6);
const common$3 = {};
const common$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: common$3
}, Symbol.toStringTag, { value: "Module" }));
const require$$7$1 = /* @__PURE__ */ getAugmentedNamespace(common$4);
var hasRequiredValidation_pipe;
function requireValidation_pipe() {
  if (hasRequiredValidation_pipe)
    return validation_pipe;
  hasRequiredValidation_pipe = 1;
  Object.defineProperty(validation_pipe, "__esModule", { value: true });
  validation_pipe.ValidationPipe = void 0;
  const tslib_1 = require$$0$3;
  const iterare_1 = requireLib$4();
  const util_12 = require$$1$1;
  const decorators_1 = requireDecorators$2();
  const core_12 = requireCore();
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_error_by_code_util_1 = requireHttpErrorByCode_util();
  const load_package_util_1 = requireLoadPackage_util();
  const shared_utils_1 = requireShared_utils();
  let classValidator = {};
  let classTransformer = {};
  let ValidationPipe = class ValidationPipe {
    constructor(options) {
      options = options || {};
      const { transform, disableErrorMessages, errorHttpStatusCode, expectedType, transformOptions, validateCustomDecorators } = options, validatorOptions = tslib_1.__rest(options, ["transform", "disableErrorMessages", "errorHttpStatusCode", "expectedType", "transformOptions", "validateCustomDecorators"]);
      this.validatorOptions = Object.assign({ forbidUnknownValues: false }, validatorOptions);
      this.isTransformEnabled = !!transform;
      this.transformOptions = transformOptions;
      this.isDetailedOutputDisabled = disableErrorMessages;
      this.validateCustomDecorators = validateCustomDecorators || false;
      this.errorHttpStatusCode = errorHttpStatusCode || http_status_enum_1.HttpStatus.BAD_REQUEST;
      this.expectedType = expectedType;
      this.exceptionFactory = options.exceptionFactory || this.createExceptionFactory();
      classValidator = this.loadValidator(options.validatorPackage);
      classTransformer = this.loadTransformer(options.transformerPackage);
    }
    loadValidator(validatorPackage) {
      return validatorPackage !== null && validatorPackage !== void 0 ? validatorPackage : (0, load_package_util_1.loadPackage)("class-validator", "ValidationPipe", () => require$$9$2);
    }
    loadTransformer(transformerPackage) {
      return transformerPackage !== null && transformerPackage !== void 0 ? transformerPackage : (0, load_package_util_1.loadPackage)("class-transformer", "ValidationPipe", () => require$$7$1);
    }
    async transform(value, metadata2) {
      if (this.expectedType) {
        metadata2 = Object.assign(Object.assign({}, metadata2), { metatype: this.expectedType });
      }
      const metatype = metadata2.metatype;
      if (!metatype || !this.toValidate(metadata2)) {
        return this.isTransformEnabled ? this.transformPrimitive(value, metadata2) : value;
      }
      const originalValue = value;
      value = this.toEmptyIfNil(value);
      const isNil = value !== originalValue;
      const isPrimitive = this.isPrimitive(value);
      this.stripProtoKeys(value);
      let entity = classTransformer.plainToClass(metatype, value, this.transformOptions);
      const originalEntity = entity;
      const isCtorNotEqual = entity.constructor !== metatype;
      if (isCtorNotEqual && !isPrimitive) {
        entity.constructor = metatype;
      } else if (isCtorNotEqual) {
        entity = { constructor: metatype };
      }
      const errors2 = await this.validate(entity, this.validatorOptions);
      if (errors2.length > 0) {
        throw await this.exceptionFactory(errors2);
      }
      if (isPrimitive) {
        entity = originalEntity;
      }
      if (this.isTransformEnabled) {
        return entity;
      }
      if (isNil) {
        return originalValue;
      }
      const shouldTransformToPlain = Object.keys(this.validatorOptions).length > 1;
      return shouldTransformToPlain ? classTransformer.classToPlain(entity, this.transformOptions) : value;
    }
    createExceptionFactory() {
      return (validationErrors = []) => {
        if (this.isDetailedOutputDisabled) {
          return new http_error_by_code_util_1.HttpErrorByCode[this.errorHttpStatusCode]();
        }
        const errors2 = this.flattenValidationErrors(validationErrors);
        return new http_error_by_code_util_1.HttpErrorByCode[this.errorHttpStatusCode](errors2);
      };
    }
    toValidate(metadata2) {
      const { metatype, type: type2 } = metadata2;
      if (type2 === "custom" && !this.validateCustomDecorators) {
        return false;
      }
      const types2 = [String, Boolean, Number, Array, Object, Buffer];
      return !types2.some((t2) => metatype === t2) && !(0, shared_utils_1.isNil)(metatype);
    }
    transformPrimitive(value, metadata2) {
      if (!metadata2.data) {
        return value;
      }
      const { type: type2, metatype } = metadata2;
      if (type2 !== "param" && type2 !== "query") {
        return value;
      }
      if (metatype === Boolean) {
        return value === true || value === "true";
      }
      if (metatype === Number) {
        return +value;
      }
      return value;
    }
    toEmptyIfNil(value) {
      return (0, shared_utils_1.isNil)(value) ? {} : value;
    }
    stripProtoKeys(value) {
      if (value == null || typeof value !== "object" || util_12.types.isTypedArray(value)) {
        return;
      }
      if (Array.isArray(value)) {
        for (const v of value) {
          this.stripProtoKeys(v);
        }
        return;
      }
      delete value.__proto__;
      for (const key in value) {
        this.stripProtoKeys(value[key]);
      }
    }
    isPrimitive(value) {
      return ["number", "boolean", "string"].includes(typeof value);
    }
    validate(object, validatorOptions) {
      return classValidator.validate(object, validatorOptions);
    }
    flattenValidationErrors(validationErrors) {
      return (0, iterare_1.iterate)(validationErrors).map((error2) => this.mapChildrenToValidationErrors(error2)).flatten().filter((item) => !!item.constraints).map((item) => Object.values(item.constraints)).flatten().toArray();
    }
    mapChildrenToValidationErrors(error2, parentPath) {
      if (!(error2.children && error2.children.length)) {
        return [error2];
      }
      const validationErrors = [];
      parentPath = parentPath ? `${parentPath}.${error2.property}` : error2.property;
      for (const item of error2.children) {
        if (item.children && item.children.length) {
          validationErrors.push(...this.mapChildrenToValidationErrors(item, parentPath));
        }
        validationErrors.push(this.prependConstraintsWithParentProp(parentPath, item));
      }
      return validationErrors;
    }
    prependConstraintsWithParentProp(parentPath, error2) {
      const constraints = {};
      for (const key in error2.constraints) {
        constraints[key] = `${parentPath}.${error2.constraints[key]}`;
      }
      return Object.assign(Object.assign({}, error2), { constraints });
    }
  };
  ValidationPipe = tslib_1.__decorate([
    (0, core_12.Injectable)(),
    tslib_1.__param(0, (0, decorators_1.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object])
  ], ValidationPipe);
  validation_pipe.ValidationPipe = ValidationPipe;
  return validation_pipe;
}
var hasRequiredParseArray_pipe;
function requireParseArray_pipe() {
  if (hasRequiredParseArray_pipe)
    return parseArray_pipe;
  hasRequiredParseArray_pipe = 1;
  Object.defineProperty(parseArray_pipe, "__esModule", { value: true });
  parseArray_pipe.ParseArrayPipe = void 0;
  const tslib_1 = require$$0$3;
  const injectable_decorator_1 = requireInjectable_decorator();
  const optional_decorator_1 = requireOptional_decorator();
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_error_by_code_util_1 = requireHttpErrorByCode_util();
  const shared_utils_1 = requireShared_utils();
  const validation_pipe_1 = requireValidation_pipe();
  const VALIDATION_ERROR_MESSAGE = "Validation failed (parsable array expected)";
  const DEFAULT_ARRAY_SEPARATOR = ",";
  let ParseArrayPipe = class ParseArrayPipe {
    constructor(options = {}) {
      this.options = options;
      this.validationPipe = new validation_pipe_1.ValidationPipe(Object.assign({ transform: true, validateCustomDecorators: true }, options));
      const { exceptionFactory, errorHttpStatusCode = http_status_enum_1.HttpStatus.BAD_REQUEST } = options;
      this.exceptionFactory = exceptionFactory || ((error2) => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error2));
    }
    /**
     * Method that accesses and performs optional transformation on argument for
     * in-flight requests.
     *
     * @param value currently processed route argument
     * @param metadata contains metadata about the currently processed route argument
     */
    async transform(value, metadata2) {
      if (!value && !this.options.optional) {
        throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
      } else if ((0, shared_utils_1.isNil)(value) && this.options.optional) {
        return value;
      }
      if (!Array.isArray(value)) {
        if (!(0, shared_utils_1.isString)(value)) {
          throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
        } else {
          try {
            value = value.trim().split(this.options.separator || DEFAULT_ARRAY_SEPARATOR);
          } catch (_a) {
            throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
          }
        }
      }
      if (this.options.items) {
        const validationMetadata = {
          metatype: this.options.items,
          type: "query"
        };
        const isExpectedTypePrimitive = this.isExpectedTypePrimitive();
        const toClassInstance = (item, index) => {
          if (this.options.items !== String) {
            try {
              item = JSON.parse(item);
            } catch (_a) {
            }
          }
          if (isExpectedTypePrimitive) {
            return this.validatePrimitive(item, index);
          }
          return this.validationPipe.transform(item, validationMetadata);
        };
        if (this.options.stopAtFirstError === false) {
          let errors2 = [];
          const targetArray = value;
          for (let i = 0; i < targetArray.length; i++) {
            try {
              targetArray[i] = await toClassInstance(targetArray[i]);
            } catch (err) {
              let message;
              if (err.getResponse) {
                const response2 = err.getResponse();
                if (Array.isArray(response2.message)) {
                  message = response2.message.map((item) => `[${i}] ${item}`);
                } else {
                  message = `[${i}] ${response2.message}`;
                }
              } else {
                message = err;
              }
              errors2 = errors2.concat(message);
            }
          }
          if (errors2.length > 0) {
            throw this.exceptionFactory(errors2);
          }
          return targetArray;
        } else {
          value = await Promise.all(value.map(toClassInstance));
        }
      }
      return value;
    }
    isExpectedTypePrimitive() {
      return [Boolean, Number, String].includes(this.options.items);
    }
    validatePrimitive(originalValue, index) {
      if (this.options.items === Number) {
        const value = originalValue !== null && originalValue !== "" ? +originalValue : NaN;
        if (isNaN(value)) {
          throw this.exceptionFactory(`${(0, shared_utils_1.isUndefined)(index) ? "" : `[${index}] `}item must be a number`);
        }
        return value;
      } else if (this.options.items === String) {
        if (!(0, shared_utils_1.isString)(originalValue)) {
          return `${originalValue}`;
        }
      } else if (this.options.items === Boolean) {
        if (typeof originalValue !== "boolean") {
          throw this.exceptionFactory(`${(0, shared_utils_1.isUndefined)(index) ? "" : `[${index}] `}item must be a boolean value`);
        }
      }
      return originalValue;
    }
  };
  ParseArrayPipe = tslib_1.__decorate([
    (0, injectable_decorator_1.Injectable)(),
    tslib_1.__param(0, (0, optional_decorator_1.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object])
  ], ParseArrayPipe);
  parseArray_pipe.ParseArrayPipe = ParseArrayPipe;
  return parseArray_pipe;
}
var parseBool_pipe = {};
var hasRequiredParseBool_pipe;
function requireParseBool_pipe() {
  if (hasRequiredParseBool_pipe)
    return parseBool_pipe;
  hasRequiredParseBool_pipe = 1;
  Object.defineProperty(parseBool_pipe, "__esModule", { value: true });
  parseBool_pipe.ParseBoolPipe = void 0;
  const tslib_1 = require$$0$3;
  const injectable_decorator_1 = requireInjectable_decorator();
  const optional_decorator_1 = requireOptional_decorator();
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_error_by_code_util_1 = requireHttpErrorByCode_util();
  let ParseBoolPipe = class ParseBoolPipe {
    constructor(options) {
      options = options || {};
      const { exceptionFactory, errorHttpStatusCode = http_status_enum_1.HttpStatus.BAD_REQUEST } = options;
      this.exceptionFactory = exceptionFactory || ((error2) => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error2));
    }
    /**
     * Method that accesses and performs optional transformation on argument for
     * in-flight requests.
     *
     * @param value currently processed route argument
     * @param metadata contains metadata about the currently processed route argument
     */
    async transform(value, metadata2) {
      if (this.isTrue(value)) {
        return true;
      }
      if (this.isFalse(value)) {
        return false;
      }
      throw this.exceptionFactory("Validation failed (boolean string is expected)");
    }
    /**
     * @param value currently processed route argument
     * @returns `true` if `value` is said 'true', ie., if it is equal to the boolean
     * `true` or the string `"true"`
     */
    isTrue(value) {
      return value === true || value === "true";
    }
    /**
     * @param value currently processed route argument
     * @returns `true` if `value` is said 'false', ie., if it is equal to the boolean
     * `false` or the string `"false"`
     */
    isFalse(value) {
      return value === false || value === "false";
    }
  };
  ParseBoolPipe = tslib_1.__decorate([
    (0, injectable_decorator_1.Injectable)(),
    tslib_1.__param(0, (0, optional_decorator_1.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object])
  ], ParseBoolPipe);
  parseBool_pipe.ParseBoolPipe = ParseBoolPipe;
  return parseBool_pipe;
}
var parseInt_pipe = {};
var hasRequiredParseInt_pipe;
function requireParseInt_pipe() {
  if (hasRequiredParseInt_pipe)
    return parseInt_pipe;
  hasRequiredParseInt_pipe = 1;
  Object.defineProperty(parseInt_pipe, "__esModule", { value: true });
  parseInt_pipe.ParseIntPipe = void 0;
  const tslib_1 = require$$0$3;
  const injectable_decorator_1 = requireInjectable_decorator();
  const optional_decorator_1 = requireOptional_decorator();
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_error_by_code_util_1 = requireHttpErrorByCode_util();
  let ParseIntPipe = class ParseIntPipe {
    constructor(options) {
      options = options || {};
      const { exceptionFactory, errorHttpStatusCode = http_status_enum_1.HttpStatus.BAD_REQUEST } = options;
      this.exceptionFactory = exceptionFactory || ((error2) => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error2));
    }
    /**
     * Method that accesses and performs optional transformation on argument for
     * in-flight requests.
     *
     * @param value currently processed route argument
     * @param metadata contains metadata about the currently processed route argument
     */
    async transform(value, metadata2) {
      if (!this.isNumeric(value)) {
        throw this.exceptionFactory("Validation failed (numeric string is expected)");
      }
      return parseInt(value, 10);
    }
    /**
     * @param value currently processed route argument
     * @returns `true` if `value` is a valid integer number
     */
    isNumeric(value) {
      return ["string", "number"].includes(typeof value) && /^-?\d+$/.test(value) && isFinite(value);
    }
  };
  ParseIntPipe = tslib_1.__decorate([
    (0, injectable_decorator_1.Injectable)(),
    tslib_1.__param(0, (0, optional_decorator_1.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object])
  ], ParseIntPipe);
  parseInt_pipe.ParseIntPipe = ParseIntPipe;
  return parseInt_pipe;
}
var parseFloat_pipe = {};
var hasRequiredParseFloat_pipe;
function requireParseFloat_pipe() {
  if (hasRequiredParseFloat_pipe)
    return parseFloat_pipe;
  hasRequiredParseFloat_pipe = 1;
  Object.defineProperty(parseFloat_pipe, "__esModule", { value: true });
  parseFloat_pipe.ParseFloatPipe = void 0;
  const tslib_1 = require$$0$3;
  const index_1 = requireCommon$3();
  const core_12 = requireCore();
  const http_error_by_code_util_1 = requireHttpErrorByCode_util();
  let ParseFloatPipe = class ParseFloatPipe {
    constructor(options) {
      options = options || {};
      const { exceptionFactory, errorHttpStatusCode = index_1.HttpStatus.BAD_REQUEST } = options;
      this.exceptionFactory = exceptionFactory || ((error2) => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error2));
    }
    /**
     * Method that accesses and performs optional transformation on argument for
     * in-flight requests.
     *
     * @param value currently processed route argument
     * @param metadata contains metadata about the currently processed route argument
     */
    async transform(value, metadata2) {
      if (!this.isNumeric(value)) {
        throw this.exceptionFactory("Validation failed (numeric string is expected)");
      }
      return parseFloat(value);
    }
    /**
     * @param value currently processed route argument
     * @returns `true` if `value` is a valid float number
     */
    isNumeric(value) {
      return ["string", "number"].includes(typeof value) && !isNaN(parseFloat(value)) && isFinite(value);
    }
  };
  ParseFloatPipe = tslib_1.__decorate([
    (0, core_12.Injectable)(),
    tslib_1.__param(0, (0, core_12.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object])
  ], ParseFloatPipe);
  parseFloat_pipe.ParseFloatPipe = ParseFloatPipe;
  return parseFloat_pipe;
}
var parseEnum_pipe = {};
var hasRequiredParseEnum_pipe;
function requireParseEnum_pipe() {
  if (hasRequiredParseEnum_pipe)
    return parseEnum_pipe;
  hasRequiredParseEnum_pipe = 1;
  Object.defineProperty(parseEnum_pipe, "__esModule", { value: true });
  parseEnum_pipe.ParseEnumPipe = void 0;
  const tslib_1 = require$$0$3;
  const index_1 = requireCommon$3();
  const core_12 = requireCore();
  const http_error_by_code_util_1 = requireHttpErrorByCode_util();
  let ParseEnumPipe = class ParseEnumPipe {
    constructor(enumType, options) {
      this.enumType = enumType;
      if (!enumType) {
        throw new Error(`"ParseEnumPipe" requires "enumType" argument specified (to validate input values).`);
      }
      options = options || {};
      const { exceptionFactory, errorHttpStatusCode = index_1.HttpStatus.BAD_REQUEST } = options;
      this.exceptionFactory = exceptionFactory || ((error2) => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error2));
    }
    /**
     * Method that accesses and performs optional transformation on argument for
     * in-flight requests.
     *
     * @param value currently processed route argument
     * @param metadata contains metadata about the currently processed route argument
     */
    async transform(value, metadata2) {
      if (!this.isEnum(value)) {
        throw this.exceptionFactory("Validation failed (enum string is expected)");
      }
      return value;
    }
    isEnum(value) {
      const enumValues = Object.keys(this.enumType).map((item) => this.enumType[item]);
      return enumValues.includes(value);
    }
  };
  ParseEnumPipe = tslib_1.__decorate([
    (0, core_12.Injectable)(),
    tslib_1.__param(1, (0, core_12.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
  ], ParseEnumPipe);
  parseEnum_pipe.ParseEnumPipe = ParseEnumPipe;
  return parseEnum_pipe;
}
var parseUuid_pipe = {};
var hasRequiredParseUuid_pipe;
function requireParseUuid_pipe() {
  if (hasRequiredParseUuid_pipe)
    return parseUuid_pipe;
  hasRequiredParseUuid_pipe = 1;
  var ParseUUIDPipe_1;
  Object.defineProperty(parseUuid_pipe, "__esModule", { value: true });
  parseUuid_pipe.ParseUUIDPipe = void 0;
  const tslib_1 = require$$0$3;
  const injectable_decorator_1 = requireInjectable_decorator();
  const optional_decorator_1 = requireOptional_decorator();
  const http_status_enum_1 = requireHttpStatus_enum();
  const http_error_by_code_util_1 = requireHttpErrorByCode_util();
  const shared_utils_1 = requireShared_utils();
  let ParseUUIDPipe = ParseUUIDPipe_1 = class ParseUUIDPipe {
    constructor(options) {
      options = options || {};
      const { exceptionFactory, errorHttpStatusCode = http_status_enum_1.HttpStatus.BAD_REQUEST, version } = options;
      this.version = version;
      this.exceptionFactory = exceptionFactory || ((error2) => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error2));
    }
    async transform(value, metadata2) {
      if (!this.isUUID(value, this.version)) {
        throw this.exceptionFactory(`Validation failed (uuid${this.version ? ` v ${this.version}` : ""} is expected)`);
      }
      return value;
    }
    isUUID(str, version = "all") {
      if (!(0, shared_utils_1.isString)(str)) {
        throw this.exceptionFactory("The value passed as UUID is not a string");
      }
      const pattern2 = ParseUUIDPipe_1.uuidRegExps[version];
      return pattern2 === null || pattern2 === void 0 ? void 0 : pattern2.test(str);
    }
  };
  ParseUUIDPipe.uuidRegExps = {
    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
  };
  ParseUUIDPipe = ParseUUIDPipe_1 = tslib_1.__decorate([
    (0, injectable_decorator_1.Injectable)(),
    tslib_1.__param(0, (0, optional_decorator_1.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object])
  ], ParseUUIDPipe);
  parseUuid_pipe.ParseUUIDPipe = ParseUUIDPipe;
  return parseUuid_pipe;
}
var file = {};
var fileType_validator = {};
var fileValidator_interface = {};
var hasRequiredFileValidator_interface;
function requireFileValidator_interface() {
  if (hasRequiredFileValidator_interface)
    return fileValidator_interface;
  hasRequiredFileValidator_interface = 1;
  Object.defineProperty(fileValidator_interface, "__esModule", { value: true });
  fileValidator_interface.FileValidator = void 0;
  class FileValidator {
    constructor(validationOptions) {
      this.validationOptions = validationOptions;
    }
  }
  fileValidator_interface.FileValidator = FileValidator;
  return fileValidator_interface;
}
var hasRequiredFileType_validator;
function requireFileType_validator() {
  if (hasRequiredFileType_validator)
    return fileType_validator;
  hasRequiredFileType_validator = 1;
  Object.defineProperty(fileType_validator, "__esModule", { value: true });
  fileType_validator.FileTypeValidator = void 0;
  const file_validator_interface_1 = requireFileValidator_interface();
  class FileTypeValidator extends file_validator_interface_1.FileValidator {
    buildErrorMessage() {
      return `Validation failed (expected type is ${this.validationOptions.fileType})`;
    }
    isValid(file2) {
      if (!this.validationOptions) {
        return true;
      }
      if (!file2.mimetype) {
        return false;
      }
      return Boolean(file2.mimetype.match(this.validationOptions.fileType));
    }
  }
  fileType_validator.FileTypeValidator = FileTypeValidator;
  return fileType_validator;
}
var maxFileSize_validator = {};
var hasRequiredMaxFileSize_validator;
function requireMaxFileSize_validator() {
  if (hasRequiredMaxFileSize_validator)
    return maxFileSize_validator;
  hasRequiredMaxFileSize_validator = 1;
  Object.defineProperty(maxFileSize_validator, "__esModule", { value: true });
  maxFileSize_validator.MaxFileSizeValidator = void 0;
  const file_validator_interface_1 = requireFileValidator_interface();
  class MaxFileSizeValidator extends file_validator_interface_1.FileValidator {
    buildErrorMessage() {
      if ("message" in this.validationOptions) {
        if (typeof this.validationOptions.message === "function") {
          return this.validationOptions.message(this.validationOptions.maxSize);
        }
        return this.validationOptions.message;
      }
      return `Validation failed (expected size is less than ${this.validationOptions.maxSize})`;
    }
    isValid(file2) {
      if (!this.validationOptions) {
        return true;
      }
      return file2.size < this.validationOptions.maxSize;
    }
  }
  maxFileSize_validator.MaxFileSizeValidator = MaxFileSizeValidator;
  return maxFileSize_validator;
}
var parseFileOptions_interface = {};
var hasRequiredParseFileOptions_interface;
function requireParseFileOptions_interface() {
  if (hasRequiredParseFileOptions_interface)
    return parseFileOptions_interface;
  hasRequiredParseFileOptions_interface = 1;
  Object.defineProperty(parseFileOptions_interface, "__esModule", { value: true });
  return parseFileOptions_interface;
}
var parseFile_pipe = {};
var hasRequiredParseFile_pipe;
function requireParseFile_pipe() {
  if (hasRequiredParseFile_pipe)
    return parseFile_pipe;
  hasRequiredParseFile_pipe = 1;
  Object.defineProperty(parseFile_pipe, "__esModule", { value: true });
  parseFile_pipe.ParseFilePipe = void 0;
  const tslib_1 = require$$0$3;
  const core_12 = requireCore();
  const enums_1 = requireEnums();
  const http_error_by_code_util_1 = requireHttpErrorByCode_util();
  const shared_utils_1 = requireShared_utils();
  let ParseFilePipe = class ParseFilePipe {
    constructor(options = {}) {
      const { exceptionFactory, errorHttpStatusCode = enums_1.HttpStatus.BAD_REQUEST, validators: validators2 = [], fileIsRequired } = options;
      this.exceptionFactory = exceptionFactory || ((error2) => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error2));
      this.validators = validators2;
      this.fileIsRequired = fileIsRequired !== null && fileIsRequired !== void 0 ? fileIsRequired : true;
    }
    async transform(value) {
      const areThereAnyFilesIn = this.thereAreNoFilesIn(value);
      if (areThereAnyFilesIn && this.fileIsRequired) {
        throw this.exceptionFactory("File is required");
      }
      if (!areThereAnyFilesIn && this.validators.length) {
        await this.validateFilesOrFile(value);
      }
      return value;
    }
    async validateFilesOrFile(value) {
      if (Array.isArray(value)) {
        await Promise.all(value.map((f) => this.validate(f)));
      } else {
        await this.validate(value);
      }
    }
    thereAreNoFilesIn(value) {
      const isEmptyArray = Array.isArray(value) && (0, shared_utils_1.isEmpty)(value);
      const isEmptyObject2 = (0, shared_utils_1.isObject)(value) && (0, shared_utils_1.isEmpty)(Object.keys(value));
      return (0, shared_utils_1.isUndefined)(value) || isEmptyArray || isEmptyObject2;
    }
    async validate(file2) {
      for (const validator2 of this.validators) {
        await this.validateOrThrow(file2, validator2);
      }
      return file2;
    }
    async validateOrThrow(file2, validator2) {
      const isValid = await validator2.isValid(file2);
      if (!isValid) {
        const errorMessage = validator2.buildErrorMessage(file2);
        throw this.exceptionFactory(errorMessage);
      }
    }
    /**
     * @returns list of validators used in this pipe.
     */
    getValidators() {
      return this.validators;
    }
  };
  ParseFilePipe = tslib_1.__decorate([
    (0, core_12.Injectable)(),
    tslib_1.__param(0, (0, core_12.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object])
  ], ParseFilePipe);
  parseFile_pipe.ParseFilePipe = ParseFilePipe;
  return parseFile_pipe;
}
var parseFilePipe_builder = {};
var hasRequiredParseFilePipe_builder;
function requireParseFilePipe_builder() {
  if (hasRequiredParseFilePipe_builder)
    return parseFilePipe_builder;
  hasRequiredParseFilePipe_builder = 1;
  Object.defineProperty(parseFilePipe_builder, "__esModule", { value: true });
  parseFilePipe_builder.ParseFilePipeBuilder = void 0;
  const file_type_validator_1 = requireFileType_validator();
  const max_file_size_validator_1 = requireMaxFileSize_validator();
  const parse_file_pipe_1 = requireParseFile_pipe();
  class ParseFilePipeBuilder {
    constructor() {
      this.validators = [];
    }
    addMaxSizeValidator(options) {
      return this.addValidator(new max_file_size_validator_1.MaxFileSizeValidator(options));
    }
    addFileTypeValidator(options) {
      return this.addValidator(new file_type_validator_1.FileTypeValidator(options));
    }
    addValidator(validator2) {
      this.validators.push(validator2);
      return this;
    }
    build(additionalOptions) {
      const parseFilePipe = new parse_file_pipe_1.ParseFilePipe(Object.assign(Object.assign({}, additionalOptions), { validators: this.validators }));
      this.validators = [];
      return parseFilePipe;
    }
  }
  parseFilePipe_builder.ParseFilePipeBuilder = ParseFilePipeBuilder;
  return parseFilePipe_builder;
}
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile)
    return file;
  hasRequiredFile = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireFileType_validator(), exports2);
    tslib_1.__exportStar(requireFileValidator_interface(), exports2);
    tslib_1.__exportStar(requireMaxFileSize_validator(), exports2);
    tslib_1.__exportStar(requireParseFileOptions_interface(), exports2);
    tslib_1.__exportStar(requireParseFile_pipe(), exports2);
    tslib_1.__exportStar(requireParseFilePipe_builder(), exports2);
  })(file);
  return file;
}
var hasRequiredPipes$1;
function requirePipes$1() {
  if (hasRequiredPipes$1)
    return pipes$1;
  hasRequiredPipes$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireDefaultValue_pipe(), exports2);
    tslib_1.__exportStar(requireParseArray_pipe(), exports2);
    tslib_1.__exportStar(requireParseBool_pipe(), exports2);
    tslib_1.__exportStar(requireParseInt_pipe(), exports2);
    tslib_1.__exportStar(requireParseFloat_pipe(), exports2);
    tslib_1.__exportStar(requireParseEnum_pipe(), exports2);
    tslib_1.__exportStar(requireParseUuid_pipe(), exports2);
    tslib_1.__exportStar(requireValidation_pipe(), exports2);
    tslib_1.__exportStar(requireFile(), exports2);
  })(pipes$1);
  return pipes$1;
}
var serializer = {};
var classSerializer_interceptor = {};
var classSerializer_constants = {};
var hasRequiredClassSerializer_constants;
function requireClassSerializer_constants() {
  if (hasRequiredClassSerializer_constants)
    return classSerializer_constants;
  hasRequiredClassSerializer_constants = 1;
  Object.defineProperty(classSerializer_constants, "__esModule", { value: true });
  classSerializer_constants.CLASS_SERIALIZER_OPTIONS = void 0;
  classSerializer_constants.CLASS_SERIALIZER_OPTIONS = "class_serializer:options";
  return classSerializer_constants;
}
var hasRequiredClassSerializer_interceptor;
function requireClassSerializer_interceptor() {
  if (hasRequiredClassSerializer_interceptor)
    return classSerializer_interceptor;
  hasRequiredClassSerializer_interceptor = 1;
  Object.defineProperty(classSerializer_interceptor, "__esModule", { value: true });
  classSerializer_interceptor.ClassSerializerInterceptor = void 0;
  const tslib_1 = require$$0$3;
  const operators_1 = requireOperators();
  const core_12 = requireCore();
  const file_stream_1 = requireFileStream();
  const load_package_util_1 = requireLoadPackage_util();
  const shared_utils_1 = requireShared_utils();
  const class_serializer_constants_1 = requireClassSerializer_constants();
  let classTransformer = {};
  const REFLECTOR = "Reflector";
  let ClassSerializerInterceptor = class ClassSerializerInterceptor {
    constructor(reflector, defaultOptions2 = {}) {
      var _a;
      this.reflector = reflector;
      this.defaultOptions = defaultOptions2;
      classTransformer = (_a = defaultOptions2 === null || defaultOptions2 === void 0 ? void 0 : defaultOptions2.transformerPackage) !== null && _a !== void 0 ? _a : (0, load_package_util_1.loadPackage)("class-transformer", "ClassSerializerInterceptor", () => require$$7$1);
      if (!(defaultOptions2 === null || defaultOptions2 === void 0 ? void 0 : defaultOptions2.transformerPackage))
        ;
    }
    intercept(context, next) {
      const contextOptions = this.getContextOptions(context);
      const options = Object.assign(Object.assign({}, this.defaultOptions), contextOptions);
      return next.handle().pipe((0, operators_1.map)((res) => this.serialize(res, options)));
    }
    /**
     * Serializes responses that are non-null objects nor streamable files.
     */
    serialize(response2, options) {
      if (!(0, shared_utils_1.isObject)(response2) || response2 instanceof file_stream_1.StreamableFile) {
        return response2;
      }
      return Array.isArray(response2) ? response2.map((item) => this.transformToPlain(item, options)) : this.transformToPlain(response2, options);
    }
    transformToPlain(plainOrClass, options) {
      if (!plainOrClass) {
        return plainOrClass;
      }
      if (!options.type) {
        return classTransformer.classToPlain(plainOrClass, options);
      }
      if (plainOrClass instanceof options.type) {
        return classTransformer.classToPlain(plainOrClass, options);
      }
      const instance = classTransformer.plainToClass(options.type, plainOrClass);
      return classTransformer.classToPlain(instance, options);
    }
    getContextOptions(context) {
      return this.reflector.getAllAndOverride(class_serializer_constants_1.CLASS_SERIALIZER_OPTIONS, [
        context.getHandler(),
        context.getClass()
      ]);
    }
  };
  ClassSerializerInterceptor = tslib_1.__decorate([
    (0, core_12.Injectable)(),
    tslib_1.__param(0, (0, core_12.Inject)(REFLECTOR)),
    tslib_1.__param(1, (0, core_12.Optional)()),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
  ], ClassSerializerInterceptor);
  classSerializer_interceptor.ClassSerializerInterceptor = ClassSerializerInterceptor;
  return classSerializer_interceptor;
}
var decorators = {};
var serializeOptions_decorator = {};
var hasRequiredSerializeOptions_decorator;
function requireSerializeOptions_decorator() {
  if (hasRequiredSerializeOptions_decorator)
    return serializeOptions_decorator;
  hasRequiredSerializeOptions_decorator = 1;
  Object.defineProperty(serializeOptions_decorator, "__esModule", { value: true });
  serializeOptions_decorator.SerializeOptions = void 0;
  const decorators_1 = requireDecorators$2();
  const class_serializer_constants_1 = requireClassSerializer_constants();
  const SerializeOptions = (options) => (0, decorators_1.SetMetadata)(class_serializer_constants_1.CLASS_SERIALIZER_OPTIONS, options);
  serializeOptions_decorator.SerializeOptions = SerializeOptions;
  return serializeOptions_decorator;
}
var hasRequiredDecorators;
function requireDecorators() {
  if (hasRequiredDecorators)
    return decorators;
  hasRequiredDecorators = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireSerializeOptions_decorator(), exports2);
  })(decorators);
  return decorators;
}
var classSerializer_interfaces = {};
var hasRequiredClassSerializer_interfaces;
function requireClassSerializer_interfaces() {
  if (hasRequiredClassSerializer_interfaces)
    return classSerializer_interfaces;
  hasRequiredClassSerializer_interfaces = 1;
  Object.defineProperty(classSerializer_interfaces, "__esModule", { value: true });
  return classSerializer_interfaces;
}
var hasRequiredSerializer;
function requireSerializer() {
  if (hasRequiredSerializer)
    return serializer;
  hasRequiredSerializer = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireClassSerializer_interceptor(), exports2);
    tslib_1.__exportStar(requireDecorators(), exports2);
    tslib_1.__exportStar(requireClassSerializer_interfaces(), exports2);
  })(serializer);
  return serializer;
}
var utils$9 = {};
var forwardRef_util = {};
var hasRequiredForwardRef_util;
function requireForwardRef_util() {
  if (hasRequiredForwardRef_util)
    return forwardRef_util;
  hasRequiredForwardRef_util = 1;
  Object.defineProperty(forwardRef_util, "__esModule", { value: true });
  forwardRef_util.forwardRef = void 0;
  const forwardRef = (fn) => ({
    forwardRef: fn
  });
  forwardRef_util.forwardRef = forwardRef;
  return forwardRef_util;
}
var hasRequiredUtils$5;
function requireUtils$5() {
  if (hasRequiredUtils$5)
    return utils$9;
  hasRequiredUtils$5 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireForwardRef_util(), exports2);
  })(utils$9);
  return utils$9;
}
var hasRequiredCommon$3;
function requireCommon$3() {
  if (hasRequiredCommon$3)
    return common$9;
  hasRequiredCommon$3 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION_NEUTRAL = exports2.Scope = void 0;
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireCache(), exports2);
    tslib_1.__exportStar(requireDecorators$2(), exports2);
    tslib_1.__exportStar(requireEnums(), exports2);
    tslib_1.__exportStar(requireExceptions$2(), exports2);
    tslib_1.__exportStar(requireFileStream(), exports2);
    var interfaces_1 = requireInterfaces$3();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return interfaces_1.Scope;
    } });
    Object.defineProperty(exports2, "VERSION_NEUTRAL", { enumerable: true, get: function() {
      return interfaces_1.VERSION_NEUTRAL;
    } });
    tslib_1.__exportStar(requireModuleUtils(), exports2);
    tslib_1.__exportStar(requirePipes$1(), exports2);
    tslib_1.__exportStar(requireSerializer(), exports2);
    tslib_1.__exportStar(requireServices$1(), exports2);
    tslib_1.__exportStar(requireUtils$5(), exports2);
  })(common$9);
  return common$9;
}
var metadataScanner = {};
var hasRequiredMetadataScanner;
function requireMetadataScanner() {
  if (hasRequiredMetadataScanner)
    return metadataScanner;
  hasRequiredMetadataScanner = 1;
  Object.defineProperty(metadataScanner, "__esModule", { value: true });
  metadataScanner.MetadataScanner = void 0;
  const shared_utils_1 = requireShared_utils();
  class MetadataScanner {
    constructor() {
      this.cachedScannedPrototypes = /* @__PURE__ */ new Map();
    }
    /**
     * @deprecated
     * @see {@link getAllMethodNames}
     * @see getAllMethodNames
     */
    scanFromPrototype(instance, prototype2, callback) {
      if (!prototype2) {
        return [];
      }
      const visitedNames = /* @__PURE__ */ new Map();
      const result = [];
      do {
        for (const property of Object.getOwnPropertyNames(prototype2)) {
          if (visitedNames.has(property)) {
            continue;
          }
          visitedNames.set(property, true);
          const descriptor = Object.getOwnPropertyDescriptor(prototype2, property);
          if (descriptor.set || descriptor.get || (0, shared_utils_1.isConstructor)(property) || !(0, shared_utils_1.isFunction)(prototype2[property])) {
            continue;
          }
          const value = callback(property);
          if ((0, shared_utils_1.isNil)(value)) {
            continue;
          }
          result.push(value);
        }
      } while ((prototype2 = Reflect.getPrototypeOf(prototype2)) && prototype2 !== Object.prototype);
      return result;
    }
    /**
     * @deprecated
     * @see {@link getAllMethodNames}
     * @see getAllMethodNames
     */
    *getAllFilteredMethodNames(prototype2) {
      yield* this.getAllMethodNames(prototype2);
    }
    getAllMethodNames(prototype2) {
      if (!prototype2) {
        return [];
      }
      if (this.cachedScannedPrototypes.has(prototype2)) {
        return this.cachedScannedPrototypes.get(prototype2);
      }
      const visitedNames = /* @__PURE__ */ new Map();
      const result = [];
      this.cachedScannedPrototypes.set(prototype2, result);
      do {
        for (const property of Object.getOwnPropertyNames(prototype2)) {
          if (visitedNames.has(property)) {
            continue;
          }
          visitedNames.set(property, true);
          const descriptor = Object.getOwnPropertyDescriptor(prototype2, property);
          if (descriptor.set || descriptor.get || (0, shared_utils_1.isConstructor)(property) || !(0, shared_utils_1.isFunction)(prototype2[property])) {
            continue;
          }
          result.push(property);
        }
      } while ((prototype2 = Reflect.getPrototypeOf(prototype2)) && prototype2 !== Object.prototype);
      return result;
    }
  }
  metadataScanner.MetadataScanner = MetadataScanner;
  return metadataScanner;
}
var discoveryService = {};
var modulesContainer = {};
var hasRequiredModulesContainer;
function requireModulesContainer() {
  if (hasRequiredModulesContainer)
    return modulesContainer;
  hasRequiredModulesContainer = 1;
  Object.defineProperty(modulesContainer, "__esModule", { value: true });
  modulesContainer.ModulesContainer = void 0;
  const uid_1 = requireDist$1();
  class ModulesContainer extends Map {
    constructor() {
      super(...arguments);
      this._applicationId = (0, uid_1.uid)(21);
    }
    get applicationId() {
      return this._applicationId;
    }
    getById(id2) {
      return Array.from(this.values()).find((moduleRef2) => moduleRef2.id === id2);
    }
  }
  modulesContainer.ModulesContainer = ModulesContainer;
  return modulesContainer;
}
var hasRequiredDiscoveryService;
function requireDiscoveryService() {
  if (hasRequiredDiscoveryService)
    return discoveryService;
  hasRequiredDiscoveryService = 1;
  Object.defineProperty(discoveryService, "__esModule", { value: true });
  discoveryService.DiscoveryService = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const modules_container_1 = requireModulesContainer();
  let DiscoveryService = class DiscoveryService {
    constructor(modulesContainer2) {
      this.modulesContainer = modulesContainer2;
    }
    getProviders(options = {}, modules2 = this.getModules(options)) {
      const providers = modules2.map((item) => [...item.providers.values()]);
      return (0, common_1.flatten)(providers);
    }
    getControllers(options = {}, modules2 = this.getModules(options)) {
      const controllers = modules2.map((item) => [...item.controllers.values()]);
      return (0, common_1.flatten)(controllers);
    }
    getModules(options = {}) {
      if (!options.include) {
        const moduleRefs = [...this.modulesContainer.values()];
        return moduleRefs;
      }
      const whitelisted = this.includeWhitelisted(options.include);
      return whitelisted;
    }
    includeWhitelisted(include) {
      const moduleRefs = [...this.modulesContainer.values()];
      return moduleRefs.filter(({ metatype }) => include.some((item) => item === metatype));
    }
  };
  DiscoveryService = tslib_1.__decorate([
    (0, common_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [modules_container_1.ModulesContainer])
  ], DiscoveryService);
  discoveryService.DiscoveryService = DiscoveryService;
  return discoveryService;
}
var hasRequiredDiscoveryModule;
function requireDiscoveryModule() {
  if (hasRequiredDiscoveryModule)
    return discoveryModule;
  hasRequiredDiscoveryModule = 1;
  Object.defineProperty(discoveryModule, "__esModule", { value: true });
  discoveryModule.DiscoveryModule = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const metadata_scanner_1 = requireMetadataScanner();
  const discovery_service_1 = requireDiscoveryService();
  let DiscoveryModule = class DiscoveryModule {
  };
  DiscoveryModule = tslib_1.__decorate([
    (0, common_1.Module)({
      providers: [metadata_scanner_1.MetadataScanner, discovery_service_1.DiscoveryService],
      exports: [metadata_scanner_1.MetadataScanner, discovery_service_1.DiscoveryService]
    })
  ], DiscoveryModule);
  discoveryModule.DiscoveryModule = DiscoveryModule;
  return discoveryModule;
}
var hasRequiredDiscovery;
function requireDiscovery() {
  if (hasRequiredDiscovery)
    return discovery;
  hasRequiredDiscovery = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireDiscoveryModule(), exports2);
    tslib_1.__exportStar(requireDiscoveryService(), exports2);
  })(discovery);
  return discovery;
}
var exceptions$1 = {};
var baseExceptionFilter = {};
var httpAdapterHost = {};
var hasRequiredHttpAdapterHost;
function requireHttpAdapterHost() {
  if (hasRequiredHttpAdapterHost)
    return httpAdapterHost;
  hasRequiredHttpAdapterHost = 1;
  Object.defineProperty(httpAdapterHost, "__esModule", { value: true });
  httpAdapterHost.HttpAdapterHost = void 0;
  class HttpAdapterHost {
    /**
     * Accessor for the underlying `HttpAdapter`
     *
     * @param httpAdapter reference to the `HttpAdapter` to be set
     */
    set httpAdapter(httpAdapter3) {
      this._httpAdapter = httpAdapter3;
    }
    /**
     * Accessor for the underlying `HttpAdapter`
     *
     * @example
     * `const httpAdapter = adapterHost.httpAdapter;`
     */
    get httpAdapter() {
      return this._httpAdapter;
    }
  }
  httpAdapterHost.HttpAdapterHost = HttpAdapterHost;
  return httpAdapterHost;
}
var hasRequiredBaseExceptionFilter;
function requireBaseExceptionFilter() {
  if (hasRequiredBaseExceptionFilter)
    return baseExceptionFilter;
  hasRequiredBaseExceptionFilter = 1;
  Object.defineProperty(baseExceptionFilter, "__esModule", { value: true });
  baseExceptionFilter.BaseExceptionFilter = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const shared_utils_1 = requireShared_utils();
  const constants_1 = requireConstants$5();
  const http_adapter_host_1 = requireHttpAdapterHost();
  class BaseExceptionFilter {
    constructor(applicationRef) {
      this.applicationRef = applicationRef;
    }
    catch(exception, host) {
      const applicationRef = this.applicationRef || this.httpAdapterHost && this.httpAdapterHost.httpAdapter;
      if (!(exception instanceof common_1.HttpException)) {
        return this.handleUnknownError(exception, host, applicationRef);
      }
      const res = exception.getResponse();
      const message = (0, shared_utils_1.isObject)(res) ? res : {
        statusCode: exception.getStatus(),
        message: res
      };
      const response2 = host.getArgByIndex(1);
      if (!applicationRef.isHeadersSent(response2)) {
        applicationRef.reply(response2, message, exception.getStatus());
      } else {
        applicationRef.end(response2);
      }
    }
    handleUnknownError(exception, host, applicationRef) {
      const body = this.isHttpError(exception) ? {
        statusCode: exception.statusCode,
        message: exception.message
      } : {
        statusCode: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        message: constants_1.MESSAGES.UNKNOWN_EXCEPTION_MESSAGE
      };
      const response2 = host.getArgByIndex(1);
      if (!applicationRef.isHeadersSent(response2)) {
        applicationRef.reply(response2, body, body.statusCode);
      } else {
        applicationRef.end(response2);
      }
      if (this.isExceptionObject(exception)) {
        return BaseExceptionFilter.logger.error(exception.message, exception.stack);
      }
      return BaseExceptionFilter.logger.error(exception);
    }
    isExceptionObject(err) {
      return (0, shared_utils_1.isObject)(err) && !!err.message;
    }
    /**
     * Checks if the thrown error comes from the "http-errors" library.
     * @param err error object
     */
    isHttpError(err) {
      return (err === null || err === void 0 ? void 0 : err.statusCode) && (err === null || err === void 0 ? void 0 : err.message);
    }
  }
  BaseExceptionFilter.logger = new common_1.Logger("ExceptionsHandler");
  tslib_1.__decorate([
    (0, common_1.Optional)(),
    (0, common_1.Inject)(),
    tslib_1.__metadata("design:type", http_adapter_host_1.HttpAdapterHost)
  ], BaseExceptionFilter.prototype, "httpAdapterHost", void 0);
  baseExceptionFilter.BaseExceptionFilter = BaseExceptionFilter;
  return baseExceptionFilter;
}
var hasRequiredExceptions$1;
function requireExceptions$1() {
  if (hasRequiredExceptions$1)
    return exceptions$1;
  hasRequiredExceptions$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireBaseExceptionFilter(), exports2);
  })(exceptions$1);
  return exceptions$1;
}
var helpers = {};
var contextIdFactory = {};
var requestConstants = {};
var hasRequiredRequestConstants;
function requireRequestConstants() {
  if (hasRequiredRequestConstants)
    return requestConstants;
  hasRequiredRequestConstants = 1;
  Object.defineProperty(requestConstants, "__esModule", { value: true });
  requestConstants.REQUEST_CONTEXT_ID = requestConstants.REQUEST = void 0;
  requestConstants.REQUEST = "REQUEST";
  requestConstants.REQUEST_CONTEXT_ID = Symbol("REQUEST_CONTEXT_ID");
  return requestConstants;
}
var hasRequiredContextIdFactory;
function requireContextIdFactory() {
  if (hasRequiredContextIdFactory)
    return contextIdFactory;
  hasRequiredContextIdFactory = 1;
  Object.defineProperty(contextIdFactory, "__esModule", { value: true });
  contextIdFactory.ContextIdFactory = contextIdFactory.createContextId = void 0;
  const shared_utils_1 = requireShared_utils();
  const request_constants_1 = requireRequestConstants();
  function createContextId() {
    return { id: Math.random() };
  }
  contextIdFactory.createContextId = createContextId;
  class ContextIdFactory {
    /**
     * Generates a context identifier based on the request object.
     */
    static create() {
      return createContextId();
    }
    /**
     * Generates a random identifier to track asynchronous execution context.
     * @param request request object
     */
    static getByRequest(request2, propsToInspect = ["raw"]) {
      var _a;
      if (!request2) {
        return ContextIdFactory.create();
      }
      if (request2[request_constants_1.REQUEST_CONTEXT_ID]) {
        return request2[request_constants_1.REQUEST_CONTEXT_ID];
      }
      for (const key of propsToInspect) {
        if ((_a = request2[key]) === null || _a === void 0 ? void 0 : _a[request_constants_1.REQUEST_CONTEXT_ID]) {
          return request2[key][request_constants_1.REQUEST_CONTEXT_ID];
        }
      }
      if (!this.strategy) {
        return ContextIdFactory.create();
      }
      const contextId = createContextId();
      const resolverObjectOrFunction = this.strategy.attach(contextId, request2);
      if (this.isContextIdResolverWithPayload(resolverObjectOrFunction)) {
        contextId.getParent = resolverObjectOrFunction.resolve;
        contextId.payload = resolverObjectOrFunction.payload;
      } else {
        contextId.getParent = resolverObjectOrFunction;
      }
      return contextId;
    }
    /**
     * Registers a custom context id strategy that lets you attach
     * a parent context id to the existing context id object.
     * @param strategy strategy instance
     */
    static apply(strategy) {
      this.strategy = strategy;
    }
    static isContextIdResolverWithPayload(resolverOrResolverFn) {
      return (0, shared_utils_1.isObject)(resolverOrResolverFn);
    }
  }
  contextIdFactory.ContextIdFactory = ContextIdFactory;
  return contextIdFactory;
}
var externalContextCreator = {};
var externalExceptionFilterContext = {};
var constants$4 = {};
var hasRequiredConstants$2;
function requireConstants$2() {
  if (hasRequiredConstants$2)
    return constants$4;
  hasRequiredConstants$2 = 1;
  Object.defineProperty(constants$4, "__esModule", { value: true });
  constants$4.STATIC_CONTEXT = constants$4.CONTROLLER_ID_KEY = void 0;
  constants$4.CONTROLLER_ID_KEY = "CONTROLLER_ID";
  const STATIC_CONTEXT_ID = 1;
  constants$4.STATIC_CONTEXT = Object.freeze({
    id: STATIC_CONTEXT_ID
  });
  return constants$4;
}
var baseExceptionFilterContext = {};
var contextCreator = {};
var hasRequiredContextCreator;
function requireContextCreator() {
  if (hasRequiredContextCreator)
    return contextCreator;
  hasRequiredContextCreator = 1;
  Object.defineProperty(contextCreator, "__esModule", { value: true });
  contextCreator.ContextCreator = void 0;
  const constants_1 = requireConstants$2();
  class ContextCreator {
    createContext(instance, callback, metadataKey, contextId = constants_1.STATIC_CONTEXT, inquirerId) {
      const globalMetadata = this.getGlobalMetadata && this.getGlobalMetadata(contextId, inquirerId);
      const classMetadata = this.reflectClassMetadata(instance, metadataKey);
      const methodMetadata = this.reflectMethodMetadata(callback, metadataKey);
      return [
        ...this.createConcreteContext(globalMetadata || [], contextId, inquirerId),
        ...this.createConcreteContext(classMetadata, contextId, inquirerId),
        ...this.createConcreteContext(methodMetadata, contextId, inquirerId)
      ];
    }
    reflectClassMetadata(instance, metadataKey) {
      const prototype2 = Object.getPrototypeOf(instance);
      return Reflect.getMetadata(metadataKey, prototype2.constructor);
    }
    reflectMethodMetadata(callback, metadataKey) {
      return Reflect.getMetadata(metadataKey, callback);
    }
    getContextId(contextId, instanceWrapper2) {
      return contextId.getParent ? contextId.getParent({
        token: instanceWrapper2.token,
        isTreeDurable: instanceWrapper2.isDependencyTreeDurable()
      }) : contextId;
    }
  }
  contextCreator.ContextCreator = ContextCreator;
  return contextCreator;
}
var hasRequiredBaseExceptionFilterContext;
function requireBaseExceptionFilterContext() {
  if (hasRequiredBaseExceptionFilterContext)
    return baseExceptionFilterContext;
  hasRequiredBaseExceptionFilterContext = 1;
  Object.defineProperty(baseExceptionFilterContext, "__esModule", { value: true });
  baseExceptionFilterContext.BaseExceptionFilterContext = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const context_creator_1 = requireContextCreator();
  const constants_2 = requireConstants$2();
  class BaseExceptionFilterContext extends context_creator_1.ContextCreator {
    constructor(container2) {
      super();
      this.container = container2;
    }
    createConcreteContext(metadata2, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      if ((0, shared_utils_1.isEmpty)(metadata2)) {
        return [];
      }
      return (0, iterare_1.iterate)(metadata2).filter((instance) => instance && ((0, shared_utils_1.isFunction)(instance.catch) || instance.name)).map((filter3) => this.getFilterInstance(filter3, contextId, inquirerId)).filter((item) => !!item).map((instance) => ({
        func: instance.catch.bind(instance),
        exceptionMetatypes: this.reflectCatchExceptions(instance)
      })).toArray();
    }
    getFilterInstance(filter3, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      const isObject2 = filter3.catch;
      if (isObject2) {
        return filter3;
      }
      const instanceWrapper2 = this.getInstanceByMetatype(filter3);
      if (!instanceWrapper2) {
        return null;
      }
      const instanceHost = instanceWrapper2.getInstanceByContextId(this.getContextId(contextId, instanceWrapper2), inquirerId);
      return instanceHost && instanceHost.instance;
    }
    getInstanceByMetatype(metatype) {
      if (!this.moduleContext) {
        return;
      }
      const collection = this.container.getModules();
      const moduleRef2 = collection.get(this.moduleContext);
      if (!moduleRef2) {
        return;
      }
      return moduleRef2.injectables.get(metatype);
    }
    reflectCatchExceptions(instance) {
      const prototype2 = Object.getPrototypeOf(instance);
      return Reflect.getMetadata(constants_1.FILTER_CATCH_EXCEPTIONS, prototype2.constructor) || [];
    }
  }
  baseExceptionFilterContext.BaseExceptionFilterContext = BaseExceptionFilterContext;
  return baseExceptionFilterContext;
}
var externalExceptionsHandler = {};
var invalidExceptionFilter_exception = {};
var runtime_exception = {};
var hasRequiredRuntime_exception;
function requireRuntime_exception() {
  if (hasRequiredRuntime_exception)
    return runtime_exception;
  hasRequiredRuntime_exception = 1;
  Object.defineProperty(runtime_exception, "__esModule", { value: true });
  runtime_exception.RuntimeException = void 0;
  class RuntimeException extends Error {
    constructor(message = ``) {
      super(message);
    }
    what() {
      return this.message;
    }
  }
  runtime_exception.RuntimeException = RuntimeException;
  return runtime_exception;
}
var messages$1 = {};
var hasRequiredMessages$1;
function requireMessages$1() {
  if (hasRequiredMessages$1)
    return messages$1;
  hasRequiredMessages$1 = 1;
  Object.defineProperty(messages$1, "__esModule", { value: true });
  messages$1.MICROSERVICES_PACKAGE_NOT_FOUND_EXCEPTION = messages$1.INVALID_EXCEPTION_FILTER = messages$1.UNHANDLED_RUNTIME_EXCEPTION = messages$1.INVALID_MIDDLEWARE_CONFIGURATION = messages$1.UNKNOWN_REQUEST_MAPPING = messages$1.INVALID_CLASS_SCOPE_MESSAGE = messages$1.INVALID_CLASS_MESSAGE = messages$1.UNKNOWN_EXPORT_MESSAGE = messages$1.UNDEFINED_MODULE_MESSAGE = messages$1.USING_INVALID_CLASS_AS_A_MODULE_MESSAGE = messages$1.INVALID_MODULE_MESSAGE = messages$1.UNDEFINED_FORWARDREF_MESSAGE = messages$1.INVALID_MIDDLEWARE_MESSAGE = messages$1.UNKNOWN_DEPENDENCIES_MESSAGE = void 0;
  const shared_utils_1 = requireShared_utils();
  const getInstanceName = (instance) => {
    var _a, _b;
    if (instance === null || instance === void 0 ? void 0 : instance.forwardRef) {
      return (_a = instance.forwardRef()) === null || _a === void 0 ? void 0 : _a.name;
    }
    if (instance === null || instance === void 0 ? void 0 : instance.module) {
      return (_b = instance.module) === null || _b === void 0 ? void 0 : _b.name;
    }
    return instance === null || instance === void 0 ? void 0 : instance.name;
  };
  const getDependencyName = (dependency) => (
    // use class name
    getInstanceName(dependency) || // use injection token (symbol)
    (0, shared_utils_1.isSymbol)(dependency) && dependency.toString() || // use string directly
    dependency || // otherwise
    "+"
  );
  const getModuleName = (module2) => module2 && getInstanceName(module2.metatype) || "current";
  const stringifyScope = (scope2) => (scope2 || []).map(getInstanceName).join(" -> ");
  const UNKNOWN_DEPENDENCIES_MESSAGE = (type2, unknownDependencyContext, module2) => {
    const { index, name = "dependency", dependencies: dependencies2, key } = unknownDependencyContext;
    const moduleName = getModuleName(module2);
    const dependencyName = getDependencyName(name);
    const potentialSolutions = (
      // If module's name is well defined
      moduleName !== "current" ? `

Potential solutions:
- Is ${moduleName} a valid NestJS module?
- If ${dependencyName} is a provider, is it part of the current ${moduleName}?
- If ${dependencyName} is exported from a separate @Module, is that module imported within ${moduleName}?
  @Module({
    imports: [ /* the Module containing ${dependencyName} */ ]
  })
` : `

Potential solutions:
- If ${dependencyName} is a provider, is it part of the current Module?
- If ${dependencyName} is exported from a separate @Module, is that module imported within Module?
  @Module({
    imports: [ /* the Module containing ${dependencyName} */ ]
  })
`
    );
    let message = `Nest can't resolve dependencies of the ${type2.toString()}`;
    if ((0, shared_utils_1.isNil)(index)) {
      message += `. Please make sure that the "${key.toString()}" property is available in the current context.${potentialSolutions}`;
      return message;
    }
    const dependenciesName = (dependencies2 || []).map(getDependencyName);
    dependenciesName[index] = "?";
    message += ` (`;
    message += dependenciesName.join(", ");
    message += `). Please make sure that the argument ${dependencyName} at index [${index}] is available in the ${moduleName} context.`;
    message += potentialSolutions;
    return message;
  };
  messages$1.UNKNOWN_DEPENDENCIES_MESSAGE = UNKNOWN_DEPENDENCIES_MESSAGE;
  const INVALID_MIDDLEWARE_MESSAGE = (text, name) => `The middleware doesn't provide the 'use' method (${name})`;
  messages$1.INVALID_MIDDLEWARE_MESSAGE = INVALID_MIDDLEWARE_MESSAGE;
  const UNDEFINED_FORWARDREF_MESSAGE = (scope2) => `Nest cannot create the module instance. Often, this is because of a circular dependency between modules. Use forwardRef() to avoid it.

(Read more: https://docs.nestjs.com/fundamentals/circular-dependency)
Scope [${stringifyScope(scope2)}]
`;
  messages$1.UNDEFINED_FORWARDREF_MESSAGE = UNDEFINED_FORWARDREF_MESSAGE;
  const INVALID_MODULE_MESSAGE = (parentModule, index, scope2) => {
    const parentModuleName = (parentModule === null || parentModule === void 0 ? void 0 : parentModule.name) || "module";
    return `Nest cannot create the ${parentModuleName} instance.
Received an unexpected value at index [${index}] of the ${parentModuleName} "imports" array.

Scope [${stringifyScope(scope2)}]`;
  };
  messages$1.INVALID_MODULE_MESSAGE = INVALID_MODULE_MESSAGE;
  const USING_INVALID_CLASS_AS_A_MODULE_MESSAGE = (metatypeUsedAsAModule, scope2) => {
    const metatypeNameQuote = `"${getInstanceName(metatypeUsedAsAModule)}"` || "that class";
    return `Classes annotated with @Injectable(), @Catch(), and @Controller() decorators must not appear in the "imports" array of a module.
Please remove ${metatypeNameQuote} (including forwarded occurrences, if any) from all of the "imports" arrays.

Scope [${stringifyScope(scope2)}]
`;
  };
  messages$1.USING_INVALID_CLASS_AS_A_MODULE_MESSAGE = USING_INVALID_CLASS_AS_A_MODULE_MESSAGE;
  const UNDEFINED_MODULE_MESSAGE = (parentModule, index, scope2) => {
    const parentModuleName = (parentModule === null || parentModule === void 0 ? void 0 : parentModule.name) || "module";
    return `Nest cannot create the ${parentModuleName} instance.
The module at index [${index}] of the ${parentModuleName} "imports" array is undefined.

Potential causes:
- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency
- The module at index [${index}] is of type "undefined". Check your import statements and the type of the module.

Scope [${stringifyScope(scope2)}]`;
  };
  messages$1.UNDEFINED_MODULE_MESSAGE = UNDEFINED_MODULE_MESSAGE;
  const UNKNOWN_EXPORT_MESSAGE = (token = "item", module2) => {
    token = (0, shared_utils_1.isSymbol)(token) ? token.toString() : token;
    return `Nest cannot export a provider/module that is not a part of the currently processed module (${module2}). Please verify whether the exported ${token} is available in this particular context.

Possible Solutions:
- Is ${token} part of the relevant providers/imports within ${module2}?
`;
  };
  messages$1.UNKNOWN_EXPORT_MESSAGE = UNKNOWN_EXPORT_MESSAGE;
  const INVALID_CLASS_MESSAGE = (text, value) => `ModuleRef cannot instantiate class (${value} is not constructable).`;
  messages$1.INVALID_CLASS_MESSAGE = INVALID_CLASS_MESSAGE;
  const INVALID_CLASS_SCOPE_MESSAGE = (text, name) => `${name || "This class"} is marked as a scoped provider. Request and transient-scoped providers can't be used in combination with "get()" method. Please, use "resolve()" instead.`;
  messages$1.INVALID_CLASS_SCOPE_MESSAGE = INVALID_CLASS_SCOPE_MESSAGE;
  const UNKNOWN_REQUEST_MAPPING = (metatype) => {
    const className = metatype.name;
    return className ? `An invalid controller has been detected. "${className}" does not have the @Controller() decorator but it is being listed in the "controllers" array of some module.` : `An invalid controller has been detected. Perhaps, one of your controllers is missing the @Controller() decorator.`;
  };
  messages$1.UNKNOWN_REQUEST_MAPPING = UNKNOWN_REQUEST_MAPPING;
  messages$1.INVALID_MIDDLEWARE_CONFIGURATION = `An invalid middleware configuration has been passed inside the module 'configure()' method.`;
  messages$1.UNHANDLED_RUNTIME_EXCEPTION = `Unhandled Runtime Exception.`;
  messages$1.INVALID_EXCEPTION_FILTER = `Invalid exception filters (@UseFilters()).`;
  messages$1.MICROSERVICES_PACKAGE_NOT_FOUND_EXCEPTION = `Unable to load @nestjs/microservices package. (Please make sure that it's already installed.)`;
  return messages$1;
}
var hasRequiredInvalidExceptionFilter_exception;
function requireInvalidExceptionFilter_exception() {
  if (hasRequiredInvalidExceptionFilter_exception)
    return invalidExceptionFilter_exception;
  hasRequiredInvalidExceptionFilter_exception = 1;
  Object.defineProperty(invalidExceptionFilter_exception, "__esModule", { value: true });
  invalidExceptionFilter_exception.InvalidExceptionFilterException = void 0;
  const runtime_exception_1 = requireRuntime_exception();
  const messages_1 = requireMessages$1();
  class InvalidExceptionFilterException extends runtime_exception_1.RuntimeException {
    constructor() {
      super(messages_1.INVALID_EXCEPTION_FILTER);
    }
  }
  invalidExceptionFilter_exception.InvalidExceptionFilterException = InvalidExceptionFilterException;
  return invalidExceptionFilter_exception;
}
var externalExceptionFilter = {};
var hasRequiredExternalExceptionFilter;
function requireExternalExceptionFilter() {
  if (hasRequiredExternalExceptionFilter)
    return externalExceptionFilter;
  hasRequiredExternalExceptionFilter = 1;
  Object.defineProperty(externalExceptionFilter, "__esModule", { value: true });
  externalExceptionFilter.ExternalExceptionFilter = void 0;
  const common_1 = requireCommon$3();
  class ExternalExceptionFilter {
    catch(exception, host) {
      if (exception instanceof Error && !(exception instanceof common_1.HttpException)) {
        ExternalExceptionFilter.logger.error(exception.message, exception.stack);
      }
      throw exception;
    }
  }
  ExternalExceptionFilter.logger = new common_1.Logger("ExceptionsHandler");
  externalExceptionFilter.ExternalExceptionFilter = ExternalExceptionFilter;
  return externalExceptionFilter;
}
var hasRequiredExternalExceptionsHandler;
function requireExternalExceptionsHandler() {
  if (hasRequiredExternalExceptionsHandler)
    return externalExceptionsHandler;
  hasRequiredExternalExceptionsHandler = 1;
  Object.defineProperty(externalExceptionsHandler, "__esModule", { value: true });
  externalExceptionsHandler.ExternalExceptionsHandler = void 0;
  const shared_utils_1 = requireShared_utils();
  const invalid_exception_filter_exception_1 = requireInvalidExceptionFilter_exception();
  const external_exception_filter_1 = requireExternalExceptionFilter();
  class ExternalExceptionsHandler extends external_exception_filter_1.ExternalExceptionFilter {
    constructor() {
      super(...arguments);
      this.filters = [];
    }
    next(exception, host) {
      const result = this.invokeCustomFilters(exception, host);
      if (result) {
        return result;
      }
      return super.catch(exception, host);
    }
    setCustomFilters(filters) {
      if (!Array.isArray(filters)) {
        throw new invalid_exception_filter_exception_1.InvalidExceptionFilterException();
      }
      this.filters = filters;
    }
    invokeCustomFilters(exception, host) {
      if ((0, shared_utils_1.isEmpty)(this.filters)) {
        return null;
      }
      const isInstanceOf = (metatype) => exception instanceof metatype;
      const filter3 = this.filters.find(({ exceptionMetatypes }) => {
        const typeExists = !exceptionMetatypes.length || exceptionMetatypes.some(isInstanceOf);
        return typeExists;
      });
      return filter3 ? filter3.func(exception, host) : null;
    }
  }
  externalExceptionsHandler.ExternalExceptionsHandler = ExternalExceptionsHandler;
  return externalExceptionsHandler;
}
var hasRequiredExternalExceptionFilterContext;
function requireExternalExceptionFilterContext() {
  if (hasRequiredExternalExceptionFilterContext)
    return externalExceptionFilterContext;
  hasRequiredExternalExceptionFilterContext = 1;
  Object.defineProperty(externalExceptionFilterContext, "__esModule", { value: true });
  externalExceptionFilterContext.ExternalExceptionFilterContext = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const constants_2 = requireConstants$2();
  const base_exception_filter_context_1 = requireBaseExceptionFilterContext();
  const external_exceptions_handler_1 = requireExternalExceptionsHandler();
  const iterare_1 = requireLib$4();
  class ExternalExceptionFilterContext extends base_exception_filter_context_1.BaseExceptionFilterContext {
    constructor(container2, config2) {
      super(container2);
      this.config = config2;
    }
    create(instance, callback, module2, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      this.moduleContext = module2;
      const exceptionHandler2 = new external_exceptions_handler_1.ExternalExceptionsHandler();
      const filters = this.createContext(instance, callback, constants_1.EXCEPTION_FILTERS_METADATA, contextId, inquirerId);
      if ((0, shared_utils_1.isEmpty)(filters)) {
        return exceptionHandler2;
      }
      exceptionHandler2.setCustomFilters(filters.reverse());
      return exceptionHandler2;
    }
    getGlobalMetadata(contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      if (!this.config) {
        return [];
      }
      const globalFilters = this.config.getGlobalFilters();
      if (contextId === constants_2.STATIC_CONTEXT && !inquirerId) {
        return globalFilters;
      }
      const scopedFilterWrappers = this.config.getGlobalRequestFilters();
      const scopedFilters = (0, iterare_1.iterate)(scopedFilterWrappers).map((wrapper) => wrapper.getInstanceByContextId(contextId, inquirerId)).filter((host) => !!host).map((host) => host.instance).toArray();
      return globalFilters.concat(scopedFilters);
    }
  }
  externalExceptionFilterContext.ExternalExceptionFilterContext = ExternalExceptionFilterContext;
  return externalExceptionFilterContext;
}
var constants$3 = {};
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1)
    return constants$3;
  hasRequiredConstants$1 = 1;
  Object.defineProperty(constants$3, "__esModule", { value: true });
  constants$3.FORBIDDEN_MESSAGE = void 0;
  constants$3.FORBIDDEN_MESSAGE = "Forbidden resource";
  return constants$3;
}
var guards = {};
var guardsConsumer = {};
var executionContextHost = {};
var hasRequiredExecutionContextHost;
function requireExecutionContextHost() {
  if (hasRequiredExecutionContextHost)
    return executionContextHost;
  hasRequiredExecutionContextHost = 1;
  Object.defineProperty(executionContextHost, "__esModule", { value: true });
  executionContextHost.ExecutionContextHost = void 0;
  class ExecutionContextHost {
    constructor(args2, constructorRef = null, handler = null) {
      this.args = args2;
      this.constructorRef = constructorRef;
      this.handler = handler;
      this.contextType = "http";
    }
    setType(type2) {
      type2 && (this.contextType = type2);
    }
    getType() {
      return this.contextType;
    }
    getClass() {
      return this.constructorRef;
    }
    getHandler() {
      return this.handler;
    }
    getArgs() {
      return this.args;
    }
    getArgByIndex(index) {
      return this.args[index];
    }
    switchToRpc() {
      return Object.assign(this, {
        getData: () => this.getArgByIndex(0),
        getContext: () => this.getArgByIndex(1)
      });
    }
    switchToHttp() {
      return Object.assign(this, {
        getRequest: () => this.getArgByIndex(0),
        getResponse: () => this.getArgByIndex(1),
        getNext: () => this.getArgByIndex(2)
      });
    }
    switchToWs() {
      return Object.assign(this, {
        getClient: () => this.getArgByIndex(0),
        getData: () => this.getArgByIndex(1)
      });
    }
  }
  executionContextHost.ExecutionContextHost = ExecutionContextHost;
  return executionContextHost;
}
var hasRequiredGuardsConsumer;
function requireGuardsConsumer() {
  if (hasRequiredGuardsConsumer)
    return guardsConsumer;
  hasRequiredGuardsConsumer = 1;
  Object.defineProperty(guardsConsumer, "__esModule", { value: true });
  guardsConsumer.GuardsConsumer = void 0;
  const shared_utils_1 = requireShared_utils();
  const rxjs_1 = requireCjs();
  const execution_context_host_1 = requireExecutionContextHost();
  class GuardsConsumer {
    async tryActivate(guards2, args2, instance, callback, type2) {
      if (!guards2 || (0, shared_utils_1.isEmpty)(guards2)) {
        return true;
      }
      const context = this.createContext(args2, instance, callback);
      context.setType(type2);
      for (const guard of guards2) {
        const result = guard.canActivate(context);
        if (await this.pickResult(result)) {
          continue;
        }
        return false;
      }
      return true;
    }
    createContext(args2, instance, callback) {
      return new execution_context_host_1.ExecutionContextHost(args2, instance.constructor, callback);
    }
    async pickResult(result) {
      if (result instanceof rxjs_1.Observable) {
        return (0, rxjs_1.lastValueFrom)(result);
      }
      return result;
    }
  }
  guardsConsumer.GuardsConsumer = GuardsConsumer;
  return guardsConsumer;
}
var guardsContextCreator = {};
var hasRequiredGuardsContextCreator;
function requireGuardsContextCreator() {
  if (hasRequiredGuardsContextCreator)
    return guardsContextCreator;
  hasRequiredGuardsContextCreator = 1;
  Object.defineProperty(guardsContextCreator, "__esModule", { value: true });
  guardsContextCreator.GuardsContextCreator = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const context_creator_1 = requireContextCreator();
  const constants_2 = requireConstants$2();
  class GuardsContextCreator extends context_creator_1.ContextCreator {
    constructor(container2, config2) {
      super();
      this.container = container2;
      this.config = config2;
    }
    create(instance, callback, module2, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      this.moduleContext = module2;
      return this.createContext(instance, callback, constants_1.GUARDS_METADATA, contextId, inquirerId);
    }
    createConcreteContext(metadata2, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      if ((0, shared_utils_1.isEmpty)(metadata2)) {
        return [];
      }
      return (0, iterare_1.iterate)(metadata2).filter((guard) => guard && (guard.name || guard.canActivate)).map((guard) => this.getGuardInstance(guard, contextId, inquirerId)).filter((guard) => guard && (0, shared_utils_1.isFunction)(guard.canActivate)).toArray();
    }
    getGuardInstance(metatype, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      const isObject2 = metatype.canActivate;
      if (isObject2) {
        return metatype;
      }
      const instanceWrapper2 = this.getInstanceByMetatype(metatype);
      if (!instanceWrapper2) {
        return null;
      }
      const instanceHost = instanceWrapper2.getInstanceByContextId(this.getContextId(contextId, instanceWrapper2), inquirerId);
      return instanceHost && instanceHost.instance;
    }
    getInstanceByMetatype(metatype) {
      if (!this.moduleContext) {
        return;
      }
      const collection = this.container.getModules();
      const moduleRef2 = collection.get(this.moduleContext);
      if (!moduleRef2) {
        return;
      }
      const injectables = moduleRef2.injectables;
      return injectables.get(metatype);
    }
    getGlobalMetadata(contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      if (!this.config) {
        return [];
      }
      const globalGuards = this.config.getGlobalGuards();
      if (contextId === constants_2.STATIC_CONTEXT && !inquirerId) {
        return globalGuards;
      }
      const scopedGuardWrappers = this.config.getGlobalRequestGuards();
      const scopedGuards = (0, iterare_1.iterate)(scopedGuardWrappers).map((wrapper) => wrapper.getInstanceByContextId(this.getContextId(contextId, wrapper), inquirerId)).filter((host) => !!host).map((host) => host.instance).toArray();
      return globalGuards.concat(scopedGuards);
    }
  }
  guardsContextCreator.GuardsContextCreator = GuardsContextCreator;
  return guardsContextCreator;
}
var hasRequiredGuards;
function requireGuards() {
  if (hasRequiredGuards)
    return guards;
  hasRequiredGuards = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireConstants$1(), exports2);
    tslib_1.__exportStar(requireGuardsConsumer(), exports2);
    tslib_1.__exportStar(requireGuardsContextCreator(), exports2);
  })(guards);
  return guards;
}
var interceptors$1 = {};
var interceptorsConsumer = {};
var hasRequiredInterceptorsConsumer;
function requireInterceptorsConsumer() {
  if (hasRequiredInterceptorsConsumer)
    return interceptorsConsumer;
  hasRequiredInterceptorsConsumer = 1;
  Object.defineProperty(interceptorsConsumer, "__esModule", { value: true });
  interceptorsConsumer.InterceptorsConsumer = void 0;
  const shared_utils_1 = requireShared_utils();
  const rxjs_1 = requireCjs();
  const operators_1 = requireOperators();
  const execution_context_host_1 = requireExecutionContextHost();
  class InterceptorsConsumer {
    async intercept(interceptors2, args2, instance, callback, next, type2) {
      if ((0, shared_utils_1.isEmpty)(interceptors2)) {
        return next();
      }
      const context = this.createContext(args2, instance, callback);
      context.setType(type2);
      const start$ = (0, rxjs_1.defer)(() => this.transformDeferred(next));
      const nextFn = (i = 0) => async () => {
        if (i >= interceptors2.length) {
          return start$;
        }
        const handler = {
          handle: () => (0, rxjs_1.from)(nextFn(i + 1)()).pipe((0, operators_1.mergeAll)())
        };
        return interceptors2[i].intercept(context, handler);
      };
      return nextFn()();
    }
    createContext(args2, instance, callback) {
      return new execution_context_host_1.ExecutionContextHost(args2, instance.constructor, callback);
    }
    transformDeferred(next) {
      return (0, rxjs_1.from)(next()).pipe((0, operators_1.switchMap)((res) => {
        const isDeferred = res instanceof Promise || res instanceof rxjs_1.Observable;
        return isDeferred ? res : Promise.resolve(res);
      }));
    }
  }
  interceptorsConsumer.InterceptorsConsumer = InterceptorsConsumer;
  return interceptorsConsumer;
}
var interceptorsContextCreator = {};
var hasRequiredInterceptorsContextCreator;
function requireInterceptorsContextCreator() {
  if (hasRequiredInterceptorsContextCreator)
    return interceptorsContextCreator;
  hasRequiredInterceptorsContextCreator = 1;
  Object.defineProperty(interceptorsContextCreator, "__esModule", { value: true });
  interceptorsContextCreator.InterceptorsContextCreator = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const context_creator_1 = requireContextCreator();
  const constants_2 = requireConstants$2();
  class InterceptorsContextCreator extends context_creator_1.ContextCreator {
    constructor(container2, config2) {
      super();
      this.container = container2;
      this.config = config2;
    }
    create(instance, callback, module2, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      this.moduleContext = module2;
      return this.createContext(instance, callback, constants_1.INTERCEPTORS_METADATA, contextId, inquirerId);
    }
    createConcreteContext(metadata2, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      if ((0, shared_utils_1.isEmpty)(metadata2)) {
        return [];
      }
      return (0, iterare_1.iterate)(metadata2).filter((interceptor) => interceptor && (interceptor.name || interceptor.intercept)).map((interceptor) => this.getInterceptorInstance(interceptor, contextId, inquirerId)).filter((interceptor) => interceptor && (0, shared_utils_1.isFunction)(interceptor.intercept)).toArray();
    }
    getInterceptorInstance(metatype, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      const isObject2 = metatype.intercept;
      if (isObject2) {
        return metatype;
      }
      const instanceWrapper2 = this.getInstanceByMetatype(metatype);
      if (!instanceWrapper2) {
        return null;
      }
      const instanceHost = instanceWrapper2.getInstanceByContextId(this.getContextId(contextId, instanceWrapper2), inquirerId);
      return instanceHost && instanceHost.instance;
    }
    getInstanceByMetatype(metatype) {
      if (!this.moduleContext) {
        return;
      }
      const collection = this.container.getModules();
      const moduleRef2 = collection.get(this.moduleContext);
      if (!moduleRef2) {
        return;
      }
      return moduleRef2.injectables.get(metatype);
    }
    getGlobalMetadata(contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      if (!this.config) {
        return [];
      }
      const globalInterceptors = this.config.getGlobalInterceptors();
      if (contextId === constants_2.STATIC_CONTEXT && !inquirerId) {
        return globalInterceptors;
      }
      const scopedInterceptorWrappers = this.config.getGlobalRequestInterceptors();
      const scopedInterceptors = (0, iterare_1.iterate)(scopedInterceptorWrappers).map((wrapper) => wrapper.getInstanceByContextId(this.getContextId(contextId, wrapper), inquirerId)).filter((host) => !!host).map((host) => host.instance).toArray();
      return globalInterceptors.concat(scopedInterceptors);
    }
  }
  interceptorsContextCreator.InterceptorsContextCreator = InterceptorsContextCreator;
  return interceptorsContextCreator;
}
var hasRequiredInterceptors$1;
function requireInterceptors$1() {
  if (hasRequiredInterceptors$1)
    return interceptors$1;
  hasRequiredInterceptors$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireInterceptorsConsumer(), exports2);
    tslib_1.__exportStar(requireInterceptorsContextCreator(), exports2);
  })(interceptors$1);
  return interceptors$1;
}
var pipes = {};
var paramsTokenFactory = {};
var hasRequiredParamsTokenFactory;
function requireParamsTokenFactory() {
  if (hasRequiredParamsTokenFactory)
    return paramsTokenFactory;
  hasRequiredParamsTokenFactory = 1;
  Object.defineProperty(paramsTokenFactory, "__esModule", { value: true });
  paramsTokenFactory.ParamsTokenFactory = void 0;
  const route_paramtypes_enum_1 = requireRouteParamtypes_enum();
  class ParamsTokenFactory {
    exchangeEnumForString(type2) {
      switch (type2) {
        case route_paramtypes_enum_1.RouteParamtypes.BODY:
          return "body";
        case route_paramtypes_enum_1.RouteParamtypes.PARAM:
          return "param";
        case route_paramtypes_enum_1.RouteParamtypes.QUERY:
          return "query";
        default:
          return "custom";
      }
    }
  }
  paramsTokenFactory.ParamsTokenFactory = ParamsTokenFactory;
  return paramsTokenFactory;
}
var pipesConsumer = {};
var hasRequiredPipesConsumer;
function requirePipesConsumer() {
  if (hasRequiredPipesConsumer)
    return pipesConsumer;
  hasRequiredPipesConsumer = 1;
  Object.defineProperty(pipesConsumer, "__esModule", { value: true });
  pipesConsumer.PipesConsumer = void 0;
  const params_token_factory_1 = requireParamsTokenFactory();
  class PipesConsumer {
    constructor() {
      this.paramsTokenFactory = new params_token_factory_1.ParamsTokenFactory();
    }
    async apply(value, { metatype, type: type2, data }, pipes2) {
      const token = this.paramsTokenFactory.exchangeEnumForString(type2);
      return this.applyPipes(value, { metatype, type: token, data }, pipes2);
    }
    async applyPipes(value, { metatype, type: type2, data }, transforms) {
      return transforms.reduce(async (deferredValue, pipe2) => {
        const val = await deferredValue;
        const result = pipe2.transform(val, { metatype, type: type2, data });
        return result;
      }, Promise.resolve(value));
    }
  }
  pipesConsumer.PipesConsumer = PipesConsumer;
  return pipesConsumer;
}
var pipesContextCreator = {};
var hasRequiredPipesContextCreator;
function requirePipesContextCreator() {
  if (hasRequiredPipesContextCreator)
    return pipesContextCreator;
  hasRequiredPipesContextCreator = 1;
  Object.defineProperty(pipesContextCreator, "__esModule", { value: true });
  pipesContextCreator.PipesContextCreator = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const context_creator_1 = requireContextCreator();
  const constants_2 = requireConstants$2();
  class PipesContextCreator extends context_creator_1.ContextCreator {
    constructor(container2, config2) {
      super();
      this.container = container2;
      this.config = config2;
    }
    create(instance, callback, moduleKey, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      this.moduleContext = moduleKey;
      return this.createContext(instance, callback, constants_1.PIPES_METADATA, contextId, inquirerId);
    }
    createConcreteContext(metadata2, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      if ((0, shared_utils_1.isEmpty)(metadata2)) {
        return [];
      }
      return (0, iterare_1.iterate)(metadata2).filter((pipe2) => pipe2 && (pipe2.name || pipe2.transform)).map((pipe2) => this.getPipeInstance(pipe2, contextId, inquirerId)).filter((pipe2) => pipe2 && pipe2.transform && (0, shared_utils_1.isFunction)(pipe2.transform)).toArray();
    }
    getPipeInstance(pipe2, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      const isObject2 = pipe2.transform;
      if (isObject2) {
        return pipe2;
      }
      const instanceWrapper2 = this.getInstanceByMetatype(pipe2);
      if (!instanceWrapper2) {
        return null;
      }
      const instanceHost = instanceWrapper2.getInstanceByContextId(this.getContextId(contextId, instanceWrapper2), inquirerId);
      return instanceHost && instanceHost.instance;
    }
    getInstanceByMetatype(metatype) {
      if (!this.moduleContext) {
        return;
      }
      const collection = this.container.getModules();
      const moduleRef2 = collection.get(this.moduleContext);
      if (!moduleRef2) {
        return;
      }
      return moduleRef2.injectables.get(metatype);
    }
    getGlobalMetadata(contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      if (!this.config) {
        return [];
      }
      const globalPipes = this.config.getGlobalPipes();
      if (contextId === constants_2.STATIC_CONTEXT && !inquirerId) {
        return globalPipes;
      }
      const scopedPipeWrappers = this.config.getGlobalRequestPipes();
      const scopedPipes = (0, iterare_1.iterate)(scopedPipeWrappers).map((wrapper) => wrapper.getInstanceByContextId(this.getContextId(contextId, wrapper), inquirerId)).filter((host) => !!host).map((host) => host.instance).toArray();
      return globalPipes.concat(scopedPipes);
    }
    setModuleContext(context) {
      this.moduleContext = context;
    }
  }
  pipesContextCreator.PipesContextCreator = PipesContextCreator;
  return pipesContextCreator;
}
var hasRequiredPipes;
function requirePipes() {
  if (hasRequiredPipes)
    return pipes;
  hasRequiredPipes = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireParamsTokenFactory(), exports2);
    tslib_1.__exportStar(requirePipesConsumer(), exports2);
    tslib_1.__exportStar(requirePipesContextCreator(), exports2);
  })(pipes);
  return pipes;
}
var contextUtils = {};
var hasRequiredContextUtils;
function requireContextUtils() {
  if (hasRequiredContextUtils)
    return contextUtils;
  hasRequiredContextUtils = 1;
  Object.defineProperty(contextUtils, "__esModule", { value: true });
  contextUtils.ContextUtils = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const execution_context_host_1 = requireExecutionContextHost();
  class ContextUtils {
    mapParamType(key) {
      const keyPair = key.split(":");
      return keyPair[0];
    }
    reflectCallbackParamtypes(instance, methodName) {
      return Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, instance, methodName);
    }
    reflectCallbackMetadata(instance, methodName, metadataKey) {
      return Reflect.getMetadata(metadataKey, instance.constructor, methodName);
    }
    reflectPassthrough(instance, methodName) {
      return Reflect.getMetadata(constants_1.RESPONSE_PASSTHROUGH_METADATA, instance.constructor, methodName);
    }
    getArgumentsLength(keys, metadata2) {
      return keys.length ? Math.max(...keys.map((key) => metadata2[key].index)) + 1 : 0;
    }
    createNullArray(length) {
      const a = new Array(length);
      for (let i = 0; i < length; ++i)
        a[i] = void 0;
      return a;
    }
    mergeParamsMetatypes(paramsProperties, paramtypes) {
      if (!paramtypes) {
        return paramsProperties;
      }
      return paramsProperties.map((param) => Object.assign(Object.assign({}, param), { metatype: paramtypes[param.index] }));
    }
    getCustomFactory(factory2, data, contextFactory) {
      return (0, shared_utils_1.isFunction)(factory2) ? (...args2) => factory2(data, contextFactory(args2)) : () => null;
    }
    getContextFactory(contextType, instance, callback) {
      const contextFactory = (args2) => {
        const ctx = new execution_context_host_1.ExecutionContextHost(args2, instance && instance.constructor, callback);
        ctx.setType(contextType);
        return ctx;
      };
      return contextFactory;
    }
  }
  contextUtils.ContextUtils = ContextUtils;
  return contextUtils;
}
var externalProxy = {};
var hasRequiredExternalProxy;
function requireExternalProxy() {
  if (hasRequiredExternalProxy)
    return externalProxy;
  hasRequiredExternalProxy = 1;
  Object.defineProperty(externalProxy, "__esModule", { value: true });
  externalProxy.ExternalErrorProxy = void 0;
  const execution_context_host_1 = requireExecutionContextHost();
  class ExternalErrorProxy {
    createProxy(targetCallback, exceptionsHandler2, type2) {
      return async (...args2) => {
        try {
          return await targetCallback(...args2);
        } catch (e) {
          const host = new execution_context_host_1.ExecutionContextHost(args2);
          host.setType(type2);
          return exceptionsHandler2.next(e, host);
        }
      };
    }
  }
  externalProxy.ExternalErrorProxy = ExternalErrorProxy;
  return externalProxy;
}
var handlerMetadataStorage = {};
var hasRequiredHandlerMetadataStorage;
function requireHandlerMetadataStorage() {
  if (hasRequiredHandlerMetadataStorage)
    return handlerMetadataStorage;
  hasRequiredHandlerMetadataStorage = 1;
  (function(exports2) {
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HandlerMetadataStorage = exports2.HANDLER_METADATA_SYMBOL = void 0;
    const constants_1 = requireConstants$2();
    exports2.HANDLER_METADATA_SYMBOL = Symbol.for("handler_metadata:cache");
    class HandlerMetadataStorage {
      constructor() {
        this[_a] = /* @__PURE__ */ new Map();
      }
      set(controller, methodName, metadata2) {
        const metadataKey = this.getMetadataKey(controller, methodName);
        this[exports2.HANDLER_METADATA_SYMBOL].set(metadataKey, metadata2);
      }
      get(controller, methodName) {
        const metadataKey = this.getMetadataKey(controller, methodName);
        return this[exports2.HANDLER_METADATA_SYMBOL].get(metadataKey);
      }
      getMetadataKey(controller, methodName) {
        const ctor = controller.constructor;
        const controllerKey = ctor && (ctor[constants_1.CONTROLLER_ID_KEY] || ctor.name);
        return controllerKey + methodName;
      }
    }
    exports2.HandlerMetadataStorage = HandlerMetadataStorage;
    _a = exports2.HANDLER_METADATA_SYMBOL;
  })(handlerMetadataStorage);
  return handlerMetadataStorage;
}
var hasRequiredExternalContextCreator;
function requireExternalContextCreator() {
  if (hasRequiredExternalContextCreator)
    return externalContextCreator;
  hasRequiredExternalContextCreator = 1;
  Object.defineProperty(externalContextCreator, "__esModule", { value: true });
  externalContextCreator.ExternalContextCreator = void 0;
  const common_1 = requireCommon$3();
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const rxjs_1 = requireCjs();
  const external_exception_filter_context_1 = requireExternalExceptionFilterContext();
  const constants_2 = requireConstants$1();
  const guards_1 = requireGuards();
  const constants_3 = requireConstants$2();
  const interceptors_1 = requireInterceptors$1();
  const pipes_1 = requirePipes();
  const context_utils_1 = requireContextUtils();
  const external_proxy_1 = requireExternalProxy();
  const handler_metadata_storage_1 = requireHandlerMetadataStorage();
  class ExternalContextCreator {
    constructor(guardsContextCreator2, guardsConsumer2, interceptorsContextCreator2, interceptorsConsumer2, modulesContainer2, pipesContextCreator2, pipesConsumer2, filtersContextCreator) {
      this.guardsContextCreator = guardsContextCreator2;
      this.guardsConsumer = guardsConsumer2;
      this.interceptorsContextCreator = interceptorsContextCreator2;
      this.interceptorsConsumer = interceptorsConsumer2;
      this.modulesContainer = modulesContainer2;
      this.pipesContextCreator = pipesContextCreator2;
      this.pipesConsumer = pipesConsumer2;
      this.filtersContextCreator = filtersContextCreator;
      this.contextUtils = new context_utils_1.ContextUtils();
      this.externalErrorProxy = new external_proxy_1.ExternalErrorProxy();
      this.handlerMetadataStorage = new handler_metadata_storage_1.HandlerMetadataStorage();
    }
    static fromContainer(container2) {
      const guardsContextCreator2 = new guards_1.GuardsContextCreator(container2, container2.applicationConfig);
      const guardsConsumer2 = new guards_1.GuardsConsumer();
      const interceptorsContextCreator2 = new interceptors_1.InterceptorsContextCreator(container2, container2.applicationConfig);
      const interceptorsConsumer2 = new interceptors_1.InterceptorsConsumer();
      const pipesContextCreator2 = new pipes_1.PipesContextCreator(container2, container2.applicationConfig);
      const pipesConsumer2 = new pipes_1.PipesConsumer();
      const filtersContextCreator = new external_exception_filter_context_1.ExternalExceptionFilterContext(container2, container2.applicationConfig);
      const externalContextCreator2 = new ExternalContextCreator(guardsContextCreator2, guardsConsumer2, interceptorsContextCreator2, interceptorsConsumer2, container2.getModules(), pipesContextCreator2, pipesConsumer2, filtersContextCreator);
      externalContextCreator2.container = container2;
      return externalContextCreator2;
    }
    create(instance, callback, methodName, metadataKey, paramsFactory, contextId = constants_3.STATIC_CONTEXT, inquirerId, options = {
      interceptors: true,
      guards: true,
      filters: true
    }, contextType = "http") {
      const module2 = this.getContextModuleKey(instance.constructor);
      const { argsLength, paramtypes, getParamsMetadata } = this.getMetadata(instance, methodName, metadataKey, paramsFactory, contextType);
      const pipes2 = this.pipesContextCreator.create(instance, callback, module2, contextId, inquirerId);
      const guards2 = this.guardsContextCreator.create(instance, callback, module2, contextId, inquirerId);
      const exceptionFilter = this.filtersContextCreator.create(instance, callback, module2, contextId, inquirerId);
      const interceptors2 = options.interceptors ? this.interceptorsContextCreator.create(instance, callback, module2, contextId, inquirerId) : [];
      const paramsMetadata = getParamsMetadata(module2, contextId, inquirerId);
      const paramsOptions = paramsMetadata ? this.contextUtils.mergeParamsMetatypes(paramsMetadata, paramtypes) : [];
      const fnCanActivate = options.guards ? this.createGuardsFn(guards2, instance, callback, contextType) : null;
      const fnApplyPipes = this.createPipesFn(pipes2, paramsOptions);
      const handler = (initialArgs, ...args2) => async () => {
        if (fnApplyPipes) {
          await fnApplyPipes(initialArgs, ...args2);
          return callback.apply(instance, initialArgs);
        }
        return callback.apply(instance, args2);
      };
      const target = async (...args2) => {
        const initialArgs = this.contextUtils.createNullArray(argsLength);
        fnCanActivate && await fnCanActivate(args2);
        const result = await this.interceptorsConsumer.intercept(interceptors2, args2, instance, callback, handler(initialArgs, ...args2), contextType);
        return this.transformToResult(result);
      };
      return options.filters ? this.externalErrorProxy.createProxy(target, exceptionFilter, contextType) : target;
    }
    getMetadata(instance, methodName, metadataKey, paramsFactory, contextType) {
      const cacheMetadata = this.handlerMetadataStorage.get(instance, methodName);
      if (cacheMetadata) {
        return cacheMetadata;
      }
      const metadata2 = this.contextUtils.reflectCallbackMetadata(instance, methodName, metadataKey || "") || {};
      const keys = Object.keys(metadata2);
      const argsLength = this.contextUtils.getArgumentsLength(keys, metadata2);
      const paramtypes = this.contextUtils.reflectCallbackParamtypes(instance, methodName);
      const contextFactory = this.contextUtils.getContextFactory(contextType, instance, instance[methodName]);
      const getParamsMetadata = (moduleKey, contextId = constants_3.STATIC_CONTEXT, inquirerId) => paramsFactory ? this.exchangeKeysForValues(keys, metadata2, moduleKey, paramsFactory, contextId, inquirerId, contextFactory) : null;
      const handlerMetadata = {
        argsLength,
        paramtypes,
        getParamsMetadata
      };
      this.handlerMetadataStorage.set(instance, methodName, handlerMetadata);
      return handlerMetadata;
    }
    getContextModuleKey(moduleCtor) {
      const emptyModuleKey = "";
      if (!moduleCtor) {
        return emptyModuleKey;
      }
      const moduleContainerEntries = this.modulesContainer.entries();
      for (const [key, moduleRef2] of moduleContainerEntries) {
        if (moduleRef2.hasProvider(moduleCtor)) {
          return key;
        }
      }
      return emptyModuleKey;
    }
    exchangeKeysForValues(keys, metadata2, moduleContext, paramsFactory, contextId = constants_3.STATIC_CONTEXT, inquirerId, contextFactory = this.contextUtils.getContextFactory("http")) {
      this.pipesContextCreator.setModuleContext(moduleContext);
      return keys.map((key) => {
        const { index, data, pipes: pipesCollection } = metadata2[key];
        const pipes2 = this.pipesContextCreator.createConcreteContext(pipesCollection, contextId, inquirerId);
        const type2 = this.contextUtils.mapParamType(key);
        if (key.includes(constants_1.CUSTOM_ROUTE_ARGS_METADATA)) {
          const { factory: factory2 } = metadata2[key];
          const customExtractValue = this.contextUtils.getCustomFactory(factory2, data, contextFactory);
          return { index, extractValue: customExtractValue, type: type2, data, pipes: pipes2 };
        }
        const numericType = Number(type2);
        const extractValue = (...args2) => paramsFactory.exchangeKeyForValue(numericType, data, args2);
        return { index, extractValue, type: numericType, data, pipes: pipes2 };
      });
    }
    createPipesFn(pipes2, paramsOptions) {
      const pipesFn = async (args2, ...params) => {
        const resolveParamValue = async (param) => {
          const { index, extractValue, type: type2, data, metatype, pipes: paramPipes } = param;
          const value = extractValue(...params);
          args2[index] = await this.getParamValue(value, { metatype, type: type2, data }, pipes2.concat(paramPipes));
        };
        await Promise.all(paramsOptions.map(resolveParamValue));
      };
      return paramsOptions.length ? pipesFn : null;
    }
    async getParamValue(value, { metatype, type: type2, data }, pipes2) {
      return (0, shared_utils_1.isEmpty)(pipes2) ? value : this.pipesConsumer.apply(value, { metatype, type: type2, data }, pipes2);
    }
    async transformToResult(resultOrDeferred) {
      if ((0, rxjs_1.isObservable)(resultOrDeferred)) {
        return (0, rxjs_1.lastValueFrom)(resultOrDeferred);
      }
      return resultOrDeferred;
    }
    createGuardsFn(guards2, instance, callback, contextType) {
      const canActivateFn = async (args2) => {
        const canActivate = await this.guardsConsumer.tryActivate(guards2, args2, instance, callback, contextType);
        if (!canActivate) {
          throw new common_1.ForbiddenException(constants_2.FORBIDDEN_MESSAGE);
        }
      };
      return guards2.length ? canActivateFn : null;
    }
    registerRequestProvider(request2, contextId) {
      this.container.registerRequestProvider(request2, contextId);
    }
  }
  externalContextCreator.ExternalContextCreator = ExternalContextCreator;
  return externalContextCreator;
}
var hasRequiredHelpers;
function requireHelpers() {
  if (hasRequiredHelpers)
    return helpers;
  hasRequiredHelpers = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireContextIdFactory(), exports2);
    tslib_1.__exportStar(requireExternalContextCreator(), exports2);
    tslib_1.__exportStar(requireHttpAdapterHost(), exports2);
  })(helpers);
  return helpers;
}
var injector$1 = {};
var container$1 = {};
var exceptions = {};
var circularDependency_exception = {};
var hasRequiredCircularDependency_exception;
function requireCircularDependency_exception() {
  if (hasRequiredCircularDependency_exception)
    return circularDependency_exception;
  hasRequiredCircularDependency_exception = 1;
  Object.defineProperty(circularDependency_exception, "__esModule", { value: true });
  circularDependency_exception.CircularDependencyException = void 0;
  const runtime_exception_1 = requireRuntime_exception();
  class CircularDependencyException extends runtime_exception_1.RuntimeException {
    constructor(context) {
      const ctx = context ? ` inside ${context}` : ``;
      super(`A circular dependency has been detected${ctx}. Please, make sure that each side of a bidirectional relationships are decorated with "forwardRef()".`);
    }
  }
  circularDependency_exception.CircularDependencyException = CircularDependencyException;
  return circularDependency_exception;
}
var unknownElement_exception = {};
var hasRequiredUnknownElement_exception;
function requireUnknownElement_exception() {
  if (hasRequiredUnknownElement_exception)
    return unknownElement_exception;
  hasRequiredUnknownElement_exception = 1;
  Object.defineProperty(unknownElement_exception, "__esModule", { value: true });
  unknownElement_exception.UnknownElementException = void 0;
  const runtime_exception_1 = requireRuntime_exception();
  class UnknownElementException extends runtime_exception_1.RuntimeException {
    constructor(name) {
      name = name && name.toString();
      super(`Nest could not find ${name || "given"} element (this provider does not exist in the current context)`);
    }
  }
  unknownElement_exception.UnknownElementException = UnknownElementException;
  return unknownElement_exception;
}
var invalidClassScope_exception = {};
var hasRequiredInvalidClassScope_exception;
function requireInvalidClassScope_exception() {
  if (hasRequiredInvalidClassScope_exception)
    return invalidClassScope_exception;
  hasRequiredInvalidClassScope_exception = 1;
  Object.defineProperty(invalidClassScope_exception, "__esModule", { value: true });
  invalidClassScope_exception.InvalidClassScopeException = void 0;
  const shared_utils_1 = requireShared_utils();
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class InvalidClassScopeException extends runtime_exception_1.RuntimeException {
    constructor(metatypeOrToken) {
      let name = (0, shared_utils_1.isFunction)(metatypeOrToken) ? metatypeOrToken.name : metatypeOrToken;
      name = name && name.toString();
      super((0, messages_1.INVALID_CLASS_SCOPE_MESSAGE)`${name}`);
    }
  }
  invalidClassScope_exception.InvalidClassScopeException = InvalidClassScopeException;
  return invalidClassScope_exception;
}
var invalidClass_exception = {};
var hasRequiredInvalidClass_exception;
function requireInvalidClass_exception() {
  if (hasRequiredInvalidClass_exception)
    return invalidClass_exception;
  hasRequiredInvalidClass_exception = 1;
  Object.defineProperty(invalidClass_exception, "__esModule", { value: true });
  invalidClass_exception.InvalidClassException = void 0;
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class InvalidClassException extends runtime_exception_1.RuntimeException {
    constructor(value) {
      super((0, messages_1.INVALID_CLASS_MESSAGE)`${value}`);
    }
  }
  invalidClass_exception.InvalidClassException = InvalidClassException;
  return invalidClass_exception;
}
var unknownExport_exception = {};
var hasRequiredUnknownExport_exception;
function requireUnknownExport_exception() {
  if (hasRequiredUnknownExport_exception)
    return unknownExport_exception;
  hasRequiredUnknownExport_exception = 1;
  Object.defineProperty(unknownExport_exception, "__esModule", { value: true });
  unknownExport_exception.UnknownExportException = void 0;
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class UnknownExportException extends runtime_exception_1.RuntimeException {
    constructor(token, moduleName) {
      super((0, messages_1.UNKNOWN_EXPORT_MESSAGE)(token, moduleName));
    }
  }
  unknownExport_exception.UnknownExportException = UnknownExportException;
  return unknownExport_exception;
}
var unknownModule_exception = {};
var hasRequiredUnknownModule_exception;
function requireUnknownModule_exception() {
  if (hasRequiredUnknownModule_exception)
    return unknownModule_exception;
  hasRequiredUnknownModule_exception = 1;
  Object.defineProperty(unknownModule_exception, "__esModule", { value: true });
  unknownModule_exception.UnknownModuleException = void 0;
  const runtime_exception_1 = requireRuntime_exception();
  class UnknownModuleException extends runtime_exception_1.RuntimeException {
    constructor() {
      super("Nest could not select the given module (it does not exist in current context)");
    }
  }
  unknownModule_exception.UnknownModuleException = UnknownModuleException;
  return unknownModule_exception;
}
var undefinedForwardref_exception = {};
var hasRequiredUndefinedForwardref_exception;
function requireUndefinedForwardref_exception() {
  if (hasRequiredUndefinedForwardref_exception)
    return undefinedForwardref_exception;
  hasRequiredUndefinedForwardref_exception = 1;
  Object.defineProperty(undefinedForwardref_exception, "__esModule", { value: true });
  undefinedForwardref_exception.UndefinedForwardRefException = void 0;
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class UndefinedForwardRefException extends runtime_exception_1.RuntimeException {
    constructor(scope2) {
      super((0, messages_1.UNDEFINED_FORWARDREF_MESSAGE)(scope2));
    }
  }
  undefinedForwardref_exception.UndefinedForwardRefException = UndefinedForwardRefException;
  return undefinedForwardref_exception;
}
var hasRequiredExceptions;
function requireExceptions() {
  if (hasRequiredExceptions)
    return exceptions;
  hasRequiredExceptions = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireCircularDependency_exception(), exports2);
    tslib_1.__exportStar(requireRuntime_exception(), exports2);
    tslib_1.__exportStar(requireUnknownElement_exception(), exports2);
    tslib_1.__exportStar(requireInvalidClassScope_exception(), exports2);
    tslib_1.__exportStar(requireInvalidClass_exception(), exports2);
    tslib_1.__exportStar(requireUnknownExport_exception(), exports2);
    tslib_1.__exportStar(requireUnknownModule_exception(), exports2);
    tslib_1.__exportStar(requireUndefinedForwardref_exception(), exports2);
  })(exceptions);
  return exceptions;
}
var initializeOnPreview_allowlist = {};
var hasRequiredInitializeOnPreview_allowlist;
function requireInitializeOnPreview_allowlist() {
  if (hasRequiredInitializeOnPreview_allowlist)
    return initializeOnPreview_allowlist;
  hasRequiredInitializeOnPreview_allowlist = 1;
  Object.defineProperty(initializeOnPreview_allowlist, "__esModule", { value: true });
  initializeOnPreview_allowlist.InitializeOnPreviewAllowlist = void 0;
  class InitializeOnPreviewAllowlist {
    static add(type2) {
      this.allowlist.set(type2, true);
    }
    static has(type2) {
      return this.allowlist.has(type2);
    }
  }
  InitializeOnPreviewAllowlist.allowlist = /* @__PURE__ */ new WeakMap();
  initializeOnPreview_allowlist.InitializeOnPreviewAllowlist = InitializeOnPreviewAllowlist;
  return initializeOnPreview_allowlist;
}
var serializedGraph = {};
var inquirerConstants = {};
var hasRequiredInquirerConstants;
function requireInquirerConstants() {
  if (hasRequiredInquirerConstants)
    return inquirerConstants;
  hasRequiredInquirerConstants = 1;
  Object.defineProperty(inquirerConstants, "__esModule", { value: true });
  inquirerConstants.INQUIRER = void 0;
  inquirerConstants.INQUIRER = "INQUIRER";
  return inquirerConstants;
}
var lazyModuleLoader = {};
var silentLogger = {};
var hasRequiredSilentLogger;
function requireSilentLogger() {
  if (hasRequiredSilentLogger)
    return silentLogger;
  hasRequiredSilentLogger = 1;
  Object.defineProperty(silentLogger, "__esModule", { value: true });
  silentLogger.SilentLogger = void 0;
  const common_1 = requireCommon$3();
  const noop2 = () => {
  };
  class SilentLogger extends common_1.Logger {
    constructor() {
      super(...arguments);
      this.log = noop2;
      this.error = noop2;
      this.warn = noop2;
      this.debug = noop2;
      this.verbose = noop2;
      this.setLogLevels = noop2;
    }
  }
  silentLogger.SilentLogger = SilentLogger;
  return silentLogger;
}
var moduleRef = {};
var getClassScope = {};
var hasRequiredGetClassScope;
function requireGetClassScope() {
  if (hasRequiredGetClassScope)
    return getClassScope;
  hasRequiredGetClassScope = 1;
  Object.defineProperty(getClassScope, "__esModule", { value: true });
  getClassScope.getClassScope = void 0;
  const constants_1 = requireConstants$4();
  function getClassScope$1(provider) {
    const metadata2 = Reflect.getMetadata(constants_1.SCOPE_OPTIONS_METADATA, provider);
    return metadata2 && metadata2.scope;
  }
  getClassScope.getClassScope = getClassScope$1;
  return getClassScope;
}
var isDurable = {};
var hasRequiredIsDurable;
function requireIsDurable() {
  if (hasRequiredIsDurable)
    return isDurable;
  hasRequiredIsDurable = 1;
  Object.defineProperty(isDurable, "__esModule", { value: true });
  isDurable.isDurable = void 0;
  const constants_1 = requireConstants$4();
  function isDurable$1(provider) {
    const metadata2 = Reflect.getMetadata(constants_1.SCOPE_OPTIONS_METADATA, provider);
    return metadata2 && metadata2.durable;
  }
  isDurable.isDurable = isDurable$1;
  return isDurable;
}
var abstractInstanceResolver = {};
var hasRequiredAbstractInstanceResolver;
function requireAbstractInstanceResolver() {
  if (hasRequiredAbstractInstanceResolver)
    return abstractInstanceResolver;
  hasRequiredAbstractInstanceResolver = 1;
  Object.defineProperty(abstractInstanceResolver, "__esModule", { value: true });
  abstractInstanceResolver.AbstractInstanceResolver = void 0;
  const common_1 = requireCommon$3();
  const exceptions_1 = requireExceptions();
  class AbstractInstanceResolver {
    find(typeOrToken, options) {
      const instanceLinkOrArray = this.instanceLinksHost.get(typeOrToken, options);
      const pluckInstance = ({ wrapperRef }) => {
        if (wrapperRef.scope === common_1.Scope.REQUEST || wrapperRef.scope === common_1.Scope.TRANSIENT) {
          throw new exceptions_1.InvalidClassScopeException(typeOrToken);
        }
        return wrapperRef.instance;
      };
      if (Array.isArray(instanceLinkOrArray)) {
        return instanceLinkOrArray.map(pluckInstance);
      }
      return pluckInstance(instanceLinkOrArray);
    }
    async resolvePerContext(typeOrToken, contextModule, contextId, options) {
      const instanceLinkOrArray = (options === null || options === void 0 ? void 0 : options.strict) ? this.instanceLinksHost.get(typeOrToken, {
        moduleId: contextModule.id,
        each: options.each
      }) : this.instanceLinksHost.get(typeOrToken, {
        each: options.each
      });
      const pluckInstance = async (instanceLink) => {
        const { wrapperRef, collection } = instanceLink;
        if (wrapperRef.isDependencyTreeStatic() && !wrapperRef.isTransient) {
          return this.get(typeOrToken, { strict: options.strict });
        }
        const ctorHost = wrapperRef.instance || { constructor: typeOrToken };
        const instance = await this.injector.loadPerContext(ctorHost, wrapperRef.host, collection, contextId, wrapperRef);
        if (!instance) {
          throw new exceptions_1.UnknownElementException();
        }
        return instance;
      };
      if (Array.isArray(instanceLinkOrArray)) {
        return Promise.all(instanceLinkOrArray.map((instanceLink) => pluckInstance(instanceLink)));
      }
      return pluckInstance(instanceLinkOrArray);
    }
  }
  abstractInstanceResolver.AbstractInstanceResolver = AbstractInstanceResolver;
  return abstractInstanceResolver;
}
var injector = {};
var undefinedDependency_exception = {};
var hasRequiredUndefinedDependency_exception;
function requireUndefinedDependency_exception() {
  if (hasRequiredUndefinedDependency_exception)
    return undefinedDependency_exception;
  hasRequiredUndefinedDependency_exception = 1;
  Object.defineProperty(undefinedDependency_exception, "__esModule", { value: true });
  undefinedDependency_exception.UndefinedDependencyException = void 0;
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class UndefinedDependencyException extends runtime_exception_1.RuntimeException {
    constructor(type2, undefinedDependencyContext, module2) {
      super((0, messages_1.UNKNOWN_DEPENDENCIES_MESSAGE)(type2, undefinedDependencyContext, module2));
    }
  }
  undefinedDependency_exception.UndefinedDependencyException = UndefinedDependencyException;
  return undefinedDependency_exception;
}
var unknownDependencies_exception = {};
var hasRequiredUnknownDependencies_exception;
function requireUnknownDependencies_exception() {
  if (hasRequiredUnknownDependencies_exception)
    return unknownDependencies_exception;
  hasRequiredUnknownDependencies_exception = 1;
  Object.defineProperty(unknownDependencies_exception, "__esModule", { value: true });
  unknownDependencies_exception.UnknownDependenciesException = void 0;
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class UnknownDependenciesException extends runtime_exception_1.RuntimeException {
    constructor(type2, context, moduleRef2, metadata2) {
      super((0, messages_1.UNKNOWN_DEPENDENCIES_MESSAGE)(type2, context, moduleRef2));
      this.type = type2;
      this.context = context;
      this.metadata = metadata2;
      this.moduleRef = moduleRef2 && { id: moduleRef2.id };
    }
  }
  unknownDependencies_exception.UnknownDependenciesException = UnknownDependenciesException;
  return unknownDependencies_exception;
}
var inquirer = {};
var hasRequiredInquirer;
function requireInquirer() {
  if (hasRequiredInquirer)
    return inquirer;
  hasRequiredInquirer = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireInquirerConstants(), exports2);
  })(inquirer);
  return inquirer;
}
var instanceWrapper = {};
var uuidFactory = {};
var deterministicUuidRegistry = {};
var hasRequiredDeterministicUuidRegistry;
function requireDeterministicUuidRegistry() {
  if (hasRequiredDeterministicUuidRegistry)
    return deterministicUuidRegistry;
  hasRequiredDeterministicUuidRegistry = 1;
  Object.defineProperty(deterministicUuidRegistry, "__esModule", { value: true });
  deterministicUuidRegistry.DeterministicUuidRegistry = void 0;
  class DeterministicUuidRegistry {
    static get(str, inc2 = 0) {
      const id2 = inc2 ? this.hashCode(`${str}_${inc2}`) : this.hashCode(str);
      if (this.registry.has(id2)) {
        return this.get(str, inc2 + 1);
      }
      this.registry.set(id2, true);
      return id2;
    }
    static clear() {
      this.registry.clear();
    }
    static hashCode(s) {
      let h = 0;
      for (let i = 0; i < s.length; i++)
        h = Math.imul(31, h) + s.charCodeAt(i) | 0;
      return h.toString();
    }
  }
  DeterministicUuidRegistry.registry = /* @__PURE__ */ new Map();
  deterministicUuidRegistry.DeterministicUuidRegistry = DeterministicUuidRegistry;
  return deterministicUuidRegistry;
}
var hasRequiredUuidFactory;
function requireUuidFactory() {
  if (hasRequiredUuidFactory)
    return uuidFactory;
  hasRequiredUuidFactory = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UuidFactory = exports2.UuidFactoryMode = void 0;
    const random_string_generator_util_1 = requireRandomStringGenerator_util();
    const deterministic_uuid_registry_1 = requireDeterministicUuidRegistry();
    var UuidFactoryMode;
    (function(UuidFactoryMode2) {
      UuidFactoryMode2["Random"] = "random";
      UuidFactoryMode2["Deterministic"] = "deterministic";
    })(UuidFactoryMode = exports2.UuidFactoryMode || (exports2.UuidFactoryMode = {}));
    class UuidFactory {
      static set mode(value) {
        this._mode = value;
      }
      static get(key = "") {
        return this._mode === UuidFactoryMode.Deterministic ? deterministic_uuid_registry_1.DeterministicUuidRegistry.get(key) : (0, random_string_generator_util_1.randomStringGenerator)();
      }
    }
    UuidFactory._mode = UuidFactoryMode.Random;
    exports2.UuidFactory = UuidFactory;
  })(uuidFactory);
  return uuidFactory;
}
var providerClassifier = {};
var hasRequiredProviderClassifier;
function requireProviderClassifier() {
  if (hasRequiredProviderClassifier)
    return providerClassifier;
  hasRequiredProviderClassifier = 1;
  Object.defineProperty(providerClassifier, "__esModule", { value: true });
  providerClassifier.isFactoryProvider = providerClassifier.isValueProvider = providerClassifier.isClassProvider = void 0;
  const shared_utils_1 = requireShared_utils();
  function isClassProvider(provider) {
    return Boolean(provider === null || provider === void 0 ? void 0 : provider.useClass);
  }
  providerClassifier.isClassProvider = isClassProvider;
  function isValueProvider(provider) {
    const providerValue = provider === null || provider === void 0 ? void 0 : provider.useValue;
    return !(0, shared_utils_1.isUndefined)(providerValue);
  }
  providerClassifier.isValueProvider = isValueProvider;
  function isFactoryProvider(provider) {
    return Boolean(provider.useFactory);
  }
  providerClassifier.isFactoryProvider = isFactoryProvider;
  return providerClassifier;
}
var hasRequiredInstanceWrapper;
function requireInstanceWrapper() {
  if (hasRequiredInstanceWrapper)
    return instanceWrapper;
  hasRequiredInstanceWrapper = 1;
  (function(exports2) {
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InstanceWrapper = exports2.INSTANCE_ID_SYMBOL = exports2.INSTANCE_METADATA_SYMBOL = void 0;
    const tslib_1 = require$$0$3;
    const common_1 = requireCommon$3();
    const cli_colors_util_1 = requireCliColors_util();
    const random_string_generator_util_1 = requireRandomStringGenerator_util();
    const shared_utils_1 = requireShared_utils();
    const iterare_1 = requireLib$4();
    const uuid_factory_1 = requireUuidFactory();
    const constants_1 = requireConstants$2();
    const provider_classifier_1 = requireProviderClassifier();
    exports2.INSTANCE_METADATA_SYMBOL = Symbol.for("instance_metadata:cache");
    exports2.INSTANCE_ID_SYMBOL = Symbol.for("instance_metadata:id");
    class InstanceWrapper {
      constructor(metadata2 = {}) {
        var _b;
        this.isAlias = false;
        this.scope = common_1.Scope.DEFAULT;
        this.values = /* @__PURE__ */ new WeakMap();
        this[_a] = {};
        this.initialize(metadata2);
        this[exports2.INSTANCE_ID_SYMBOL] = (_b = metadata2[exports2.INSTANCE_ID_SYMBOL]) !== null && _b !== void 0 ? _b : this.generateUuid();
      }
      get id() {
        return this[exports2.INSTANCE_ID_SYMBOL];
      }
      set instance(value) {
        this.values.set(constants_1.STATIC_CONTEXT, { instance: value });
      }
      get instance() {
        const instancePerContext = this.getInstanceByContextId(constants_1.STATIC_CONTEXT);
        return instancePerContext.instance;
      }
      get isNotMetatype() {
        const isFactory = this.metatype && !(0, shared_utils_1.isNil)(this.inject);
        return !this.metatype || isFactory;
      }
      get isTransient() {
        return this.scope === common_1.Scope.TRANSIENT;
      }
      getInstanceByContextId(contextId, inquirerId) {
        if (this.scope === common_1.Scope.TRANSIENT && inquirerId) {
          return this.getInstanceByInquirerId(contextId, inquirerId);
        }
        const instancePerContext = this.values.get(contextId);
        return instancePerContext ? instancePerContext : this.cloneStaticInstance(contextId);
      }
      getInstanceByInquirerId(contextId, inquirerId) {
        let collectionPerContext = this.transientMap.get(inquirerId);
        if (!collectionPerContext) {
          collectionPerContext = /* @__PURE__ */ new WeakMap();
          this.transientMap.set(inquirerId, collectionPerContext);
        }
        const instancePerContext = collectionPerContext.get(contextId);
        return instancePerContext ? instancePerContext : this.cloneTransientInstance(contextId, inquirerId);
      }
      setInstanceByContextId(contextId, value, inquirerId) {
        if (this.scope === common_1.Scope.TRANSIENT && inquirerId) {
          return this.setInstanceByInquirerId(contextId, inquirerId, value);
        }
        this.values.set(contextId, value);
      }
      setInstanceByInquirerId(contextId, inquirerId, value) {
        let collection = this.transientMap.get(inquirerId);
        if (!collection) {
          collection = /* @__PURE__ */ new WeakMap();
          this.transientMap.set(inquirerId, collection);
        }
        collection.set(contextId, value);
      }
      addCtorMetadata(index, wrapper) {
        if (!this[exports2.INSTANCE_METADATA_SYMBOL].dependencies) {
          this[exports2.INSTANCE_METADATA_SYMBOL].dependencies = [];
        }
        this[exports2.INSTANCE_METADATA_SYMBOL].dependencies[index] = wrapper;
      }
      getCtorMetadata() {
        return this[exports2.INSTANCE_METADATA_SYMBOL].dependencies;
      }
      addPropertiesMetadata(key, wrapper) {
        if (!this[exports2.INSTANCE_METADATA_SYMBOL].properties) {
          this[exports2.INSTANCE_METADATA_SYMBOL].properties = [];
        }
        this[exports2.INSTANCE_METADATA_SYMBOL].properties.push({
          key,
          wrapper
        });
      }
      getPropertiesMetadata() {
        return this[exports2.INSTANCE_METADATA_SYMBOL].properties;
      }
      addEnhancerMetadata(wrapper) {
        if (!this[exports2.INSTANCE_METADATA_SYMBOL].enhancers) {
          this[exports2.INSTANCE_METADATA_SYMBOL].enhancers = [];
        }
        this[exports2.INSTANCE_METADATA_SYMBOL].enhancers.push(wrapper);
      }
      getEnhancersMetadata() {
        return this[exports2.INSTANCE_METADATA_SYMBOL].enhancers;
      }
      isDependencyTreeDurable(lookupRegistry = []) {
        if (!(0, shared_utils_1.isUndefined)(this.isTreeDurable)) {
          return this.isTreeDurable;
        }
        if (this.scope === common_1.Scope.REQUEST) {
          this.isTreeDurable = this.durable === void 0 ? false : this.durable;
          if (this.isTreeDurable) {
            this.printIntrospectedAsDurable();
          }
          return this.isTreeDurable;
        }
        const isStatic = this.isDependencyTreeStatic();
        if (isStatic) {
          return false;
        }
        const isTreeNonDurable = this.introspectDepsAttribute((collection, registry) => collection.some((item) => !item.isDependencyTreeStatic() && !item.isDependencyTreeDurable(registry)), lookupRegistry);
        this.isTreeDurable = !isTreeNonDurable;
        if (this.isTreeDurable) {
          this.printIntrospectedAsDurable();
        }
        return this.isTreeDurable;
      }
      introspectDepsAttribute(callback, lookupRegistry = []) {
        if (lookupRegistry.includes(this[exports2.INSTANCE_ID_SYMBOL])) {
          return false;
        }
        lookupRegistry = lookupRegistry.concat(this[exports2.INSTANCE_ID_SYMBOL]);
        const { dependencies: dependencies2, properties: properties2, enhancers } = this[exports2.INSTANCE_METADATA_SYMBOL];
        let introspectionResult = dependencies2 ? callback(dependencies2, lookupRegistry) : false;
        if (introspectionResult || !(properties2 || enhancers)) {
          return introspectionResult;
        }
        introspectionResult = properties2 ? callback(properties2.map((item) => item.wrapper), lookupRegistry) : false;
        if (introspectionResult || !enhancers) {
          return introspectionResult;
        }
        return enhancers ? callback(enhancers, lookupRegistry) : false;
      }
      isDependencyTreeStatic(lookupRegistry = []) {
        if (!(0, shared_utils_1.isUndefined)(this.isTreeStatic)) {
          return this.isTreeStatic;
        }
        if (this.scope === common_1.Scope.REQUEST) {
          this.isTreeStatic = false;
          this.printIntrospectedAsRequestScoped();
          return this.isTreeStatic;
        }
        this.isTreeStatic = !this.introspectDepsAttribute((collection, registry) => collection.some((item) => !item.isDependencyTreeStatic(registry)), lookupRegistry);
        if (!this.isTreeStatic) {
          this.printIntrospectedAsRequestScoped();
        }
        return this.isTreeStatic;
      }
      cloneStaticInstance(contextId) {
        const staticInstance = this.getInstanceByContextId(constants_1.STATIC_CONTEXT);
        if (this.isDependencyTreeStatic()) {
          return staticInstance;
        }
        const instancePerContext = Object.assign(Object.assign({}, staticInstance), { instance: void 0, isResolved: false, isPending: false });
        if (this.isNewable()) {
          instancePerContext.instance = Object.create(this.metatype.prototype);
        }
        this.setInstanceByContextId(contextId, instancePerContext);
        return instancePerContext;
      }
      cloneTransientInstance(contextId, inquirerId) {
        const staticInstance = this.getInstanceByContextId(constants_1.STATIC_CONTEXT);
        const instancePerContext = Object.assign(Object.assign({}, staticInstance), { instance: void 0, isResolved: false, isPending: false });
        if (this.isNewable()) {
          instancePerContext.instance = Object.create(this.metatype.prototype);
        }
        this.setInstanceByInquirerId(contextId, inquirerId, instancePerContext);
        return instancePerContext;
      }
      createPrototype(contextId) {
        const host = this.getInstanceByContextId(contextId);
        if (!this.isNewable() || host.isResolved) {
          return;
        }
        return Object.create(this.metatype.prototype);
      }
      isInRequestScope(contextId, inquirer2) {
        const isDependencyTreeStatic = this.isDependencyTreeStatic();
        return !isDependencyTreeStatic && contextId !== constants_1.STATIC_CONTEXT && (!this.isTransient || this.isTransient && !!inquirer2);
      }
      isLazyTransient(contextId, inquirer2) {
        const isInquirerRequestScoped = inquirer2 && !inquirer2.isDependencyTreeStatic();
        return this.isDependencyTreeStatic() && contextId !== constants_1.STATIC_CONTEXT && this.isTransient && isInquirerRequestScoped;
      }
      isExplicitlyRequested(contextId, inquirer2) {
        const isSelfRequested = inquirer2 === this;
        return this.isDependencyTreeStatic() && contextId !== constants_1.STATIC_CONTEXT && (isSelfRequested || inquirer2 && inquirer2.scope === common_1.Scope.TRANSIENT);
      }
      isStatic(contextId, inquirer2) {
        const isInquirerRequestScoped = inquirer2 && !inquirer2.isDependencyTreeStatic();
        const isStaticTransient = this.isTransient && !isInquirerRequestScoped;
        return this.isDependencyTreeStatic() && contextId === constants_1.STATIC_CONTEXT && (!this.isTransient || isStaticTransient && !!inquirer2 && !inquirer2.isTransient);
      }
      getStaticTransientInstances() {
        if (!this.transientMap) {
          return [];
        }
        const instances = [...this.transientMap.values()];
        return (0, iterare_1.iterate)(instances).map((item) => item.get(constants_1.STATIC_CONTEXT)).filter((item) => !!item).toArray();
      }
      mergeWith(provider) {
        if ((0, provider_classifier_1.isValueProvider)(provider)) {
          this.metatype = null;
          this.inject = null;
          this.scope = common_1.Scope.DEFAULT;
          this.setInstanceByContextId(constants_1.STATIC_CONTEXT, {
            instance: provider.useValue,
            isResolved: true,
            isPending: false
          });
        } else if ((0, provider_classifier_1.isClassProvider)(provider)) {
          this.inject = null;
          this.metatype = provider.useClass;
        } else if ((0, provider_classifier_1.isFactoryProvider)(provider)) {
          this.metatype = provider.useFactory;
          this.inject = provider.inject || [];
        }
      }
      isNewable() {
        return (0, shared_utils_1.isNil)(this.inject) && this.metatype && this.metatype.prototype;
      }
      initialize(metadata2) {
        const { instance, isResolved } = metadata2, wrapperPartial = tslib_1.__rest(metadata2, ["instance", "isResolved"]);
        Object.assign(this, wrapperPartial);
        this.setInstanceByContextId(constants_1.STATIC_CONTEXT, {
          instance,
          isResolved
        });
        this.scope === common_1.Scope.TRANSIENT && (this.transientMap = /* @__PURE__ */ new Map());
      }
      printIntrospectedAsRequestScoped() {
        if (!this.isDebugMode() || this.name === "REQUEST") {
          return;
        }
        if ((0, shared_utils_1.isString)(this.name)) {
          InstanceWrapper.logger.log(`${cli_colors_util_1.clc.cyanBright(this.name)}${cli_colors_util_1.clc.green(" introspected as ")}${cli_colors_util_1.clc.magentaBright("request-scoped")}`);
        }
      }
      printIntrospectedAsDurable() {
        if (!this.isDebugMode()) {
          return;
        }
        if ((0, shared_utils_1.isString)(this.name)) {
          InstanceWrapper.logger.log(`${cli_colors_util_1.clc.cyanBright(this.name)}${cli_colors_util_1.clc.green(" introspected as ")}${cli_colors_util_1.clc.magentaBright("durable")}`);
        }
      }
      isDebugMode() {
        return !!process.env.NEST_DEBUG;
      }
      generateUuid() {
        var _b, _c, _d, _e, _f;
        let key = (_c = (_b = this.name) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : (_d = this.token) === null || _d === void 0 ? void 0 : _d.toString();
        key += (_f = (_e = this.host) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0 ? _f : "";
        return key ? uuid_factory_1.UuidFactory.get(key) : (0, random_string_generator_util_1.randomStringGenerator)();
      }
    }
    _a = exports2.INSTANCE_METADATA_SYMBOL;
    InstanceWrapper.logger = new common_1.Logger(InstanceWrapper.name);
    exports2.InstanceWrapper = InstanceWrapper;
  })(instanceWrapper);
  return instanceWrapper;
}
var hasRequiredInjector$1;
function requireInjector$1() {
  if (hasRequiredInjector$1)
    return injector;
  hasRequiredInjector$1 = 1;
  Object.defineProperty(injector, "__esModule", { value: true });
  injector.Injector = void 0;
  const common_1 = requireCommon$3();
  const constants_1 = requireConstants$4();
  const cli_colors_util_1 = requireCliColors_util();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const perf_hooks_1 = require$$5$1;
  const runtime_exception_1 = requireRuntime_exception();
  const undefined_dependency_exception_1 = requireUndefinedDependency_exception();
  const unknown_dependencies_exception_1 = requireUnknownDependencies_exception();
  const constants_2 = requireConstants$2();
  const inquirer_1 = requireInquirer();
  const instance_wrapper_1 = requireInstanceWrapper();
  class Injector {
    constructor(options) {
      this.options = options;
      this.logger = new common_1.Logger("InjectorLogger");
    }
    loadPrototype({ token }, collection, contextId = constants_2.STATIC_CONTEXT) {
      if (!collection) {
        return;
      }
      const target = collection.get(token);
      const instance = target.createPrototype(contextId);
      if (instance) {
        const wrapper = new instance_wrapper_1.InstanceWrapper(Object.assign(Object.assign({}, target), { instance }));
        collection.set(token, wrapper);
      }
    }
    async loadInstance(wrapper, collection, moduleRef2, contextId = constants_2.STATIC_CONTEXT, inquirer2) {
      const inquirerId = this.getInquirerId(inquirer2);
      const instanceHost = wrapper.getInstanceByContextId(this.getContextId(contextId, wrapper), inquirerId);
      if (instanceHost.isPending) {
        return instanceHost.donePromise.then((err) => {
          if (err) {
            throw err;
          }
        });
      }
      const done = this.applyDoneHook(instanceHost);
      const token = wrapper.token || wrapper.name;
      const { inject } = wrapper;
      const targetWrapper = collection.get(token);
      if ((0, shared_utils_1.isUndefined)(targetWrapper)) {
        throw new runtime_exception_1.RuntimeException();
      }
      if (instanceHost.isResolved) {
        return done();
      }
      try {
        const t0 = this.getNowTimestamp();
        const callback = async (instances) => {
          const properties2 = await this.resolveProperties(wrapper, moduleRef2, inject, contextId, wrapper, inquirer2);
          const instance = await this.instantiateClass(instances, wrapper, targetWrapper, contextId, inquirer2);
          this.applyProperties(instance, properties2);
          wrapper.initTime = this.getNowTimestamp() - t0;
          done();
        };
        await this.resolveConstructorParams(wrapper, moduleRef2, inject, callback, contextId, wrapper, inquirer2);
      } catch (err) {
        done(err);
        throw err;
      }
    }
    async loadMiddleware(wrapper, collection, moduleRef2, contextId = constants_2.STATIC_CONTEXT, inquirer2) {
      const { metatype, token } = wrapper;
      const targetWrapper = collection.get(token);
      if (!(0, shared_utils_1.isUndefined)(targetWrapper.instance)) {
        return;
      }
      targetWrapper.instance = Object.create(metatype.prototype);
      await this.loadInstance(wrapper, collection, moduleRef2, contextId, inquirer2 || wrapper);
    }
    async loadController(wrapper, moduleRef2, contextId = constants_2.STATIC_CONTEXT) {
      const controllers = moduleRef2.controllers;
      await this.loadInstance(wrapper, controllers, moduleRef2, contextId, wrapper);
      await this.loadEnhancersPerContext(wrapper, contextId, wrapper);
    }
    async loadInjectable(wrapper, moduleRef2, contextId = constants_2.STATIC_CONTEXT, inquirer2) {
      const injectables = moduleRef2.injectables;
      await this.loadInstance(wrapper, injectables, moduleRef2, contextId, inquirer2);
    }
    async loadProvider(wrapper, moduleRef2, contextId = constants_2.STATIC_CONTEXT, inquirer2) {
      const providers = moduleRef2.providers;
      await this.loadInstance(wrapper, providers, moduleRef2, contextId, inquirer2);
      await this.loadEnhancersPerContext(wrapper, contextId, wrapper);
    }
    applyDoneHook(wrapper) {
      let done;
      wrapper.donePromise = new Promise((resolve2, reject) => {
        done = resolve2;
      });
      wrapper.isPending = true;
      return done;
    }
    async resolveConstructorParams(wrapper, moduleRef2, inject, callback, contextId = constants_2.STATIC_CONTEXT, inquirer2, parentInquirer) {
      let inquirerId = this.getInquirerId(inquirer2);
      const metadata2 = wrapper.getCtorMetadata();
      if (metadata2 && contextId !== constants_2.STATIC_CONTEXT) {
        const deps = await this.loadCtorMetadata(metadata2, contextId, inquirer2, parentInquirer);
        return callback(deps);
      }
      const isFactoryProvider = !(0, shared_utils_1.isNil)(inject);
      const [dependencies2, optionalDependenciesIds] = isFactoryProvider ? this.getFactoryProviderDependencies(wrapper) : this.getClassDependencies(wrapper);
      let isResolved = true;
      const resolveParam = async (param, index) => {
        try {
          if (this.isInquirer(param, parentInquirer)) {
            return parentInquirer && parentInquirer.instance;
          }
          if ((inquirer2 === null || inquirer2 === void 0 ? void 0 : inquirer2.isTransient) && parentInquirer) {
            inquirer2 = parentInquirer;
            inquirerId = this.getInquirerId(parentInquirer);
          }
          const paramWrapper = await this.resolveSingleParam(wrapper, param, { index, dependencies: dependencies2 }, moduleRef2, contextId, inquirer2, index);
          const instanceHost = paramWrapper.getInstanceByContextId(this.getContextId(contextId, paramWrapper), inquirerId);
          if (!instanceHost.isResolved && !paramWrapper.forwardRef) {
            isResolved = false;
          }
          return instanceHost === null || instanceHost === void 0 ? void 0 : instanceHost.instance;
        } catch (err) {
          const isOptional = optionalDependenciesIds.includes(index);
          if (!isOptional) {
            throw err;
          }
          return void 0;
        }
      };
      const instances = await Promise.all(dependencies2.map(resolveParam));
      isResolved && await callback(instances);
    }
    getClassDependencies(wrapper) {
      const ctorRef = wrapper.metatype;
      return [
        this.reflectConstructorParams(ctorRef),
        this.reflectOptionalParams(ctorRef)
      ];
    }
    getFactoryProviderDependencies(wrapper) {
      var _a, _b;
      const optionalDependenciesIds = [];
      const isOptionalFactoryDep = (item) => !(0, shared_utils_1.isUndefined)(item.token) && !(0, shared_utils_1.isUndefined)(item.optional);
      const mapFactoryProviderInjectArray = (item, index) => {
        if (typeof item !== "object") {
          return item;
        }
        if (isOptionalFactoryDep(item)) {
          if (item.optional) {
            optionalDependenciesIds.push(index);
          }
          return item === null || item === void 0 ? void 0 : item.token;
        }
        return item;
      };
      return [
        (_b = (_a = wrapper.inject) === null || _a === void 0 ? void 0 : _a.map) === null || _b === void 0 ? void 0 : _b.call(_a, mapFactoryProviderInjectArray),
        optionalDependenciesIds
      ];
    }
    reflectConstructorParams(type2) {
      const paramtypes = [
        ...Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, type2) || []
      ];
      const selfParams = this.reflectSelfParams(type2);
      selfParams.forEach(({ index, param }) => paramtypes[index] = param);
      return paramtypes;
    }
    reflectOptionalParams(type2) {
      return Reflect.getMetadata(constants_1.OPTIONAL_DEPS_METADATA, type2) || [];
    }
    reflectSelfParams(type2) {
      return Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, type2) || [];
    }
    async resolveSingleParam(wrapper, param, dependencyContext, moduleRef2, contextId = constants_2.STATIC_CONTEXT, inquirer2, keyOrIndex) {
      if ((0, shared_utils_1.isUndefined)(param)) {
        this.logger.log("Nest encountered an undefined dependency. This may be due to a circular import or a missing dependency declaration.");
        throw new undefined_dependency_exception_1.UndefinedDependencyException(wrapper.name, dependencyContext, moduleRef2);
      }
      const token = this.resolveParamToken(wrapper, param);
      return this.resolveComponentInstance(moduleRef2, token, dependencyContext, wrapper, contextId, inquirer2, keyOrIndex);
    }
    resolveParamToken(wrapper, param) {
      if (!param.forwardRef) {
        return param;
      }
      wrapper.forwardRef = true;
      return param.forwardRef();
    }
    async resolveComponentInstance(moduleRef2, token, dependencyContext, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer2, keyOrIndex) {
      this.printResolvingDependenciesLog(token, inquirer2);
      this.printLookingForProviderLog(token, moduleRef2);
      const providers = moduleRef2.providers;
      const instanceWrapper2 = await this.lookupComponent(providers, moduleRef2, Object.assign(Object.assign({}, dependencyContext), { name: token }), wrapper, contextId, inquirer2, keyOrIndex);
      return this.resolveComponentHost(moduleRef2, instanceWrapper2, contextId, inquirer2);
    }
    async resolveComponentHost(moduleRef2, instanceWrapper2, contextId = constants_2.STATIC_CONTEXT, inquirer2) {
      var _a;
      const inquirerId = this.getInquirerId(inquirer2);
      const instanceHost = instanceWrapper2.getInstanceByContextId(this.getContextId(contextId, instanceWrapper2), inquirerId);
      if (!instanceHost.isResolved && !instanceWrapper2.forwardRef) {
        await this.loadProvider(instanceWrapper2, (_a = instanceWrapper2.host) !== null && _a !== void 0 ? _a : moduleRef2, contextId, inquirer2);
      } else if (!instanceHost.isResolved && instanceWrapper2.forwardRef && (contextId !== constants_2.STATIC_CONTEXT || !!inquirerId)) {
        instanceHost.donePromise && instanceHost.donePromise.then(() => this.loadProvider(instanceWrapper2, moduleRef2, contextId, inquirer2));
      }
      if (instanceWrapper2.async) {
        const host = instanceWrapper2.getInstanceByContextId(this.getContextId(contextId, instanceWrapper2), inquirerId);
        host.instance = await host.instance;
        instanceWrapper2.setInstanceByContextId(contextId, host, inquirerId);
      }
      return instanceWrapper2;
    }
    async lookupComponent(providers, moduleRef2, dependencyContext, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer2, keyOrIndex) {
      const token = wrapper.token || wrapper.name;
      const { name } = dependencyContext;
      if (wrapper && token === name) {
        throw new unknown_dependencies_exception_1.UnknownDependenciesException(wrapper.name, dependencyContext, moduleRef2, { id: wrapper.id });
      }
      if (providers.has(name)) {
        const instanceWrapper2 = providers.get(name);
        this.printFoundInModuleLog(name, moduleRef2);
        this.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapper2);
        return instanceWrapper2;
      }
      return this.lookupComponentInParentModules(dependencyContext, moduleRef2, wrapper, contextId, inquirer2, keyOrIndex);
    }
    async lookupComponentInParentModules(dependencyContext, moduleRef2, wrapper, contextId = constants_2.STATIC_CONTEXT, inquirer2, keyOrIndex) {
      const instanceWrapper2 = await this.lookupComponentInImports(moduleRef2, dependencyContext.name, wrapper, [], contextId, inquirer2, keyOrIndex);
      if ((0, shared_utils_1.isNil)(instanceWrapper2)) {
        throw new unknown_dependencies_exception_1.UnknownDependenciesException(wrapper.name, dependencyContext, moduleRef2, { id: wrapper.id });
      }
      return instanceWrapper2;
    }
    async lookupComponentInImports(moduleRef2, name, wrapper, moduleRegistry = [], contextId = constants_2.STATIC_CONTEXT, inquirer2, keyOrIndex, isTraversing) {
      let instanceWrapperRef = null;
      const imports = moduleRef2.imports || /* @__PURE__ */ new Set();
      const identity2 = (item) => item;
      let children = [...imports.values()].filter(identity2);
      if (isTraversing) {
        const contextModuleExports = moduleRef2.exports;
        children = children.filter((child) => contextModuleExports.has(child.metatype));
      }
      for (const relatedModule of children) {
        if (moduleRegistry.includes(relatedModule.id)) {
          continue;
        }
        this.printLookingForProviderLog(name, relatedModule);
        moduleRegistry.push(relatedModule.id);
        const { providers, exports: exports2 } = relatedModule;
        if (!exports2.has(name) || !providers.has(name)) {
          const instanceRef = await this.lookupComponentInImports(relatedModule, name, wrapper, moduleRegistry, contextId, inquirer2, keyOrIndex, true);
          if (instanceRef) {
            this.addDependencyMetadata(keyOrIndex, wrapper, instanceRef);
            return instanceRef;
          }
          continue;
        }
        this.printFoundInModuleLog(name, relatedModule);
        instanceWrapperRef = providers.get(name);
        this.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapperRef);
        const inquirerId = this.getInquirerId(inquirer2);
        const instanceHost = instanceWrapperRef.getInstanceByContextId(this.getContextId(contextId, instanceWrapperRef), inquirerId);
        if (!instanceHost.isResolved && !instanceWrapperRef.forwardRef) {
          await this.loadProvider(instanceWrapperRef, relatedModule, contextId, wrapper);
          break;
        }
      }
      return instanceWrapperRef;
    }
    async resolveProperties(wrapper, moduleRef2, inject, contextId = constants_2.STATIC_CONTEXT, inquirer2, parentInquirer) {
      if (!(0, shared_utils_1.isNil)(inject)) {
        return [];
      }
      const metadata2 = wrapper.getPropertiesMetadata();
      if (metadata2 && contextId !== constants_2.STATIC_CONTEXT) {
        return this.loadPropertiesMetadata(metadata2, contextId, inquirer2);
      }
      const properties2 = this.reflectProperties(wrapper.metatype);
      const instances = await Promise.all(properties2.map(async (item) => {
        try {
          const dependencyContext = {
            key: item.key,
            name: item.name
          };
          if (this.isInquirer(item.name, parentInquirer)) {
            return parentInquirer && parentInquirer.instance;
          }
          const paramWrapper = await this.resolveSingleParam(wrapper, item.name, dependencyContext, moduleRef2, contextId, inquirer2, item.key);
          if (!paramWrapper) {
            return void 0;
          }
          const inquirerId = this.getInquirerId(inquirer2);
          const instanceHost = paramWrapper.getInstanceByContextId(this.getContextId(contextId, paramWrapper), inquirerId);
          return instanceHost.instance;
        } catch (err) {
          if (!item.isOptional) {
            throw err;
          }
          return void 0;
        }
      }));
      return properties2.map((item, index) => Object.assign(Object.assign({}, item), { instance: instances[index] }));
    }
    reflectProperties(type2) {
      const properties2 = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, type2) || [];
      const optionalKeys = Reflect.getMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, type2) || [];
      return properties2.map((item) => Object.assign(Object.assign({}, item), { name: item.type, isOptional: optionalKeys.includes(item.key) }));
    }
    applyProperties(instance, properties2) {
      if (!(0, shared_utils_1.isObject)(instance)) {
        return void 0;
      }
      (0, iterare_1.iterate)(properties2).filter((item) => !(0, shared_utils_1.isNil)(item.instance)).forEach((item) => instance[item.key] = item.instance);
    }
    async instantiateClass(instances, wrapper, targetMetatype, contextId = constants_2.STATIC_CONTEXT, inquirer2) {
      var _a, _b;
      const { metatype, inject } = wrapper;
      const inquirerId = this.getInquirerId(inquirer2);
      const instanceHost = targetMetatype.getInstanceByContextId(this.getContextId(contextId, targetMetatype), inquirerId);
      const isInContext = wrapper.isStatic(contextId, inquirer2) || wrapper.isInRequestScope(contextId, inquirer2) || wrapper.isLazyTransient(contextId, inquirer2) || wrapper.isExplicitlyRequested(contextId, inquirer2);
      if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.preview) && !((_b = wrapper.host) === null || _b === void 0 ? void 0 : _b.initOnPreview)) {
        instanceHost.isResolved = true;
        return instanceHost.instance;
      }
      if ((0, shared_utils_1.isNil)(inject) && isInContext) {
        instanceHost.instance = wrapper.forwardRef ? Object.assign(instanceHost.instance, new metatype(...instances)) : new metatype(...instances);
      } else if (isInContext) {
        const factoryReturnValue = targetMetatype.metatype(...instances);
        instanceHost.instance = await factoryReturnValue;
      }
      instanceHost.isResolved = true;
      return instanceHost.instance;
    }
    async loadPerContext(instance, moduleRef2, collection, ctx, wrapper) {
      if (!wrapper) {
        const injectionToken = instance.constructor;
        wrapper = collection.get(injectionToken);
      }
      await this.loadInstance(wrapper, collection, moduleRef2, ctx, wrapper);
      await this.loadEnhancersPerContext(wrapper, ctx, wrapper);
      const host = wrapper.getInstanceByContextId(this.getContextId(ctx, wrapper), wrapper.id);
      return host && host.instance;
    }
    async loadEnhancersPerContext(wrapper, ctx, inquirer2) {
      const enhancers = wrapper.getEnhancersMetadata() || [];
      const loadEnhancer = (item) => {
        const hostModule = item.host;
        return this.loadInstance(item, hostModule.injectables, hostModule, ctx, inquirer2);
      };
      await Promise.all(enhancers.map(loadEnhancer));
    }
    async loadCtorMetadata(metadata2, contextId, inquirer2, parentInquirer) {
      const hosts = await Promise.all(metadata2.map(async (item) => this.resolveScopedComponentHost(item, contextId, inquirer2, parentInquirer)));
      const inquirerId = this.getInquirerId(inquirer2);
      return hosts.map((item) => item === null || item === void 0 ? void 0 : item.getInstanceByContextId(this.getContextId(contextId, item), inquirerId).instance);
    }
    async loadPropertiesMetadata(metadata2, contextId, inquirer2) {
      const dependenciesHosts = await Promise.all(metadata2.map(async ({ wrapper: item, key }) => ({
        key,
        host: await this.resolveComponentHost(item.host, item, contextId, inquirer2)
      })));
      const inquirerId = this.getInquirerId(inquirer2);
      return dependenciesHosts.map(({ key, host }) => ({
        key,
        name: key,
        instance: host.getInstanceByContextId(this.getContextId(contextId, host), inquirerId).instance
      }));
    }
    getInquirerId(inquirer2) {
      return inquirer2 && inquirer2.id;
    }
    resolveScopedComponentHost(item, contextId, inquirer2, parentInquirer) {
      return this.isInquirerRequest(item, parentInquirer) ? parentInquirer : this.resolveComponentHost(item.host, item, contextId, inquirer2);
    }
    isInquirerRequest(item, parentInquirer) {
      return item.isTransient && item.name === inquirer_1.INQUIRER && parentInquirer;
    }
    isInquirer(param, parentInquirer) {
      return param === inquirer_1.INQUIRER && parentInquirer;
    }
    addDependencyMetadata(keyOrIndex, hostWrapper, instanceWrapper2) {
      if ((0, shared_utils_1.isSymbol)(keyOrIndex) || (0, shared_utils_1.isString)(keyOrIndex)) {
        hostWrapper.addPropertiesMetadata(keyOrIndex, instanceWrapper2);
      } else {
        hostWrapper.addCtorMetadata(keyOrIndex, instanceWrapper2);
      }
    }
    getTokenName(token) {
      return (0, shared_utils_1.isFunction)(token) ? token.name : token.toString();
    }
    printResolvingDependenciesLog(token, inquirer2) {
      var _a, _b, _c;
      if (!this.isDebugMode()) {
        return;
      }
      const tokenName = this.getTokenName(token);
      const dependentName = (_c = (inquirer2 === null || inquirer2 === void 0 ? void 0 : inquirer2.name) && ((_b = (_a = inquirer2.name).toString) === null || _b === void 0 ? void 0 : _b.call(_a))) !== null && _c !== void 0 ? _c : "unknown";
      const isAlias = dependentName === tokenName;
      const messageToPrint = `Resolving dependency ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(" in the ")}${cli_colors_util_1.clc.yellow(dependentName)}${cli_colors_util_1.clc.green(` provider ${isAlias ? "(alias)" : ""}`)}`;
      this.logger.log(messageToPrint);
    }
    printLookingForProviderLog(token, moduleRef2) {
      var _a, _b;
      if (!this.isDebugMode()) {
        return;
      }
      const tokenName = this.getTokenName(token);
      const moduleRefName = (_b = (_a = moduleRef2 === null || moduleRef2 === void 0 ? void 0 : moduleRef2.metatype) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "unknown";
      this.logger.log(`Looking for ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(" in ")}${cli_colors_util_1.clc.magentaBright(moduleRefName)}`);
    }
    printFoundInModuleLog(token, moduleRef2) {
      var _a, _b;
      if (!this.isDebugMode()) {
        return;
      }
      const tokenName = this.getTokenName(token);
      const moduleRefName = (_b = (_a = moduleRef2 === null || moduleRef2 === void 0 ? void 0 : moduleRef2.metatype) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "unknown";
      this.logger.log(`Found ${cli_colors_util_1.clc.cyanBright(tokenName)}${cli_colors_util_1.clc.green(" in ")}${cli_colors_util_1.clc.magentaBright(moduleRefName)}`);
    }
    isDebugMode() {
      return !!process.env.NEST_DEBUG;
    }
    getContextId(contextId, instanceWrapper2) {
      return contextId.getParent ? contextId.getParent({
        token: instanceWrapper2.token,
        isTreeDurable: instanceWrapper2.isDependencyTreeDurable()
      }) : contextId;
    }
    getNowTimestamp() {
      return perf_hooks_1.performance.now();
    }
  }
  injector.Injector = Injector;
  return injector;
}
var instanceLinksHost = {};
var hasRequiredInstanceLinksHost;
function requireInstanceLinksHost() {
  if (hasRequiredInstanceLinksHost)
    return instanceLinksHost;
  hasRequiredInstanceLinksHost = 1;
  Object.defineProperty(instanceLinksHost, "__esModule", { value: true });
  instanceLinksHost.InstanceLinksHost = void 0;
  const shared_utils_1 = requireShared_utils();
  const unknown_element_exception_1 = requireUnknownElement_exception();
  class InstanceLinksHost {
    constructor(container2) {
      this.container = container2;
      this.instanceLinks = /* @__PURE__ */ new Map();
      this.initialize();
    }
    get(token, options = {}) {
      const instanceLinksForGivenToken = this.instanceLinks.get(token);
      if (!instanceLinksForGivenToken) {
        throw new unknown_element_exception_1.UnknownElementException(this.getInstanceNameByToken(token));
      }
      if (options.each) {
        return instanceLinksForGivenToken;
      }
      const instanceLink = options.moduleId ? instanceLinksForGivenToken.find((item) => item.moduleId === options.moduleId) : instanceLinksForGivenToken[instanceLinksForGivenToken.length - 1];
      if (!instanceLink) {
        throw new unknown_element_exception_1.UnknownElementException(this.getInstanceNameByToken(token));
      }
      return instanceLink;
    }
    initialize() {
      const modules2 = this.container.getModules();
      modules2.forEach((moduleRef2) => {
        const { providers, injectables, controllers } = moduleRef2;
        providers.forEach((wrapper, token) => this.addLink(wrapper, token, moduleRef2, "providers"));
        injectables.forEach((wrapper, token) => this.addLink(wrapper, token, moduleRef2, "injectables"));
        controllers.forEach((wrapper, token) => this.addLink(wrapper, token, moduleRef2, "controllers"));
      });
    }
    addLink(wrapper, token, moduleRef2, collectionName) {
      const instanceLink = {
        moduleId: moduleRef2.id,
        wrapperRef: wrapper,
        collection: moduleRef2[collectionName],
        token
      };
      const existingLinks = this.instanceLinks.get(token);
      if (!existingLinks) {
        this.instanceLinks.set(token, [instanceLink]);
      } else {
        existingLinks.push(instanceLink);
      }
    }
    getInstanceNameByToken(token) {
      return (0, shared_utils_1.isFunction)(token) ? token === null || token === void 0 ? void 0 : token.name : token;
    }
  }
  instanceLinksHost.InstanceLinksHost = InstanceLinksHost;
  return instanceLinksHost;
}
var hasRequiredModuleRef;
function requireModuleRef() {
  if (hasRequiredModuleRef)
    return moduleRef;
  hasRequiredModuleRef = 1;
  Object.defineProperty(moduleRef, "__esModule", { value: true });
  moduleRef.ModuleRef = void 0;
  const common_1 = requireCommon$3();
  const get_class_scope_1 = requireGetClassScope();
  const is_durable_1 = requireIsDurable();
  const abstract_instance_resolver_1 = requireAbstractInstanceResolver();
  const injector_1 = requireInjector$1();
  const instance_links_host_1 = requireInstanceLinksHost();
  const instance_wrapper_1 = requireInstanceWrapper();
  class ModuleRef extends abstract_instance_resolver_1.AbstractInstanceResolver {
    get instanceLinksHost() {
      if (!this._instanceLinksHost) {
        this._instanceLinksHost = new instance_links_host_1.InstanceLinksHost(this.container);
      }
      return this._instanceLinksHost;
    }
    constructor(container2) {
      super();
      this.container = container2;
      this.injector = new injector_1.Injector();
    }
    introspect(token) {
      const { wrapperRef } = this.instanceLinksHost.get(token);
      let scope2 = common_1.Scope.DEFAULT;
      if (!wrapperRef.isDependencyTreeStatic()) {
        scope2 = common_1.Scope.REQUEST;
      } else if (wrapperRef.isTransient) {
        scope2 = common_1.Scope.TRANSIENT;
      }
      return { scope: scope2 };
    }
    registerRequestByContextId(request2, contextId) {
      this.container.registerRequestProvider(request2, contextId);
    }
    async instantiateClass(type2, moduleRef2) {
      const wrapper = new instance_wrapper_1.InstanceWrapper({
        name: type2 && type2.name,
        metatype: type2,
        isResolved: false,
        scope: (0, get_class_scope_1.getClassScope)(type2),
        durable: (0, is_durable_1.isDurable)(type2),
        host: moduleRef2
      });
      return new Promise(async (resolve2, reject) => {
        try {
          const callback = async (instances) => {
            const properties2 = await this.injector.resolveProperties(wrapper, moduleRef2);
            const instance = new type2(...instances);
            this.injector.applyProperties(instance, properties2);
            resolve2(instance);
          };
          await this.injector.resolveConstructorParams(wrapper, moduleRef2, void 0, callback);
        } catch (err) {
          reject(err);
        }
      });
    }
  }
  moduleRef.ModuleRef = ModuleRef;
  return moduleRef;
}
var hasRequiredLazyModuleLoader;
function requireLazyModuleLoader() {
  if (hasRequiredLazyModuleLoader)
    return lazyModuleLoader;
  hasRequiredLazyModuleLoader = 1;
  Object.defineProperty(lazyModuleLoader, "__esModule", { value: true });
  lazyModuleLoader.LazyModuleLoader = void 0;
  const silent_logger_1 = requireSilentLogger();
  const module_ref_1 = requireModuleRef();
  class LazyModuleLoader {
    constructor(dependenciesScanner, instanceLoader2, moduleCompiler, modulesContainer2) {
      this.dependenciesScanner = dependenciesScanner;
      this.instanceLoader = instanceLoader2;
      this.moduleCompiler = moduleCompiler;
      this.modulesContainer = modulesContainer2;
    }
    async load(loaderFn, loadOpts) {
      this.registerLoggerConfiguration(loadOpts);
      const moduleClassOrDynamicDefinition = await loaderFn();
      const moduleInstances = await this.dependenciesScanner.scanForModules(moduleClassOrDynamicDefinition);
      if (moduleInstances.length === 0) {
        const { token } = await this.moduleCompiler.compile(moduleClassOrDynamicDefinition);
        const moduleInstance = this.modulesContainer.get(token);
        return moduleInstance && this.getTargetModuleRef(moduleInstance);
      }
      const lazyModulesContainer = this.createLazyModulesContainer(moduleInstances);
      await this.dependenciesScanner.scanModulesForDependencies(lazyModulesContainer);
      await this.instanceLoader.createInstancesOfDependencies(lazyModulesContainer);
      const [targetModule] = moduleInstances;
      return this.getTargetModuleRef(targetModule);
    }
    registerLoggerConfiguration(loadOpts) {
      if ((loadOpts === null || loadOpts === void 0 ? void 0 : loadOpts.logger) === false) {
        this.instanceLoader.setLogger(new silent_logger_1.SilentLogger());
      }
    }
    createLazyModulesContainer(moduleInstances) {
      moduleInstances = Array.from(new Set(moduleInstances));
      return new Map(moduleInstances.map((ref2) => [ref2.token, ref2]));
    }
    getTargetModuleRef(moduleInstance) {
      const moduleRefInstanceWrapper = moduleInstance.getProviderByKey(module_ref_1.ModuleRef);
      return moduleRefInstanceWrapper.instance;
    }
  }
  lazyModuleLoader.LazyModuleLoader = LazyModuleLoader;
  return lazyModuleLoader;
}
var reflector_service = {};
var hasRequiredReflector_service;
function requireReflector_service() {
  if (hasRequiredReflector_service)
    return reflector_service;
  hasRequiredReflector_service = 1;
  Object.defineProperty(reflector_service, "__esModule", { value: true });
  reflector_service.Reflector = void 0;
  const shared_utils_1 = requireShared_utils();
  class Reflector {
    /**
     * Retrieve metadata for a specified key for a specified target.
     *
     * @example
     * `const roles = this.reflector.get<string[]>('roles', context.getHandler());`
     *
     * @param metadataKey lookup key for metadata to retrieve
     * @param target context (decorated object) to retrieve metadata from
     *
     */
    get(metadataKey, target) {
      return Reflect.getMetadata(metadataKey, target);
    }
    /**
     * Retrieve metadata for a specified key for a specified set of targets.
     *
     * @param metadataKey lookup key for metadata to retrieve
     * @param targets context (decorated objects) to retrieve metadata from
     *
     */
    getAll(metadataKey, targets) {
      return (targets || []).map((target) => this.get(metadataKey, target));
    }
    /**
     * Retrieve metadata for a specified key for a specified set of targets and merge results.
     *
     * @param metadataKey lookup key for metadata to retrieve
     * @param targets context (decorated objects) to retrieve metadata from
     *
     */
    getAllAndMerge(metadataKey, targets) {
      const metadataCollection = this.getAll(metadataKey, targets).filter((item) => item !== void 0);
      if ((0, shared_utils_1.isEmpty)(metadataCollection)) {
        return metadataCollection;
      }
      return metadataCollection.reduce((a, b) => {
        if (Array.isArray(a)) {
          return a.concat(b);
        }
        if ((0, shared_utils_1.isObject)(a) && (0, shared_utils_1.isObject)(b)) {
          return Object.assign(Object.assign({}, a), b);
        }
        return [a, b];
      });
    }
    /**
     * Retrieve metadata for a specified key for a specified set of targets and return a first not undefined value.
     *
     * @param metadataKey lookup key for metadata to retrieve
     * @param targets context (decorated objects) to retrieve metadata from
     *
     */
    getAllAndOverride(metadataKey, targets) {
      for (const target of targets) {
        const result = this.get(metadataKey, target);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
  }
  reflector_service.Reflector = Reflector;
  return reflector_service;
}
var hasRequiredSerializedGraph;
function requireSerializedGraph() {
  if (hasRequiredSerializedGraph)
    return serializedGraph;
  hasRequiredSerializedGraph = 1;
  Object.defineProperty(serializedGraph, "__esModule", { value: true });
  serializedGraph.SerializedGraph = void 0;
  const application_config_1 = requireApplicationConfig();
  const external_context_creator_1 = requireExternalContextCreator();
  const http_adapter_host_1 = requireHttpAdapterHost();
  const inquirer_constants_1 = requireInquirerConstants();
  const lazy_module_loader_1 = requireLazyModuleLoader();
  const module_ref_1 = requireModuleRef();
  const modules_container_1 = requireModulesContainer();
  const request_constants_1 = requireRequestConstants();
  const reflector_service_1 = requireReflector_service();
  const deterministic_uuid_registry_1 = requireDeterministicUuidRegistry();
  class SerializedGraph {
    constructor() {
      this.nodes = /* @__PURE__ */ new Map();
      this.edges = /* @__PURE__ */ new Map();
      this.entrypoints = /* @__PURE__ */ new Map();
      this.extras = {
        orphanedEnhancers: [],
        attachedEnhancers: []
      };
      this._status = "complete";
    }
    set status(status) {
      this._status = status;
    }
    set metadata(metadata2) {
      this._metadata = metadata2;
    }
    insertNode(nodeDefinition) {
      if (nodeDefinition.metadata.type === "provider" && SerializedGraph.INTERNAL_PROVIDERS.includes(nodeDefinition.metadata.token)) {
        nodeDefinition.metadata = Object.assign(Object.assign({}, nodeDefinition.metadata), { internal: true });
      }
      if (this.nodes.has(nodeDefinition.id)) {
        return this.nodes.get(nodeDefinition.id);
      }
      this.nodes.set(nodeDefinition.id, nodeDefinition);
      return nodeDefinition;
    }
    insertEdge(edgeDefinition) {
      var _a;
      if (edgeDefinition.metadata.type === "class-to-class" && (SerializedGraph.INTERNAL_PROVIDERS.includes(edgeDefinition.metadata.sourceClassToken) || SerializedGraph.INTERNAL_PROVIDERS.includes(edgeDefinition.metadata.targetClassToken))) {
        edgeDefinition.metadata = Object.assign(Object.assign({}, edgeDefinition.metadata), { internal: true });
      }
      const id2 = (_a = edgeDefinition.id) !== null && _a !== void 0 ? _a : this.generateUuidByEdgeDefinition(edgeDefinition);
      const edge = Object.assign(Object.assign({}, edgeDefinition), { id: id2 });
      this.edges.set(id2, edge);
      return edge;
    }
    insertEntrypoint(definition, parentId) {
      if (this.entrypoints.has(parentId)) {
        const existingCollection = this.entrypoints.get(parentId);
        existingCollection.push(definition);
      } else {
        this.entrypoints.set(parentId, [definition]);
      }
    }
    insertOrphanedEnhancer(entry) {
      this.extras.orphanedEnhancers.push(entry);
    }
    insertAttachedEnhancer(nodeId) {
      this.extras.attachedEnhancers.push({
        nodeId
      });
    }
    getNodeById(id2) {
      return this.nodes.get(id2);
    }
    toJSON() {
      const json = {
        nodes: Object.fromEntries(this.nodes),
        edges: Object.fromEntries(this.edges),
        entrypoints: Object.fromEntries(this.entrypoints),
        extras: this.extras
      };
      if (this._status) {
        json["status"] = this._status;
      }
      if (this._metadata) {
        json["metadata"] = this._metadata;
      }
      return json;
    }
    toString() {
      const replacer = (key, value) => {
        var _a;
        if (typeof value === "symbol") {
          return value.toString();
        }
        return typeof value === "function" ? (_a = value.name) !== null && _a !== void 0 ? _a : "Function" : value;
      };
      return JSON.stringify(this.toJSON(), replacer, 2);
    }
    generateUuidByEdgeDefinition(edgeDefinition) {
      return deterministic_uuid_registry_1.DeterministicUuidRegistry.get(JSON.stringify(edgeDefinition));
    }
  }
  SerializedGraph.INTERNAL_PROVIDERS = [
    application_config_1.ApplicationConfig,
    module_ref_1.ModuleRef,
    http_adapter_host_1.HttpAdapterHost,
    lazy_module_loader_1.LazyModuleLoader,
    external_context_creator_1.ExternalContextCreator,
    modules_container_1.ModulesContainer,
    reflector_service_1.Reflector,
    SerializedGraph,
    http_adapter_host_1.HttpAdapterHost.name,
    reflector_service_1.Reflector.name,
    request_constants_1.REQUEST,
    inquirer_constants_1.INQUIRER
  ];
  serializedGraph.SerializedGraph = SerializedGraph;
  return serializedGraph;
}
var compiler = {};
var moduleTokenFactory = {};
var fastSafeStringify;
var hasRequiredFastSafeStringify;
function requireFastSafeStringify() {
  if (hasRequiredFastSafeStringify)
    return fastSafeStringify;
  hasRequiredFastSafeStringify = 1;
  fastSafeStringify = stringify;
  stringify.default = stringify;
  stringify.stable = deterministicStringify;
  stringify.stableStringify = deterministicStringify;
  var LIMIT_REPLACE_NODE = "[...]";
  var CIRCULAR_REPLACE_NODE = "[Circular]";
  var arr = [];
  var replacerStack = [];
  function defaultOptions2() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function stringify(obj, replacer, spacer, options) {
    if (typeof options === "undefined") {
      options = defaultOptions2();
    }
    decirc(obj, "", 0, [], void 0, 0, options);
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res;
  }
  function setReplace(replace, val, k, parent) {
    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
    if (propertyDescriptor.get !== void 0) {
      if (propertyDescriptor.configurable) {
        Object.defineProperty(parent, k, { value: replace });
        arr.push([parent, k, val, propertyDescriptor]);
      } else {
        replacerStack.push([val, k, replace]);
      }
    } else {
      parent[k] = replace;
      arr.push([parent, k, val]);
    }
  }
  function decirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === "object" && val !== null) {
      for (i = 0; i < stack.length; i++) {
        if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
          return;
        }
      }
      if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      stack.push(val);
      if (Array.isArray(val)) {
        for (i = 0; i < val.length; i++) {
          decirc(val[i], i, i, stack, val, depth, options);
        }
      } else {
        var keys = Object.keys(val);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          decirc(val[key], key, i, stack, val, depth, options);
        }
      }
      stack.pop();
    }
  }
  function compareFunction(a, b) {
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }
  function deterministicStringify(obj, replacer, spacer, options) {
    if (typeof options === "undefined") {
      options = defaultOptions2();
    }
    var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(tmp, replacer, spacer);
      } else {
        res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res;
  }
  function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === "object" && val !== null) {
      for (i = 0; i < stack.length; i++) {
        if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
          return;
        }
      }
      try {
        if (typeof val.toJSON === "function") {
          return;
        }
      } catch (_) {
        return;
      }
      if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return;
      }
      stack.push(val);
      if (Array.isArray(val)) {
        for (i = 0; i < val.length; i++) {
          deterministicDecirc(val[i], i, i, stack, val, depth, options);
        }
      } else {
        var tmp = {};
        var keys = Object.keys(val).sort(compareFunction);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          deterministicDecirc(val[key], key, i, stack, val, depth, options);
          tmp[key] = val[key];
        }
        if (typeof parent !== "undefined") {
          arr.push([parent, k, val]);
          parent[k] = tmp;
        } else {
          return tmp;
        }
      }
      stack.pop();
    }
  }
  function replaceGetterValues(replacer) {
    replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
      return v;
    };
    return function(key, val) {
      if (replacerStack.length > 0) {
        for (var i = 0; i < replacerStack.length; i++) {
          var part = replacerStack[i];
          if (part[1] === key && part[0] === val) {
            val = part[2];
            replacerStack.splice(i, 1);
            break;
          }
        }
      }
      return replacer.call(this, key, val);
    };
  }
  return fastSafeStringify;
}
var hasRequiredModuleTokenFactory;
function requireModuleTokenFactory() {
  if (hasRequiredModuleTokenFactory)
    return moduleTokenFactory;
  hasRequiredModuleTokenFactory = 1;
  Object.defineProperty(moduleTokenFactory, "__esModule", { value: true });
  moduleTokenFactory.ModuleTokenFactory = void 0;
  const random_string_generator_util_1 = requireRandomStringGenerator_util();
  const shared_utils_1 = requireShared_utils();
  const crypto_1 = require$$0$5;
  const fast_safe_stringify_1 = requireFastSafeStringify();
  const CLASS_STR = "class ";
  const CLASS_STR_LEN = CLASS_STR.length;
  class ModuleTokenFactory {
    constructor() {
      this.moduleTokenCache = /* @__PURE__ */ new Map();
      this.moduleIdsCache = /* @__PURE__ */ new WeakMap();
    }
    create(metatype, dynamicModuleMetadata) {
      const moduleId = this.getModuleId(metatype);
      if (!dynamicModuleMetadata) {
        return this.getStaticModuleToken(moduleId, this.getModuleName(metatype));
      }
      const opaqueToken = {
        id: moduleId,
        module: this.getModuleName(metatype),
        dynamic: dynamicModuleMetadata
      };
      const opaqueTokenString = this.getStringifiedOpaqueToken(opaqueToken);
      return this.hashString(opaqueTokenString);
    }
    getStaticModuleToken(moduleId, moduleName) {
      const key = `${moduleId}_${moduleName}`;
      if (this.moduleTokenCache.has(key)) {
        return this.moduleTokenCache.get(key);
      }
      const hash = this.hashString(key);
      this.moduleTokenCache.set(key, hash);
      return hash;
    }
    getStringifiedOpaqueToken(opaqueToken) {
      return opaqueToken ? (0, fast_safe_stringify_1.default)(opaqueToken, this.replacer) : "";
    }
    getModuleId(metatype) {
      let moduleId = this.moduleIdsCache.get(metatype);
      if (moduleId) {
        return moduleId;
      }
      moduleId = (0, random_string_generator_util_1.randomStringGenerator)();
      this.moduleIdsCache.set(metatype, moduleId);
      return moduleId;
    }
    getModuleName(metatype) {
      return metatype.name;
    }
    hashString(value) {
      return (0, crypto_1.createHash)("sha256").update(value).digest("hex");
    }
    replacer(key, value) {
      if ((0, shared_utils_1.isFunction)(value)) {
        const funcAsString = value.toString();
        const isClass = funcAsString.slice(0, CLASS_STR_LEN) === CLASS_STR;
        if (isClass) {
          return value.name;
        }
        return funcAsString;
      }
      if ((0, shared_utils_1.isSymbol)(value)) {
        return value.toString();
      }
      return value;
    }
  }
  moduleTokenFactory.ModuleTokenFactory = ModuleTokenFactory;
  return moduleTokenFactory;
}
var hasRequiredCompiler;
function requireCompiler() {
  if (hasRequiredCompiler)
    return compiler;
  hasRequiredCompiler = 1;
  Object.defineProperty(compiler, "__esModule", { value: true });
  compiler.ModuleCompiler = void 0;
  const tslib_1 = require$$0$3;
  const module_token_factory_1 = requireModuleTokenFactory();
  class ModuleCompiler {
    constructor(moduleTokenFactory2 = new module_token_factory_1.ModuleTokenFactory()) {
      this.moduleTokenFactory = moduleTokenFactory2;
    }
    async compile(metatype) {
      const { type: type2, dynamicMetadata } = this.extractMetadata(await metatype);
      const token = this.moduleTokenFactory.create(type2, dynamicMetadata);
      return { type: type2, dynamicMetadata, token };
    }
    extractMetadata(metatype) {
      if (!this.isDynamicModule(metatype)) {
        return {
          type: (metatype === null || metatype === void 0 ? void 0 : metatype.forwardRef) ? metatype.forwardRef() : metatype
        };
      }
      const { module: type2 } = metatype, dynamicMetadata = tslib_1.__rest(metatype, ["module"]);
      return { type: type2, dynamicMetadata };
    }
    isDynamicModule(module2) {
      return !!module2.module;
    }
  }
  compiler.ModuleCompiler = ModuleCompiler;
  return compiler;
}
var internalCoreModule = {};
var requestProviders = {};
var hasRequiredRequestProviders;
function requireRequestProviders() {
  if (hasRequiredRequestProviders)
    return requestProviders;
  hasRequiredRequestProviders = 1;
  Object.defineProperty(requestProviders, "__esModule", { value: true });
  requestProviders.requestProvider = void 0;
  const common_1 = requireCommon$3();
  const request_constants_1 = requireRequestConstants();
  const noop2 = () => {
  };
  requestProviders.requestProvider = {
    provide: request_constants_1.REQUEST,
    scope: common_1.Scope.REQUEST,
    useFactory: noop2
  };
  return requestProviders;
}
var services = {};
var hasRequiredServices;
function requireServices() {
  if (hasRequiredServices)
    return services;
  hasRequiredServices = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireReflector_service(), exports2);
  })(services);
  return services;
}
var inquirerProviders = {};
var hasRequiredInquirerProviders;
function requireInquirerProviders() {
  if (hasRequiredInquirerProviders)
    return inquirerProviders;
  hasRequiredInquirerProviders = 1;
  Object.defineProperty(inquirerProviders, "__esModule", { value: true });
  inquirerProviders.inquirerProvider = void 0;
  const common_1 = requireCommon$3();
  const inquirer_constants_1 = requireInquirerConstants();
  const noop2 = () => {
  };
  inquirerProviders.inquirerProvider = {
    provide: inquirer_constants_1.INQUIRER,
    scope: common_1.Scope.TRANSIENT,
    useFactory: noop2
  };
  return inquirerProviders;
}
var hasRequiredInternalCoreModule;
function requireInternalCoreModule() {
  if (hasRequiredInternalCoreModule)
    return internalCoreModule;
  hasRequiredInternalCoreModule = 1;
  var InternalCoreModule_1;
  Object.defineProperty(internalCoreModule, "__esModule", { value: true });
  internalCoreModule.InternalCoreModule = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const request_providers_1 = requireRequestProviders();
  const services_1 = requireServices();
  const inquirer_providers_1 = requireInquirerProviders();
  const ReflectorAliasProvider = {
    provide: services_1.Reflector.name,
    useExisting: services_1.Reflector
  };
  let InternalCoreModule = InternalCoreModule_1 = class InternalCoreModule {
    static register(providers) {
      return {
        module: InternalCoreModule_1,
        providers: [...providers],
        exports: [...providers.map((item) => item.provide)]
      };
    }
  };
  InternalCoreModule = InternalCoreModule_1 = tslib_1.__decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
      providers: [
        services_1.Reflector,
        ReflectorAliasProvider,
        request_providers_1.requestProvider,
        inquirer_providers_1.inquirerProvider
      ],
      exports: [
        services_1.Reflector,
        ReflectorAliasProvider,
        request_providers_1.requestProvider,
        inquirer_providers_1.inquirerProvider
      ]
    })
  ], InternalCoreModule);
  internalCoreModule.InternalCoreModule = InternalCoreModule;
  return internalCoreModule;
}
var internalProvidersStorage = {};
var hasRequiredInternalProvidersStorage;
function requireInternalProvidersStorage() {
  if (hasRequiredInternalProvidersStorage)
    return internalProvidersStorage;
  hasRequiredInternalProvidersStorage = 1;
  Object.defineProperty(internalProvidersStorage, "__esModule", { value: true });
  internalProvidersStorage.InternalProvidersStorage = void 0;
  const http_adapter_host_1 = requireHttpAdapterHost();
  class InternalProvidersStorage {
    constructor() {
      this._httpAdapterHost = new http_adapter_host_1.HttpAdapterHost();
    }
    get httpAdapterHost() {
      return this._httpAdapterHost;
    }
    get httpAdapter() {
      return this._httpAdapter;
    }
    set httpAdapter(httpAdapter3) {
      this._httpAdapter = httpAdapter3;
    }
  }
  internalProvidersStorage.InternalProvidersStorage = InternalProvidersStorage;
  return internalProvidersStorage;
}
var module$1 = {};
var hasRequiredModule;
function requireModule() {
  if (hasRequiredModule)
    return module$1;
  hasRequiredModule = 1;
  Object.defineProperty(module$1, "__esModule", { value: true });
  module$1.Module = void 0;
  const constants_1 = requireConstants$4();
  const random_string_generator_util_1 = requireRandomStringGenerator_util();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const application_config_1 = requireApplicationConfig();
  const exceptions_1 = requireExceptions();
  const context_id_factory_1 = requireContextIdFactory();
  const get_class_scope_1 = requireGetClassScope();
  const is_durable_1 = requireIsDurable();
  const uuid_factory_1 = requireUuidFactory();
  const constants_2 = requireConstants$2();
  const instance_wrapper_1 = requireInstanceWrapper();
  const module_ref_1 = requireModuleRef();
  class Module {
    constructor(_metatype, container2) {
      this._metatype = _metatype;
      this.container = container2;
      this._imports = /* @__PURE__ */ new Set();
      this._providers = /* @__PURE__ */ new Map();
      this._injectables = /* @__PURE__ */ new Map();
      this._middlewares = /* @__PURE__ */ new Map();
      this._controllers = /* @__PURE__ */ new Map();
      this._entryProviderKeys = /* @__PURE__ */ new Set();
      this._exports = /* @__PURE__ */ new Set();
      this._distance = 0;
      this._initOnPreview = false;
      this._isGlobal = false;
      this.addCoreProviders();
      this._id = this.generateUuid();
    }
    get id() {
      return this._id;
    }
    get token() {
      return this._token;
    }
    set token(token) {
      this._token = token;
    }
    get name() {
      return this.metatype.name;
    }
    get isGlobal() {
      return this._isGlobal;
    }
    set isGlobal(global2) {
      this._isGlobal = global2;
    }
    get initOnPreview() {
      return this._initOnPreview;
    }
    set initOnPreview(initOnPreview) {
      this._initOnPreview = initOnPreview;
    }
    get providers() {
      return this._providers;
    }
    get middlewares() {
      return this._middlewares;
    }
    get imports() {
      return this._imports;
    }
    /**
     * Left for backward-compatibility reasons
     */
    get relatedModules() {
      return this._imports;
    }
    /**
     * Left for backward-compatibility reasons
     */
    get components() {
      return this._providers;
    }
    /**
     * Left for backward-compatibility reasons
     */
    get routes() {
      return this._controllers;
    }
    get injectables() {
      return this._injectables;
    }
    get controllers() {
      return this._controllers;
    }
    get entryProviders() {
      return Array.from(this._entryProviderKeys).map((token) => this.providers.get(token));
    }
    get exports() {
      return this._exports;
    }
    get instance() {
      if (!this._providers.has(this._metatype)) {
        throw new exceptions_1.RuntimeException();
      }
      const module2 = this._providers.get(this._metatype);
      return module2.instance;
    }
    get metatype() {
      return this._metatype;
    }
    get distance() {
      return this._distance;
    }
    set distance(value) {
      this._distance = value;
    }
    addCoreProviders() {
      this.addModuleAsProvider();
      this.addModuleRef();
      this.addApplicationConfig();
    }
    addModuleRef() {
      const moduleRef2 = this.createModuleReferenceType();
      this._providers.set(module_ref_1.ModuleRef, new instance_wrapper_1.InstanceWrapper({
        token: module_ref_1.ModuleRef,
        name: module_ref_1.ModuleRef.name,
        metatype: module_ref_1.ModuleRef,
        isResolved: true,
        instance: new moduleRef2(),
        host: this
      }));
    }
    addModuleAsProvider() {
      this._providers.set(this._metatype, new instance_wrapper_1.InstanceWrapper({
        token: this._metatype,
        name: this._metatype.name,
        metatype: this._metatype,
        isResolved: false,
        instance: null,
        host: this
      }));
    }
    addApplicationConfig() {
      this._providers.set(application_config_1.ApplicationConfig, new instance_wrapper_1.InstanceWrapper({
        token: application_config_1.ApplicationConfig,
        name: application_config_1.ApplicationConfig.name,
        isResolved: true,
        instance: this.container.applicationConfig,
        host: this
      }));
    }
    addInjectable(injectable, enhancerSubtype, host) {
      if (this.isCustomProvider(injectable)) {
        return this.addCustomProvider(injectable, this._injectables, enhancerSubtype);
      }
      let instanceWrapper2 = this.injectables.get(injectable);
      if (!instanceWrapper2) {
        instanceWrapper2 = new instance_wrapper_1.InstanceWrapper({
          token: injectable,
          name: injectable.name,
          metatype: injectable,
          instance: null,
          isResolved: false,
          scope: (0, get_class_scope_1.getClassScope)(injectable),
          durable: (0, is_durable_1.isDurable)(injectable),
          subtype: enhancerSubtype,
          host: this
        });
        this._injectables.set(injectable, instanceWrapper2);
      }
      if (host) {
        const hostWrapper = this._controllers.get(host) || this._providers.get(host);
        hostWrapper && hostWrapper.addEnhancerMetadata(instanceWrapper2);
      }
      return instanceWrapper2;
    }
    addProvider(provider, enhancerSubtype) {
      if (this.isCustomProvider(provider)) {
        if (this.isEntryProvider(provider.provide)) {
          this._entryProviderKeys.add(provider.provide);
        }
        return this.addCustomProvider(provider, this._providers, enhancerSubtype);
      }
      this._providers.set(provider, new instance_wrapper_1.InstanceWrapper({
        token: provider,
        name: provider.name,
        metatype: provider,
        instance: null,
        isResolved: false,
        scope: (0, get_class_scope_1.getClassScope)(provider),
        durable: (0, is_durable_1.isDurable)(provider),
        host: this
      }));
      if (this.isEntryProvider(provider)) {
        this._entryProviderKeys.add(provider);
      }
      return provider;
    }
    isCustomProvider(provider) {
      return !(0, shared_utils_1.isNil)(provider.provide);
    }
    addCustomProvider(provider, collection, enhancerSubtype) {
      if (this.isCustomClass(provider)) {
        this.addCustomClass(provider, collection, enhancerSubtype);
      } else if (this.isCustomValue(provider)) {
        this.addCustomValue(provider, collection, enhancerSubtype);
      } else if (this.isCustomFactory(provider)) {
        this.addCustomFactory(provider, collection, enhancerSubtype);
      } else if (this.isCustomUseExisting(provider)) {
        this.addCustomUseExisting(provider, collection, enhancerSubtype);
      }
      return provider.provide;
    }
    isCustomClass(provider) {
      return !(0, shared_utils_1.isUndefined)(provider.useClass);
    }
    isCustomValue(provider) {
      return (0, shared_utils_1.isObject)(provider) && Object.prototype.hasOwnProperty.call(provider, "useValue");
    }
    isCustomFactory(provider) {
      return !(0, shared_utils_1.isUndefined)(provider.useFactory);
    }
    isCustomUseExisting(provider) {
      return !(0, shared_utils_1.isUndefined)(provider.useExisting);
    }
    isDynamicModule(exported) {
      return exported && exported.module;
    }
    addCustomClass(provider, collection, enhancerSubtype) {
      let { scope: scope2, durable } = provider;
      const { useClass } = provider;
      if ((0, shared_utils_1.isUndefined)(scope2)) {
        scope2 = (0, get_class_scope_1.getClassScope)(useClass);
      }
      if ((0, shared_utils_1.isUndefined)(durable)) {
        durable = (0, is_durable_1.isDurable)(useClass);
      }
      const token = provider.provide;
      collection.set(token, new instance_wrapper_1.InstanceWrapper({
        token,
        name: (useClass === null || useClass === void 0 ? void 0 : useClass.name) || useClass,
        metatype: useClass,
        instance: null,
        isResolved: false,
        scope: scope2,
        durable,
        host: this,
        subtype: enhancerSubtype
      }));
    }
    addCustomValue(provider, collection, enhancerSubtype) {
      const { useValue: value, provide: providerToken } = provider;
      collection.set(providerToken, new instance_wrapper_1.InstanceWrapper({
        token: providerToken,
        name: (providerToken === null || providerToken === void 0 ? void 0 : providerToken.name) || providerToken,
        metatype: null,
        instance: value,
        isResolved: true,
        async: value instanceof Promise,
        host: this,
        subtype: enhancerSubtype
      }));
    }
    addCustomFactory(provider, collection, enhancerSubtype) {
      const { useFactory: factory2, inject, scope: scope2, durable, provide: providerToken } = provider;
      collection.set(providerToken, new instance_wrapper_1.InstanceWrapper({
        token: providerToken,
        name: (providerToken === null || providerToken === void 0 ? void 0 : providerToken.name) || providerToken,
        metatype: factory2,
        instance: null,
        isResolved: false,
        inject: inject || [],
        scope: scope2,
        durable,
        host: this,
        subtype: enhancerSubtype
      }));
    }
    addCustomUseExisting(provider, collection, enhancerSubtype) {
      const { useExisting, provide: providerToken } = provider;
      collection.set(providerToken, new instance_wrapper_1.InstanceWrapper({
        token: providerToken,
        name: (providerToken === null || providerToken === void 0 ? void 0 : providerToken.name) || providerToken,
        metatype: (instance) => instance,
        instance: null,
        isResolved: false,
        inject: [useExisting],
        host: this,
        isAlias: true,
        subtype: enhancerSubtype
      }));
    }
    addExportedProvider(provider) {
      const addExportedUnit = (token) => this._exports.add(this.validateExportedProvider(token));
      if (this.isCustomProvider(provider)) {
        return this.addCustomExportedProvider(provider);
      } else if ((0, shared_utils_1.isString)(provider) || (0, shared_utils_1.isSymbol)(provider)) {
        return addExportedUnit(provider);
      } else if (this.isDynamicModule(provider)) {
        const { module: moduleClassRef } = provider;
        return addExportedUnit(moduleClassRef);
      }
      addExportedUnit(provider);
    }
    addCustomExportedProvider(provider) {
      const provide = provider.provide;
      if ((0, shared_utils_1.isString)(provide) || (0, shared_utils_1.isSymbol)(provide)) {
        return this._exports.add(this.validateExportedProvider(provide));
      }
      this._exports.add(this.validateExportedProvider(provide));
    }
    validateExportedProvider(token) {
      if (this._providers.has(token)) {
        return token;
      }
      const imports = (0, iterare_1.iterate)(this._imports.values()).filter((item) => !!item).map(({ metatype }) => metatype).filter((metatype) => !!metatype).toArray();
      if (!imports.includes(token)) {
        const { name } = this.metatype;
        const providerName = (0, shared_utils_1.isFunction)(token) ? token.name : token;
        throw new exceptions_1.UnknownExportException(providerName, name);
      }
      return token;
    }
    addController(controller) {
      this._controllers.set(controller, new instance_wrapper_1.InstanceWrapper({
        token: controller,
        name: controller.name,
        metatype: controller,
        instance: null,
        isResolved: false,
        scope: (0, get_class_scope_1.getClassScope)(controller),
        durable: (0, is_durable_1.isDurable)(controller),
        host: this
      }));
      this.assignControllerUniqueId(controller);
    }
    assignControllerUniqueId(controller) {
      Object.defineProperty(controller, constants_2.CONTROLLER_ID_KEY, {
        enumerable: false,
        writable: false,
        configurable: true,
        value: (0, random_string_generator_util_1.randomStringGenerator)()
      });
    }
    addRelatedModule(module2) {
      this._imports.add(module2);
    }
    replace(toReplace, options) {
      if (options.isProvider && this.hasProvider(toReplace)) {
        const originalProvider = this._providers.get(toReplace);
        return originalProvider.mergeWith(Object.assign({ provide: toReplace }, options));
      } else if (!options.isProvider && this.hasInjectable(toReplace)) {
        const originalInjectable = this._injectables.get(toReplace);
        return originalInjectable.mergeWith(Object.assign({ provide: toReplace }, options));
      }
    }
    hasProvider(token) {
      return this._providers.has(token);
    }
    hasInjectable(token) {
      return this._injectables.has(token);
    }
    getProviderByKey(name) {
      return this._providers.get(name);
    }
    getProviderById(id2) {
      return Array.from(this._providers.values()).find((item) => item.id === id2);
    }
    getControllerById(id2) {
      return Array.from(this._controllers.values()).find((item) => item.id === id2);
    }
    getInjectableById(id2) {
      return Array.from(this._injectables.values()).find((item) => item.id === id2);
    }
    getMiddlewareById(id2) {
      return Array.from(this._middlewares.values()).find((item) => item.id === id2);
    }
    getNonAliasProviders() {
      return [...this._providers].filter(([_, wrapper]) => !wrapper.isAlias);
    }
    createModuleReferenceType() {
      const self2 = this;
      return class extends module_ref_1.ModuleRef {
        constructor() {
          super(self2.container);
        }
        get(typeOrToken, options = {}) {
          var _a, _b;
          (_a = options.strict) !== null && _a !== void 0 ? _a : options.strict = true;
          (_b = options.each) !== null && _b !== void 0 ? _b : options.each = false;
          return this.find(typeOrToken, options.strict ? {
            moduleId: self2.id,
            each: options.each
          } : options);
        }
        resolve(typeOrToken, contextId = (0, context_id_factory_1.createContextId)(), options = {}) {
          var _a, _b;
          (_a = options.strict) !== null && _a !== void 0 ? _a : options.strict = true;
          (_b = options.each) !== null && _b !== void 0 ? _b : options.each = false;
          return this.resolvePerContext(typeOrToken, self2, contextId, options);
        }
        async create(type2) {
          if (!(type2 && (0, shared_utils_1.isFunction)(type2) && type2.prototype)) {
            throw new exceptions_1.InvalidClassException(type2);
          }
          return this.instantiateClass(type2, self2);
        }
      };
    }
    isEntryProvider(metatype) {
      return typeof metatype === "function" ? !!Reflect.getMetadata(constants_1.ENTRY_PROVIDER_WATERMARK, metatype) : false;
    }
    generateUuid() {
      var _a, _b, _c;
      const prefix = "M_";
      const key = (_b = (_a = this.name) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : (_c = this.token) === null || _c === void 0 ? void 0 : _c.toString();
      return key ? uuid_factory_1.UuidFactory.get(`${prefix}_${key}`) : (0, random_string_generator_util_1.randomStringGenerator)();
    }
  }
  module$1.Module = Module;
  return module$1;
}
var hasRequiredContainer$1;
function requireContainer$1() {
  if (hasRequiredContainer$1)
    return container$1;
  hasRequiredContainer$1 = 1;
  Object.defineProperty(container$1, "__esModule", { value: true });
  container$1.NestContainer = void 0;
  const constants_1 = requireConstants$4();
  const exceptions_1 = requireExceptions();
  const initialize_on_preview_allowlist_1 = requireInitializeOnPreview_allowlist();
  const serialized_graph_1 = requireSerializedGraph();
  const request_constants_1 = requireRequestConstants();
  const compiler_1 = requireCompiler();
  const internal_core_module_1 = requireInternalCoreModule();
  const internal_providers_storage_1 = requireInternalProvidersStorage();
  const module_1 = requireModule();
  const module_token_factory_1 = requireModuleTokenFactory();
  const modules_container_1 = requireModulesContainer();
  class NestContainer {
    constructor(_applicationConfig = void 0) {
      this._applicationConfig = _applicationConfig;
      this.globalModules = /* @__PURE__ */ new Set();
      this.moduleTokenFactory = new module_token_factory_1.ModuleTokenFactory();
      this.moduleCompiler = new compiler_1.ModuleCompiler(this.moduleTokenFactory);
      this.modules = new modules_container_1.ModulesContainer();
      this.dynamicModulesMetadata = /* @__PURE__ */ new Map();
      this.internalProvidersStorage = new internal_providers_storage_1.InternalProvidersStorage();
      this._serializedGraph = new serialized_graph_1.SerializedGraph();
    }
    get serializedGraph() {
      return this._serializedGraph;
    }
    get applicationConfig() {
      return this._applicationConfig;
    }
    setHttpAdapter(httpAdapter3) {
      this.internalProvidersStorage.httpAdapter = httpAdapter3;
      if (!this.internalProvidersStorage.httpAdapterHost) {
        return;
      }
      const host = this.internalProvidersStorage.httpAdapterHost;
      host.httpAdapter = httpAdapter3;
    }
    getHttpAdapterRef() {
      return this.internalProvidersStorage.httpAdapter;
    }
    getHttpAdapterHostRef() {
      return this.internalProvidersStorage.httpAdapterHost;
    }
    async addModule(metatype, scope2) {
      if (!metatype) {
        throw new exceptions_1.UndefinedForwardRefException(scope2);
      }
      const { type: type2, dynamicMetadata, token } = await this.moduleCompiler.compile(metatype);
      if (this.modules.has(token)) {
        return this.modules.get(token);
      }
      const moduleRef2 = new module_1.Module(type2, this);
      moduleRef2.token = token;
      moduleRef2.initOnPreview = this.shouldInitOnPreview(type2);
      this.modules.set(token, moduleRef2);
      const updatedScope = [].concat(scope2, type2);
      await this.addDynamicMetadata(token, dynamicMetadata, updatedScope);
      if (this.isGlobalModule(type2, dynamicMetadata)) {
        moduleRef2.isGlobal = true;
        this.addGlobalModule(moduleRef2);
      }
      return moduleRef2;
    }
    async addDynamicMetadata(token, dynamicModuleMetadata, scope2) {
      if (!dynamicModuleMetadata) {
        return;
      }
      this.dynamicModulesMetadata.set(token, dynamicModuleMetadata);
      const { imports } = dynamicModuleMetadata;
      await this.addDynamicModules(imports, scope2);
    }
    async addDynamicModules(modules2, scope2) {
      if (!modules2) {
        return;
      }
      await Promise.all(modules2.map((module2) => this.addModule(module2, scope2)));
    }
    isGlobalModule(metatype, dynamicMetadata) {
      if (dynamicMetadata && dynamicMetadata.global) {
        return true;
      }
      return !!Reflect.getMetadata(constants_1.GLOBAL_MODULE_METADATA, metatype);
    }
    addGlobalModule(module2) {
      this.globalModules.add(module2);
    }
    getModules() {
      return this.modules;
    }
    getModuleCompiler() {
      return this.moduleCompiler;
    }
    getModuleByKey(moduleKey) {
      return this.modules.get(moduleKey);
    }
    getInternalCoreModuleRef() {
      return this.internalCoreModule;
    }
    async addImport(relatedModule, token) {
      if (!this.modules.has(token)) {
        return;
      }
      const moduleRef2 = this.modules.get(token);
      const { token: relatedModuleToken } = await this.moduleCompiler.compile(relatedModule);
      const related = this.modules.get(relatedModuleToken);
      moduleRef2.addRelatedModule(related);
    }
    addProvider(provider, token, enhancerSubtype) {
      const moduleRef2 = this.modules.get(token);
      if (!provider) {
        throw new exceptions_1.CircularDependencyException(moduleRef2 === null || moduleRef2 === void 0 ? void 0 : moduleRef2.metatype.name);
      }
      if (!moduleRef2) {
        throw new exceptions_1.UnknownModuleException();
      }
      return moduleRef2.addProvider(provider, enhancerSubtype);
    }
    addInjectable(injectable, token, enhancerSubtype, host) {
      if (!this.modules.has(token)) {
        throw new exceptions_1.UnknownModuleException();
      }
      const moduleRef2 = this.modules.get(token);
      return moduleRef2.addInjectable(injectable, enhancerSubtype, host);
    }
    addExportedProvider(provider, token) {
      if (!this.modules.has(token)) {
        throw new exceptions_1.UnknownModuleException();
      }
      const moduleRef2 = this.modules.get(token);
      moduleRef2.addExportedProvider(provider);
    }
    addController(controller, token) {
      if (!this.modules.has(token)) {
        throw new exceptions_1.UnknownModuleException();
      }
      const moduleRef2 = this.modules.get(token);
      moduleRef2.addController(controller);
    }
    clear() {
      this.modules.clear();
    }
    replace(toReplace, options) {
      this.modules.forEach((moduleRef2) => moduleRef2.replace(toReplace, options));
    }
    bindGlobalScope() {
      this.modules.forEach((moduleRef2) => this.bindGlobalsToImports(moduleRef2));
    }
    bindGlobalsToImports(moduleRef2) {
      this.globalModules.forEach((globalModule) => this.bindGlobalModuleToModule(moduleRef2, globalModule));
    }
    bindGlobalModuleToModule(target, globalModule) {
      if (target === globalModule || target === this.internalCoreModule) {
        return;
      }
      target.addRelatedModule(globalModule);
    }
    getDynamicMetadataByToken(token, metadataKey) {
      var _a;
      const metadata2 = this.dynamicModulesMetadata.get(token);
      return metadataKey ? (_a = metadata2 === null || metadata2 === void 0 ? void 0 : metadata2[metadataKey]) !== null && _a !== void 0 ? _a : [] : metadata2;
    }
    registerCoreModuleRef(moduleRef2) {
      this.internalCoreModule = moduleRef2;
      this.modules[internal_core_module_1.InternalCoreModule.name] = moduleRef2;
    }
    getModuleTokenFactory() {
      return this.moduleTokenFactory;
    }
    registerRequestProvider(request2, contextId) {
      const wrapper = this.internalCoreModule.getProviderByKey(request_constants_1.REQUEST);
      wrapper.setInstanceByContextId(contextId, {
        instance: request2,
        isResolved: true
      });
    }
    shouldInitOnPreview(type2) {
      return initialize_on_preview_allowlist_1.InitializeOnPreviewAllowlist.has(type2);
    }
  }
  container$1.NestContainer = NestContainer;
  return container$1;
}
var hasRequiredInjector;
function requireInjector() {
  if (hasRequiredInjector)
    return injector$1;
  hasRequiredInjector = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireContainer$1(), exports2);
    tslib_1.__exportStar(requireInquirer(), exports2);
    tslib_1.__exportStar(requireLazyModuleLoader(), exports2);
    tslib_1.__exportStar(requireModuleRef(), exports2);
    tslib_1.__exportStar(requireModulesContainer(), exports2);
  })(injector$1);
  return injector$1;
}
var inspector = {};
var graphInspector = {};
var partialGraph_host = {};
var hasRequiredPartialGraph_host;
function requirePartialGraph_host() {
  if (hasRequiredPartialGraph_host)
    return partialGraph_host;
  hasRequiredPartialGraph_host = 1;
  Object.defineProperty(partialGraph_host, "__esModule", { value: true });
  partialGraph_host.PartialGraphHost = void 0;
  class PartialGraphHost {
    static toJSON() {
      var _a;
      return (_a = this.partialGraph) === null || _a === void 0 ? void 0 : _a.toJSON();
    }
    static toString() {
      var _a;
      return (_a = this.partialGraph) === null || _a === void 0 ? void 0 : _a.toString();
    }
    static register(partialGraph) {
      this.partialGraph = partialGraph;
    }
  }
  partialGraph_host.PartialGraphHost = PartialGraphHost;
  return partialGraph_host;
}
var hasRequiredGraphInspector;
function requireGraphInspector() {
  if (hasRequiredGraphInspector)
    return graphInspector;
  hasRequiredGraphInspector = 1;
  Object.defineProperty(graphInspector, "__esModule", { value: true });
  graphInspector.GraphInspector = void 0;
  const unknown_dependencies_exception_1 = requireUnknownDependencies_exception();
  const deterministic_uuid_registry_1 = requireDeterministicUuidRegistry();
  const partial_graph_host_1 = requirePartialGraph_host();
  class GraphInspector {
    constructor(container2) {
      this.container = container2;
      this.enhancersMetadataCache = new Array();
      this.graph = container2.serializedGraph;
    }
    inspectModules(modules2 = this.container.getModules()) {
      for (const moduleRef2 of modules2.values()) {
        this.insertModuleNode(moduleRef2);
        this.insertClassNodes(moduleRef2);
        this.insertModuleToModuleEdges(moduleRef2);
      }
      this.enhancersMetadataCache.forEach((entry) => this.insertEnhancerEdge(entry));
      deterministic_uuid_registry_1.DeterministicUuidRegistry.clear();
    }
    registerPartial(error2) {
      var _a, _b;
      this.graph.status = "partial";
      if (error2 instanceof unknown_dependencies_exception_1.UnknownDependenciesException) {
        this.graph.metadata = {
          cause: {
            type: "unknown-dependencies",
            context: error2.context,
            moduleId: (_a = error2.moduleRef) === null || _a === void 0 ? void 0 : _a.id,
            nodeId: (_b = error2.metadata) === null || _b === void 0 ? void 0 : _b.id
          }
        };
      } else {
        this.graph.metadata = {
          cause: {
            type: "unknown",
            error: error2
          }
        };
      }
      partial_graph_host_1.PartialGraphHost.register(this.graph);
    }
    inspectInstanceWrapper(source2, moduleRef2) {
      const ctorMetadata = source2.getCtorMetadata();
      ctorMetadata === null || ctorMetadata === void 0 ? void 0 : ctorMetadata.forEach((target, index) => this.insertClassToClassEdge(source2, target, moduleRef2, index, "constructor"));
      const propertiesMetadata = source2.getPropertiesMetadata();
      propertiesMetadata === null || propertiesMetadata === void 0 ? void 0 : propertiesMetadata.forEach(({ key, wrapper: target }) => this.insertClassToClassEdge(source2, target, moduleRef2, key, "property"));
    }
    insertEnhancerMetadataCache(entry) {
      this.enhancersMetadataCache.push(entry);
    }
    insertOrphanedEnhancer(entry) {
      var _a, _b, _c;
      this.graph.insertOrphanedEnhancer(Object.assign(Object.assign({}, entry), { ref: (_c = (_b = (_a = entry.ref) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : "Object" }));
    }
    insertAttachedEnhancer(wrapper) {
      const existingNode = this.graph.getNodeById(wrapper.id);
      existingNode.metadata.global = true;
      this.graph.insertAttachedEnhancer(existingNode.id);
    }
    insertEntrypointDefinition(definition, parentId) {
      definition = Object.assign(Object.assign({}, definition), { id: `${definition.classNodeId}_${definition.methodName}` });
      this.graph.insertEntrypoint(definition, parentId);
    }
    insertClassNode(moduleRef2, wrapper, type2) {
      this.graph.insertNode({
        id: wrapper.id,
        label: wrapper.name,
        parent: moduleRef2.id,
        metadata: {
          type: type2,
          internal: wrapper.metatype === moduleRef2.metatype,
          sourceModuleName: moduleRef2.name,
          durable: wrapper.isDependencyTreeDurable(),
          static: wrapper.isDependencyTreeStatic(),
          scope: wrapper.scope,
          transient: wrapper.isTransient,
          exported: moduleRef2.exports.has(wrapper.token),
          token: wrapper.token,
          subtype: wrapper.subtype,
          initTime: wrapper.initTime
        }
      });
    }
    insertModuleNode(moduleRef2) {
      const dynamicMetadata = this.container.getDynamicMetadataByToken(moduleRef2.token);
      const node2 = {
        id: moduleRef2.id,
        label: moduleRef2.name,
        metadata: {
          type: "module",
          global: moduleRef2.isGlobal,
          dynamic: !!dynamicMetadata,
          internal: moduleRef2.name === "InternalCoreModule"
        }
      };
      this.graph.insertNode(node2);
    }
    insertModuleToModuleEdges(moduleRef2) {
      for (const targetModuleRef of moduleRef2.imports) {
        this.graph.insertEdge({
          source: moduleRef2.id,
          target: targetModuleRef.id,
          metadata: {
            type: "module-to-module",
            sourceModuleName: moduleRef2.name,
            targetModuleName: targetModuleRef.name
          }
        });
      }
    }
    insertEnhancerEdge(entry) {
      var _a, _b, _c, _d;
      const moduleRef2 = this.container.getModuleByKey(entry.moduleToken);
      const sourceInstanceWrapper = (_a = moduleRef2.controllers.get(entry.classRef)) !== null && _a !== void 0 ? _a : moduleRef2.providers.get(entry.classRef);
      const existingSourceNode = this.graph.getNodeById(sourceInstanceWrapper.id);
      const enhancers = (_b = existingSourceNode.metadata.enhancers) !== null && _b !== void 0 ? _b : [];
      if (entry.enhancerInstanceWrapper) {
        this.insertClassToClassEdge(sourceInstanceWrapper, entry.enhancerInstanceWrapper, moduleRef2, void 0, "decorator");
        enhancers.push({
          id: entry.enhancerInstanceWrapper.id,
          methodKey: entry.methodKey,
          subtype: entry.subtype
        });
      } else {
        const name = (_d = (_c = entry.enhancerRef.constructor) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : entry.enhancerRef.name;
        enhancers.push({
          name,
          methodKey: entry.methodKey,
          subtype: entry.subtype
        });
      }
      existingSourceNode.metadata.enhancers = enhancers;
    }
    insertClassToClassEdge(source2, target, moduleRef2, keyOrIndex, injectionType) {
      var _a;
      this.graph.insertEdge({
        source: source2.id,
        target: target.id,
        metadata: {
          type: "class-to-class",
          sourceModuleName: moduleRef2.name,
          sourceClassName: source2.name,
          targetClassName: target.name,
          sourceClassToken: source2.token,
          targetClassToken: target.token,
          targetModuleName: (_a = target.host) === null || _a === void 0 ? void 0 : _a.name,
          keyOrIndex,
          injectionType
        }
      });
    }
    insertClassNodes(moduleRef2) {
      moduleRef2.providers.forEach((value) => this.insertClassNode(moduleRef2, value, "provider"));
      moduleRef2.injectables.forEach((value) => this.insertClassNode(moduleRef2, value, "injectable"));
      moduleRef2.controllers.forEach((value) => this.insertClassNode(moduleRef2, value, "controller"));
    }
  }
  graphInspector.GraphInspector = GraphInspector;
  return graphInspector;
}
var hasRequiredInspector;
function requireInspector() {
  if (hasRequiredInspector)
    return inspector;
  hasRequiredInspector = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireGraphInspector(), exports2);
    tslib_1.__exportStar(requireInitializeOnPreview_allowlist(), exports2);
    tslib_1.__exportStar(requirePartialGraph_host(), exports2);
    tslib_1.__exportStar(requireSerializedGraph(), exports2);
  })(inspector);
  return inspector;
}
var middleware = {};
var builder = {};
var utils$8 = {};
var pathToRegexp$1 = { exports: {} };
var hasRequiredPathToRegexp$1;
function requirePathToRegexp$1() {
  if (hasRequiredPathToRegexp$1)
    return pathToRegexp$1.exports;
  hasRequiredPathToRegexp$1 = 1;
  pathToRegexp$1.exports = pathToRegexp2;
  pathToRegexp$1.exports.match = match;
  pathToRegexp$1.exports.regexpToFunction = regexpToFunction;
  pathToRegexp$1.exports.parse = parse2;
  pathToRegexp$1.exports.compile = compile2;
  pathToRegexp$1.exports.tokensToFunction = tokensToFunction;
  pathToRegexp$1.exports.tokensToRegExp = tokensToRegExp;
  var DEFAULT_DELIMITER = "/";
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    "(\\\\.)",
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
    // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
    "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"
  ].join("|"), "g");
  function parse2(str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path2 = "";
    var defaultDelimiter = options && options.delimiter || DEFAULT_DELIMITER;
    var whitelist = options && options.whitelist || void 0;
    var pathEscaped = false;
    var res;
    while ((res = PATH_REGEXP.exec(str)) !== null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path2 += str.slice(index, offset);
      index = offset + m.length;
      if (escaped) {
        path2 += escaped[1];
        pathEscaped = true;
        continue;
      }
      var prev = "";
      var name = res[2];
      var capture = res[3];
      var group = res[4];
      var modifier = res[5];
      if (!pathEscaped && path2.length) {
        var k = path2.length - 1;
        var c = path2[k];
        var matches = whitelist ? whitelist.indexOf(c) > -1 : true;
        if (matches) {
          prev = c;
          path2 = path2.slice(0, k);
        }
      }
      if (path2) {
        tokens.push(path2);
        path2 = "";
        pathEscaped = false;
      }
      var repeat2 = modifier === "+" || modifier === "*";
      var optional = modifier === "?" || modifier === "*";
      var pattern2 = capture || group;
      var delimiter = prev || defaultDelimiter;
      tokens.push({
        name: name || key++,
        prefix: prev,
        delimiter,
        optional,
        repeat: repeat2,
        pattern: pattern2 ? escapeGroup(pattern2) : "[^" + escapeString(delimiter === defaultDelimiter ? delimiter : delimiter + defaultDelimiter) + "]+?"
      });
    }
    if (path2 || index < str.length) {
      tokens.push(path2 + str.substr(index));
    }
    return tokens;
  }
  function compile2(str, options) {
    return tokensToFunction(parse2(str, options), options);
  }
  function match(str, options) {
    var keys = [];
    var re2 = pathToRegexp2(str, keys, options);
    return regexpToFunction(re2, keys);
  }
  function regexpToFunction(re2, keys) {
    return function(pathname, options) {
      var m = re2.exec(pathname);
      if (!m)
        return false;
      var path2 = m[0];
      var index = m.index;
      var params = {};
      var decode = options && options.decode || decodeURIComponent;
      for (var i = 1; i < m.length; i++) {
        if (m[i] === void 0)
          continue;
        var key = keys[i - 1];
        if (key.repeat) {
          params[key.name] = m[i].split(key.delimiter).map(function(value) {
            return decode(value, key);
          });
        } else {
          params[key.name] = decode(m[i], key);
        }
      }
      return { path: path2, index, params };
    };
  }
  function tokensToFunction(tokens, options) {
    var matches = new Array(tokens.length);
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === "object") {
        matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$", flags(options));
      }
    }
    return function(data, options2) {
      var path2 = "";
      var encode2 = options2 && options2.encode || encodeURIComponent;
      var validate2 = options2 ? options2.validate !== false : true;
      for (var i2 = 0; i2 < tokens.length; i2++) {
        var token = tokens[i2];
        if (typeof token === "string") {
          path2 += token;
          continue;
        }
        var value = data ? data[token.name] : void 0;
        var segment;
        if (Array.isArray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but got array');
          }
          if (value.length === 0) {
            if (token.optional)
              continue;
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
          for (var j = 0; j < value.length; j++) {
            segment = encode2(value[j], token);
            if (validate2 && !matches[i2].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"');
            }
            path2 += (j === 0 ? token.prefix : token.delimiter) + segment;
          }
          continue;
        }
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          segment = encode2(String(value), token);
          if (validate2 && !matches[i2].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
          }
          path2 += token.prefix + segment;
          continue;
        }
        if (token.optional)
          continue;
        throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? "an array" : "a string"));
      }
      return path2;
    };
  }
  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
  }
  function escapeGroup(group) {
    return group.replace(/([=!:$/()])/g, "\\$1");
  }
  function flags(options) {
    return options && options.sensitive ? "" : "i";
  }
  function regexpToRegexp(path2, keys) {
    if (!keys)
      return path2;
    var groups = path2.source.match(/\((?!\?)/g);
    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          pattern: null
        });
      }
    }
    return path2;
  }
  function arrayToRegexp(path2, keys, options) {
    var parts = [];
    for (var i = 0; i < path2.length; i++) {
      parts.push(pathToRegexp2(path2[i], keys, options).source);
    }
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
  }
  function stringToRegexp(path2, keys, options) {
    return tokensToRegExp(parse2(path2, options), keys, options);
  }
  function tokensToRegExp(tokens, keys, options) {
    options = options || {};
    var strict = options.strict;
    var start = options.start !== false;
    var end = options.end !== false;
    var delimiter = options.delimiter || DEFAULT_DELIMITER;
    var endsWith2 = [].concat(options.endsWith || []).map(escapeString).concat("$").join("|");
    var route2 = start ? "^" : "";
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (typeof token === "string") {
        route2 += escapeString(token);
      } else {
        var capture = token.repeat ? "(?:" + token.pattern + ")(?:" + escapeString(token.delimiter) + "(?:" + token.pattern + "))*" : token.pattern;
        if (keys)
          keys.push(token);
        if (token.optional) {
          if (!token.prefix) {
            route2 += "(" + capture + ")?";
          } else {
            route2 += "(?:" + escapeString(token.prefix) + "(" + capture + "))?";
          }
        } else {
          route2 += escapeString(token.prefix) + "(" + capture + ")";
        }
      }
    }
    if (end) {
      if (!strict)
        route2 += "(?:" + escapeString(delimiter) + ")?";
      route2 += endsWith2 === "$" ? "$" : "(?=" + endsWith2 + ")";
    } else {
      var endToken = tokens[tokens.length - 1];
      var isEndDelimited = typeof endToken === "string" ? endToken[endToken.length - 1] === delimiter : endToken === void 0;
      if (!strict)
        route2 += "(?:" + escapeString(delimiter) + "(?=" + endsWith2 + "))?";
      if (!isEndDelimited)
        route2 += "(?=" + escapeString(delimiter) + "|" + endsWith2 + ")";
    }
    return new RegExp(route2, flags(options));
  }
  function pathToRegexp2(path2, keys, options) {
    if (path2 instanceof RegExp) {
      return regexpToRegexp(path2, keys);
    }
    if (Array.isArray(path2)) {
      return arrayToRegexp(
        /** @type {!Array} */
        path2,
        keys,
        options
      );
    }
    return stringToRegexp(
      /** @type {string} */
      path2,
      keys,
      options
    );
  }
  return pathToRegexp$1.exports;
}
var utils$7 = {};
var excludeRoute_util = {};
var hasRequiredExcludeRoute_util;
function requireExcludeRoute_util() {
  if (hasRequiredExcludeRoute_util)
    return excludeRoute_util;
  hasRequiredExcludeRoute_util = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isRouteExcluded = exports2.isRequestMethodAll = void 0;
    const common_1 = requireCommon$3();
    const shared_utils_1 = requireShared_utils();
    const isRequestMethodAll = (method) => {
      return common_1.RequestMethod.ALL === method || method === -1;
    };
    exports2.isRequestMethodAll = isRequestMethodAll;
    function isRouteExcluded(excludedRoutes, path2, requestMethod) {
      return excludedRoutes.some((route2) => {
        if ((0, exports2.isRequestMethodAll)(route2.requestMethod) || route2.requestMethod === requestMethod) {
          return route2.pathRegex.exec((0, shared_utils_1.addLeadingSlash)(path2));
        }
        return false;
      });
    }
    exports2.isRouteExcluded = isRouteExcluded;
  })(excludeRoute_util);
  return excludeRoute_util;
}
var flattenRoutePaths_util = {};
var hasRequiredFlattenRoutePaths_util;
function requireFlattenRoutePaths_util() {
  if (hasRequiredFlattenRoutePaths_util)
    return flattenRoutePaths_util;
  hasRequiredFlattenRoutePaths_util = 1;
  Object.defineProperty(flattenRoutePaths_util, "__esModule", { value: true });
  flattenRoutePaths_util.flattenRoutePaths = void 0;
  const shared_utils_1 = requireShared_utils();
  function flattenRoutePaths(routes) {
    const result = [];
    routes.forEach((item) => {
      if (item.module && item.path) {
        result.push({ module: item.module, path: item.path });
      }
      if (item.children) {
        const childrenRef = item.children;
        childrenRef.forEach((child) => {
          if (!(0, shared_utils_1.isString)(child) && child.path) {
            child.path = (0, shared_utils_1.normalizePath)((0, shared_utils_1.normalizePath)(item.path) + (0, shared_utils_1.normalizePath)(child.path));
          } else {
            result.push({ path: item.path, module: child });
          }
        });
        result.push(...flattenRoutePaths(childrenRef));
      }
    });
    return result;
  }
  flattenRoutePaths_util.flattenRoutePaths = flattenRoutePaths;
  return flattenRoutePaths_util;
}
var hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4)
    return utils$7;
  hasRequiredUtils$4 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireExcludeRoute_util(), exports2);
    tslib_1.__exportStar(requireFlattenRoutePaths_util(), exports2);
  })(utils$7);
  return utils$7;
}
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3)
    return utils$8;
  hasRequiredUtils$3 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMiddlewareRouteExcluded = exports2.assignToken = exports2.isMiddlewareClass = exports2.mapToClass = exports2.filterMiddleware = exports2.mapToExcludeRoute = void 0;
    const common_1 = requireCommon$3();
    const shared_utils_1 = requireShared_utils();
    const iterare_1 = requireLib$4();
    const pathToRegexp2 = requirePathToRegexp$1();
    const uid_1 = requireDist$1();
    const utils_12 = requireUtils$4();
    const mapToExcludeRoute = (routes) => {
      return routes.map((route2) => {
        if ((0, shared_utils_1.isString)(route2)) {
          return {
            path: route2,
            requestMethod: common_1.RequestMethod.ALL,
            pathRegex: pathToRegexp2((0, shared_utils_1.addLeadingSlash)(route2))
          };
        }
        return {
          path: route2.path,
          requestMethod: route2.method,
          pathRegex: pathToRegexp2((0, shared_utils_1.addLeadingSlash)(route2.path))
        };
      });
    };
    exports2.mapToExcludeRoute = mapToExcludeRoute;
    const filterMiddleware = (middleware2, routes, httpAdapter3) => {
      const excludedRoutes = (0, exports2.mapToExcludeRoute)(routes);
      return (0, iterare_1.iterate)([]).concat(middleware2).filter(shared_utils_1.isFunction).map((item) => (0, exports2.mapToClass)(item, excludedRoutes, httpAdapter3)).toArray();
    };
    exports2.filterMiddleware = filterMiddleware;
    const mapToClass = (middleware2, excludedRoutes, httpAdapter3) => {
      if (isMiddlewareClass(middleware2)) {
        if (excludedRoutes.length <= 0) {
          return middleware2;
        }
        const MiddlewareHost = class extends middleware2 {
          use(...params) {
            const [req, _, next] = params;
            const isExcluded = isMiddlewareRouteExcluded(req, excludedRoutes, httpAdapter3);
            if (isExcluded) {
              return next();
            }
            return super.use(...params);
          }
        };
        return assignToken(MiddlewareHost, middleware2.name);
      }
      return assignToken(class {
        constructor() {
          this.use = (...params) => {
            const [req, _, next] = params;
            const isExcluded = isMiddlewareRouteExcluded(req, excludedRoutes, httpAdapter3);
            if (isExcluded) {
              return next();
            }
            return middleware2(...params);
          };
        }
      });
    };
    exports2.mapToClass = mapToClass;
    function isMiddlewareClass(middleware2) {
      var _a, _b;
      const middlewareStr = middleware2.toString();
      if (middlewareStr.substring(0, 5) === "class") {
        return true;
      }
      const middlewareArr = middlewareStr.split(" ");
      return middlewareArr[0] === "function" && /[A-Z]/.test((_a = middlewareArr[1]) === null || _a === void 0 ? void 0 : _a[0]) && (0, shared_utils_1.isFunction)((_b = middleware2.prototype) === null || _b === void 0 ? void 0 : _b.use);
    }
    exports2.isMiddlewareClass = isMiddlewareClass;
    function assignToken(metatype, token = (0, uid_1.uid)(21)) {
      Object.defineProperty(metatype, "name", { value: token });
      return metatype;
    }
    exports2.assignToken = assignToken;
    function isMiddlewareRouteExcluded(req, excludedRoutes, httpAdapter3) {
      if (excludedRoutes.length <= 0) {
        return false;
      }
      const reqMethod = httpAdapter3.getRequestMethod(req);
      const originalUrl = httpAdapter3.getRequestUrl(req);
      const queryParamsIndex = originalUrl && originalUrl.indexOf("?");
      const pathname = queryParamsIndex >= 0 ? originalUrl.slice(0, queryParamsIndex) : originalUrl;
      return (0, utils_12.isRouteExcluded)(excludedRoutes, pathname, common_1.RequestMethod[reqMethod]);
    }
    exports2.isMiddlewareRouteExcluded = isMiddlewareRouteExcluded;
  })(utils$8);
  return utils$8;
}
var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder)
    return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", { value: true });
  builder.MiddlewareBuilder = void 0;
  const dependencies_decorator_1 = requireDependencies_decorator();
  const iterare_1 = requireLib$4();
  const utils_12 = requireUtils$3();
  class MiddlewareBuilder {
    constructor(routesMapper2, httpAdapter3, routeInfoPathExtractor2) {
      this.routesMapper = routesMapper2;
      this.httpAdapter = httpAdapter3;
      this.routeInfoPathExtractor = routeInfoPathExtractor2;
      this.middlewareCollection = /* @__PURE__ */ new Set();
    }
    apply(...middleware2) {
      return new MiddlewareBuilder.ConfigProxy(this, (0, dependencies_decorator_1.flatten)(middleware2), this.routeInfoPathExtractor);
    }
    build() {
      return [...this.middlewareCollection];
    }
    getHttpAdapter() {
      return this.httpAdapter;
    }
  }
  MiddlewareBuilder.ConfigProxy = class {
    constructor(builder2, middleware2, routeInfoPathExtractor2) {
      this.builder = builder2;
      this.middleware = middleware2;
      this.routeInfoPathExtractor = routeInfoPathExtractor2;
      this.excludedRoutes = [];
    }
    getExcludedRoutes() {
      return this.excludedRoutes;
    }
    exclude(...routes) {
      this.excludedRoutes = this.getRoutesFlatList(routes).map((route2) => Object.assign(Object.assign({}, route2), { path: this.routeInfoPathExtractor.extractPathFrom(route2) }));
      return this;
    }
    forRoutes(...routes) {
      const { middlewareCollection } = this.builder;
      const forRoutes = this.getRoutesFlatList(routes);
      const configuration = {
        middleware: (0, utils_12.filterMiddleware)(this.middleware, this.excludedRoutes, this.builder.getHttpAdapter()),
        forRoutes
      };
      middlewareCollection.add(configuration);
      return this.builder;
    }
    getRoutesFlatList(routes) {
      const { routesMapper: routesMapper2 } = this.builder;
      return (0, iterare_1.iterate)(routes).map((route2) => routesMapper2.mapRouteToRouteInfo(route2)).flatten().toArray();
    }
  };
  builder.MiddlewareBuilder = MiddlewareBuilder;
  return builder;
}
var hasRequiredMiddleware;
function requireMiddleware() {
  if (hasRequiredMiddleware)
    return middleware;
  hasRequiredMiddleware = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireBuilder(), exports2);
  })(middleware);
  return middleware;
}
var nestApplication = {};
var optionalRequire = {};
var hasRequiredOptionalRequire;
function requireOptionalRequire() {
  if (hasRequiredOptionalRequire)
    return optionalRequire;
  hasRequiredOptionalRequire = 1;
  Object.defineProperty(optionalRequire, "__esModule", { value: true });
  optionalRequire.optionalRequire = void 0;
  function optionalRequire$1(packageName, loaderFn) {
    try {
      return loaderFn ? loaderFn() : commonjsRequire(packageName);
    } catch (e) {
      return {};
    }
  }
  optionalRequire.optionalRequire = optionalRequire$1;
  return optionalRequire;
}
var container = {};
var hasRequiredContainer;
function requireContainer() {
  if (hasRequiredContainer)
    return container;
  hasRequiredContainer = 1;
  Object.defineProperty(container, "__esModule", { value: true });
  container.MiddlewareContainer = void 0;
  const get_class_scope_1 = requireGetClassScope();
  const is_durable_1 = requireIsDurable();
  const instance_wrapper_1 = requireInstanceWrapper();
  class MiddlewareContainer {
    constructor(container2) {
      this.container = container2;
      this.middleware = /* @__PURE__ */ new Map();
      this.configurationSets = /* @__PURE__ */ new Map();
    }
    getMiddlewareCollection(moduleKey) {
      if (!this.middleware.has(moduleKey)) {
        const moduleRef2 = this.container.getModuleByKey(moduleKey);
        this.middleware.set(moduleKey, moduleRef2.middlewares);
      }
      return this.middleware.get(moduleKey);
    }
    getConfigurations() {
      return this.configurationSets;
    }
    insertConfig(configList, moduleKey) {
      const middleware2 = this.getMiddlewareCollection(moduleKey);
      const targetConfig = this.getTargetConfig(moduleKey);
      const configurations = configList || [];
      const insertMiddleware = (metatype) => {
        var _a;
        const token = metatype;
        middleware2.set(token, new instance_wrapper_1.InstanceWrapper({
          scope: (0, get_class_scope_1.getClassScope)(metatype),
          durable: (0, is_durable_1.isDurable)(metatype),
          name: (_a = token === null || token === void 0 ? void 0 : token.name) !== null && _a !== void 0 ? _a : token,
          metatype,
          token
        }));
      };
      configurations.forEach((config2) => {
        [].concat(config2.middleware).map(insertMiddleware);
        targetConfig.add(config2);
      });
    }
    getTargetConfig(moduleName) {
      if (!this.configurationSets.has(moduleName)) {
        this.configurationSets.set(moduleName, /* @__PURE__ */ new Set());
      }
      return this.configurationSets.get(moduleName);
    }
  }
  container.MiddlewareContainer = MiddlewareContainer;
  return container;
}
var middlewareModule = {};
var invalidMiddleware_exception = {};
var hasRequiredInvalidMiddleware_exception;
function requireInvalidMiddleware_exception() {
  if (hasRequiredInvalidMiddleware_exception)
    return invalidMiddleware_exception;
  hasRequiredInvalidMiddleware_exception = 1;
  Object.defineProperty(invalidMiddleware_exception, "__esModule", { value: true });
  invalidMiddleware_exception.InvalidMiddlewareException = void 0;
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class InvalidMiddlewareException extends runtime_exception_1.RuntimeException {
    constructor(name) {
      super((0, messages_1.INVALID_MIDDLEWARE_MESSAGE)`${name}`);
    }
  }
  invalidMiddleware_exception.InvalidMiddlewareException = InvalidMiddlewareException;
  return invalidMiddleware_exception;
}
var routerExceptionFilters = {};
var exceptionsHandler = {};
var hasRequiredExceptionsHandler;
function requireExceptionsHandler() {
  if (hasRequiredExceptionsHandler)
    return exceptionsHandler;
  hasRequiredExceptionsHandler = 1;
  Object.defineProperty(exceptionsHandler, "__esModule", { value: true });
  exceptionsHandler.ExceptionsHandler = void 0;
  const shared_utils_1 = requireShared_utils();
  const invalid_exception_filter_exception_1 = requireInvalidExceptionFilter_exception();
  const base_exception_filter_1 = requireBaseExceptionFilter();
  class ExceptionsHandler extends base_exception_filter_1.BaseExceptionFilter {
    constructor() {
      super(...arguments);
      this.filters = [];
    }
    next(exception, ctx) {
      if (this.invokeCustomFilters(exception, ctx)) {
        return;
      }
      super.catch(exception, ctx);
    }
    setCustomFilters(filters) {
      if (!Array.isArray(filters)) {
        throw new invalid_exception_filter_exception_1.InvalidExceptionFilterException();
      }
      this.filters = filters;
    }
    invokeCustomFilters(exception, ctx) {
      if ((0, shared_utils_1.isEmpty)(this.filters)) {
        return false;
      }
      const isInstanceOf = (metatype) => exception instanceof metatype;
      const filter3 = this.filters.find(({ exceptionMetatypes }) => {
        const typeExists = !exceptionMetatypes.length || exceptionMetatypes.some(isInstanceOf);
        return typeExists;
      });
      filter3 && filter3.func(exception, ctx);
      return !!filter3;
    }
  }
  exceptionsHandler.ExceptionsHandler = ExceptionsHandler;
  return exceptionsHandler;
}
var hasRequiredRouterExceptionFilters;
function requireRouterExceptionFilters() {
  if (hasRequiredRouterExceptionFilters)
    return routerExceptionFilters;
  hasRequiredRouterExceptionFilters = 1;
  Object.defineProperty(routerExceptionFilters, "__esModule", { value: true });
  routerExceptionFilters.RouterExceptionFilters = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const base_exception_filter_context_1 = requireBaseExceptionFilterContext();
  const exceptions_handler_1 = requireExceptionsHandler();
  const constants_2 = requireConstants$2();
  const iterare_1 = requireLib$4();
  class RouterExceptionFilters extends base_exception_filter_context_1.BaseExceptionFilterContext {
    constructor(container2, config2, applicationRef) {
      super(container2);
      this.config = config2;
      this.applicationRef = applicationRef;
    }
    create(instance, callback, moduleKey, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      this.moduleContext = moduleKey;
      const exceptionHandler2 = new exceptions_handler_1.ExceptionsHandler(this.applicationRef);
      const filters = this.createContext(instance, callback, constants_1.EXCEPTION_FILTERS_METADATA, contextId, inquirerId);
      if ((0, shared_utils_1.isEmpty)(filters)) {
        return exceptionHandler2;
      }
      exceptionHandler2.setCustomFilters(filters.reverse());
      return exceptionHandler2;
    }
    getGlobalMetadata(contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      const globalFilters = this.config.getGlobalFilters();
      if (contextId === constants_2.STATIC_CONTEXT && !inquirerId) {
        return globalFilters;
      }
      const scopedFilterWrappers = this.config.getGlobalRequestFilters();
      const scopedFilters = (0, iterare_1.iterate)(scopedFilterWrappers).map((wrapper) => wrapper.getInstanceByContextId(contextId, inquirerId)).filter((host) => !!host).map((host) => host.instance).toArray();
      return globalFilters.concat(scopedFilters);
    }
  }
  routerExceptionFilters.RouterExceptionFilters = RouterExceptionFilters;
  return routerExceptionFilters;
}
var routerProxy = {};
var hasRequiredRouterProxy;
function requireRouterProxy() {
  if (hasRequiredRouterProxy)
    return routerProxy;
  hasRequiredRouterProxy = 1;
  Object.defineProperty(routerProxy, "__esModule", { value: true });
  routerProxy.RouterProxy = void 0;
  const execution_context_host_1 = requireExecutionContextHost();
  class RouterProxy {
    createProxy(targetCallback, exceptionsHandler2) {
      return async (req, res, next) => {
        try {
          await targetCallback(req, res, next);
        } catch (e) {
          const host = new execution_context_host_1.ExecutionContextHost([req, res, next]);
          exceptionsHandler2.next(e, host);
          return res;
        }
      };
    }
    createExceptionLayerProxy(targetCallback, exceptionsHandler2) {
      return async (err, req, res, next) => {
        try {
          await targetCallback(err, req, res, next);
        } catch (e) {
          const host = new execution_context_host_1.ExecutionContextHost([req, res, next]);
          exceptionsHandler2.next(e, host);
          return res;
        }
      };
    }
  }
  routerProxy.RouterProxy = RouterProxy;
  return routerProxy;
}
var resolver = {};
var hasRequiredResolver;
function requireResolver() {
  if (hasRequiredResolver)
    return resolver;
  hasRequiredResolver = 1;
  Object.defineProperty(resolver, "__esModule", { value: true });
  resolver.MiddlewareResolver = void 0;
  class MiddlewareResolver {
    constructor(middlewareContainer, injector2) {
      this.middlewareContainer = middlewareContainer;
      this.injector = injector2;
    }
    async resolveInstances(moduleRef2, moduleName) {
      const middlewareMap = this.middlewareContainer.getMiddlewareCollection(moduleName);
      const resolveInstance = async (wrapper) => this.resolveMiddlewareInstance(wrapper, middlewareMap, moduleRef2);
      await Promise.all([...middlewareMap.values()].map(resolveInstance));
    }
    async resolveMiddlewareInstance(wrapper, middlewareMap, moduleRef2) {
      await this.injector.loadMiddleware(wrapper, middlewareMap, moduleRef2);
    }
  }
  resolver.MiddlewareResolver = MiddlewareResolver;
  return resolver;
}
var routeInfoPathExtractor = {};
var routePathFactory = {};
var hasRequiredRoutePathFactory;
function requireRoutePathFactory() {
  if (hasRequiredRoutePathFactory)
    return routePathFactory;
  hasRequiredRoutePathFactory = 1;
  Object.defineProperty(routePathFactory, "__esModule", { value: true });
  routePathFactory.RoutePathFactory = void 0;
  const common_1 = requireCommon$3();
  const shared_utils_1 = requireShared_utils();
  const utils_12 = requireUtils$4();
  class RoutePathFactory {
    constructor(applicationConfig2) {
      this.applicationConfig = applicationConfig2;
    }
    create(metadata2, requestMethod) {
      var _a;
      let paths = [""];
      const versionOrVersions = this.getVersion(metadata2);
      if (versionOrVersions && ((_a = metadata2.versioningOptions) === null || _a === void 0 ? void 0 : _a.type) === common_1.VersioningType.URI) {
        const versionPrefix = this.getVersionPrefix(metadata2.versioningOptions);
        if (Array.isArray(versionOrVersions)) {
          paths = (0, common_1.flatten)(paths.map((path2) => versionOrVersions.map((version) => (
            // Version Neutral - Do not include version in URL
            version === common_1.VERSION_NEUTRAL ? path2 : `${path2}/${versionPrefix}${version}`
          ))));
        } else {
          if (versionOrVersions !== common_1.VERSION_NEUTRAL) {
            paths = paths.map((path2) => `${path2}/${versionPrefix}${versionOrVersions}`);
          }
        }
      }
      paths = this.appendToAllIfDefined(paths, metadata2.modulePath);
      paths = this.appendToAllIfDefined(paths, metadata2.ctrlPath);
      paths = this.appendToAllIfDefined(paths, metadata2.methodPath);
      if (metadata2.globalPrefix) {
        paths = paths.map((path2) => {
          if (this.isExcludedFromGlobalPrefix(path2, requestMethod)) {
            return path2;
          }
          return (0, shared_utils_1.stripEndSlash)(metadata2.globalPrefix || "") + path2;
        });
      }
      return paths.map((path2) => (0, shared_utils_1.addLeadingSlash)(path2 || "/")).map((path2) => path2 !== "/" ? (0, shared_utils_1.stripEndSlash)(path2) : path2);
    }
    getVersion(metadata2) {
      return metadata2.methodVersion || metadata2.controllerVersion;
    }
    getVersionPrefix(versioningOptions) {
      const defaultPrefix = "v";
      if (versioningOptions.type === common_1.VersioningType.URI) {
        if (versioningOptions.prefix === false) {
          return "";
        } else if (versioningOptions.prefix !== void 0) {
          return versioningOptions.prefix;
        }
      }
      return defaultPrefix;
    }
    appendToAllIfDefined(paths, fragmentToAppend) {
      if (!fragmentToAppend) {
        return paths;
      }
      const concatPaths = (a, b) => (0, shared_utils_1.stripEndSlash)(a) + (0, shared_utils_1.addLeadingSlash)(b);
      if (Array.isArray(fragmentToAppend)) {
        const paths2dArray = paths.map((path2) => fragmentToAppend.map((fragment) => concatPaths(path2, fragment)));
        return (0, common_1.flatten)(paths2dArray);
      }
      return paths.map((path2) => concatPaths(path2, fragmentToAppend));
    }
    isExcludedFromGlobalPrefix(path2, requestMethod) {
      if ((0, shared_utils_1.isUndefined)(requestMethod)) {
        return false;
      }
      const options = this.applicationConfig.getGlobalPrefixOptions();
      const excludedRoutes = options.exclude;
      return Array.isArray(excludedRoutes) && (0, utils_12.isRouteExcluded)(excludedRoutes, path2, requestMethod);
    }
  }
  routePathFactory.RoutePathFactory = RoutePathFactory;
  return routePathFactory;
}
var hasRequiredRouteInfoPathExtractor;
function requireRouteInfoPathExtractor() {
  if (hasRequiredRouteInfoPathExtractor)
    return routeInfoPathExtractor;
  hasRequiredRouteInfoPathExtractor = 1;
  Object.defineProperty(routeInfoPathExtractor, "__esModule", { value: true });
  routeInfoPathExtractor.RouteInfoPathExtractor = void 0;
  const common_1 = requireCommon$3();
  const shared_utils_1 = requireShared_utils();
  const utils_12 = requireUtils$4();
  const route_path_factory_1 = requireRoutePathFactory();
  class RouteInfoPathExtractor {
    constructor(applicationConfig2) {
      this.applicationConfig = applicationConfig2;
      this.routePathFactory = new route_path_factory_1.RoutePathFactory(applicationConfig2);
      this.prefixPath = (0, shared_utils_1.stripEndSlash)((0, shared_utils_1.addLeadingSlash)(this.applicationConfig.getGlobalPrefix()));
      this.excludedGlobalPrefixRoutes = this.applicationConfig.getGlobalPrefixOptions().exclude;
      this.versioningConfig = this.applicationConfig.getVersioning();
    }
    extractPathsFrom({ path: path2, method, version }) {
      const versionPath = this.extractVersionPathFrom(version);
      if (this.isAWildcard(path2)) {
        return Array.isArray(this.excludedGlobalPrefixRoutes) ? [
          this.prefixPath + versionPath + (0, shared_utils_1.addLeadingSlash)(path2),
          ...this.excludedGlobalPrefixRoutes.map((route2) => versionPath + (0, shared_utils_1.addLeadingSlash)(route2.path))
        ] : [this.prefixPath + versionPath + (0, shared_utils_1.addLeadingSlash)(path2)];
      }
      return [this.extractNonWildcardPathFrom({ path: path2, method, version })];
    }
    extractPathFrom(route2) {
      if (this.isAWildcard(route2.path) && !route2.version) {
        return (0, shared_utils_1.addLeadingSlash)(route2.path);
      }
      return this.extractNonWildcardPathFrom(route2);
    }
    isAWildcard(path2) {
      return ["*", "/*", "/*/", "(.*)", "/(.*)"].includes(path2);
    }
    extractNonWildcardPathFrom({ path: path2, method, version }) {
      const versionPath = this.extractVersionPathFrom(version);
      if (Array.isArray(this.excludedGlobalPrefixRoutes) && (0, utils_12.isRouteExcluded)(this.excludedGlobalPrefixRoutes, path2, method)) {
        return versionPath + (0, shared_utils_1.addLeadingSlash)(path2);
      }
      return this.prefixPath + versionPath + (0, shared_utils_1.addLeadingSlash)(path2);
    }
    extractVersionPathFrom(version) {
      var _a;
      if (!version || ((_a = this.versioningConfig) === null || _a === void 0 ? void 0 : _a.type) !== common_1.VersioningType.URI)
        return "";
      const versionPrefix = this.routePathFactory.getVersionPrefix(this.versioningConfig);
      return (0, shared_utils_1.addLeadingSlash)(versionPrefix + version.toString());
    }
  }
  routeInfoPathExtractor.RouteInfoPathExtractor = RouteInfoPathExtractor;
  return routeInfoPathExtractor;
}
var routesMapper = {};
var pathsExplorer = {};
var hasRequiredPathsExplorer;
function requirePathsExplorer() {
  if (hasRequiredPathsExplorer)
    return pathsExplorer;
  hasRequiredPathsExplorer = 1;
  Object.defineProperty(pathsExplorer, "__esModule", { value: true });
  pathsExplorer.PathsExplorer = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  class PathsExplorer {
    constructor(metadataScanner2) {
      this.metadataScanner = metadataScanner2;
    }
    scanForPaths(instance, prototype2) {
      const instancePrototype = (0, shared_utils_1.isUndefined)(prototype2) ? Object.getPrototypeOf(instance) : prototype2;
      return this.metadataScanner.getAllMethodNames(instancePrototype).reduce((acc, method) => {
        const route2 = this.exploreMethodMetadata(instance, instancePrototype, method);
        if (route2) {
          acc.push(route2);
        }
        return acc;
      }, []);
    }
    exploreMethodMetadata(instance, prototype2, methodName) {
      const instanceCallback = instance[methodName];
      const prototypeCallback = prototype2[methodName];
      const routePath = Reflect.getMetadata(constants_1.PATH_METADATA, prototypeCallback);
      if ((0, shared_utils_1.isUndefined)(routePath)) {
        return null;
      }
      const requestMethod = Reflect.getMetadata(constants_1.METHOD_METADATA, prototypeCallback);
      const version = Reflect.getMetadata(constants_1.VERSION_METADATA, prototypeCallback);
      const path2 = (0, shared_utils_1.isString)(routePath) ? [(0, shared_utils_1.addLeadingSlash)(routePath)] : routePath.map((p) => (0, shared_utils_1.addLeadingSlash)(p));
      return {
        path: path2,
        requestMethod,
        targetCallback: instanceCallback,
        methodName,
        version
      };
    }
  }
  pathsExplorer.PathsExplorer = PathsExplorer;
  return pathsExplorer;
}
var routerModule = {};
var hasRequiredRouterModule;
function requireRouterModule() {
  if (hasRequiredRouterModule)
    return routerModule;
  hasRequiredRouterModule = 1;
  (function(exports2) {
    var RouterModule_1;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RouterModule = exports2.targetModulesByContainer = exports2.ROUTES = void 0;
    const tslib_1 = require$$0$3;
    const common_1 = requireCommon$3();
    const constants_1 = requireConstants$4();
    const shared_utils_1 = requireShared_utils();
    const modules_container_1 = requireModulesContainer();
    const utils_12 = requireUtils$4();
    exports2.ROUTES = Symbol("ROUTES");
    exports2.targetModulesByContainer = /* @__PURE__ */ new WeakMap();
    let RouterModule = RouterModule_1 = class RouterModule {
      constructor(modulesContainer2, routes) {
        this.modulesContainer = modulesContainer2;
        this.routes = routes;
        this.routes = this.deepCloneRoutes(routes);
        this.initialize();
      }
      static register(routes) {
        return {
          module: RouterModule_1,
          providers: [
            {
              provide: exports2.ROUTES,
              useValue: routes
            }
          ]
        };
      }
      deepCloneRoutes(routes) {
        return routes.map((routeOrType) => {
          if (typeof routeOrType === "function") {
            return routeOrType;
          }
          if (routeOrType.children) {
            return Object.assign(Object.assign({}, routeOrType), { children: this.deepCloneRoutes(routeOrType.children) });
          }
          return Object.assign({}, routeOrType);
        });
      }
      initialize() {
        const flattenedRoutes = (0, utils_12.flattenRoutePaths)(this.routes);
        flattenedRoutes.forEach((route2) => {
          const modulePath = (0, shared_utils_1.normalizePath)(route2.path);
          this.registerModulePathMetadata(route2.module, modulePath);
          this.updateTargetModulesCache(route2.module);
        });
      }
      registerModulePathMetadata(moduleCtor, modulePath) {
        Reflect.defineMetadata(constants_1.MODULE_PATH + this.modulesContainer.applicationId, modulePath, moduleCtor);
      }
      updateTargetModulesCache(moduleCtor) {
        let moduleClassSet;
        if (exports2.targetModulesByContainer.has(this.modulesContainer)) {
          moduleClassSet = exports2.targetModulesByContainer.get(this.modulesContainer);
        } else {
          moduleClassSet = /* @__PURE__ */ new WeakSet();
          exports2.targetModulesByContainer.set(this.modulesContainer, moduleClassSet);
        }
        const moduleRef2 = Array.from(this.modulesContainer.values()).find((item) => (item === null || item === void 0 ? void 0 : item.metatype) === moduleCtor);
        if (!moduleRef2) {
          return;
        }
        moduleClassSet.add(moduleRef2);
      }
    };
    RouterModule = RouterModule_1 = tslib_1.__decorate([
      (0, common_1.Module)({}),
      tslib_1.__param(1, (0, common_1.Inject)(exports2.ROUTES)),
      tslib_1.__metadata("design:paramtypes", [modules_container_1.ModulesContainer, Array])
    ], RouterModule);
    exports2.RouterModule = RouterModule;
  })(routerModule);
  return routerModule;
}
var hasRequiredRoutesMapper;
function requireRoutesMapper() {
  if (hasRequiredRoutesMapper)
    return routesMapper;
  hasRequiredRoutesMapper = 1;
  Object.defineProperty(routesMapper, "__esModule", { value: true });
  routesMapper.RoutesMapper = void 0;
  const constants_1 = requireConstants$4();
  const shared_utils_1 = requireShared_utils();
  const metadata_scanner_1 = requireMetadataScanner();
  const paths_explorer_1 = requirePathsExplorer();
  const router_module_1 = requireRouterModule();
  class RoutesMapper {
    constructor(container2) {
      this.container = container2;
      this.pathsExplorer = new paths_explorer_1.PathsExplorer(new metadata_scanner_1.MetadataScanner());
    }
    mapRouteToRouteInfo(route2) {
      if ((0, shared_utils_1.isString)(route2)) {
        return this.getRouteInfoFromPath(route2);
      }
      const routePathOrPaths = this.getRoutePath(route2);
      if (this.isRouteInfo(routePathOrPaths, route2)) {
        return this.getRouteInfoFromObject(route2);
      }
      return this.getRouteInfoFromController(route2, routePathOrPaths);
    }
    getRouteInfoFromPath(routePath) {
      const defaultRequestMethod = -1;
      return [
        {
          path: (0, shared_utils_1.addLeadingSlash)(routePath),
          method: defaultRequestMethod
        }
      ];
    }
    getRouteInfoFromObject(routeInfoObject) {
      const routeInfo = {
        path: (0, shared_utils_1.addLeadingSlash)(routeInfoObject.path),
        method: routeInfoObject.method
      };
      if (routeInfoObject.version) {
        routeInfo.version = routeInfoObject.version;
      }
      return [routeInfo];
    }
    getRouteInfoFromController(controller, routePath) {
      const controllerPaths = this.pathsExplorer.scanForPaths(Object.create(controller), controller.prototype);
      const moduleRef2 = this.getHostModuleOfController(controller);
      const modulePath = this.getModulePath(moduleRef2 === null || moduleRef2 === void 0 ? void 0 : moduleRef2.metatype);
      const concatPaths = (acc, currentValue) => acc.concat(currentValue);
      return [].concat(routePath).map((routePath2) => controllerPaths.map((item) => {
        var _a;
        return (_a = item.path) === null || _a === void 0 ? void 0 : _a.map((p) => {
          let path2 = modulePath !== null && modulePath !== void 0 ? modulePath : "";
          path2 += this.normalizeGlobalPath(routePath2) + (0, shared_utils_1.addLeadingSlash)(p);
          const routeInfo = {
            path: path2,
            method: item.requestMethod
          };
          if (item.version) {
            routeInfo.version = item.version;
          }
          return routeInfo;
        });
      }).reduce(concatPaths, [])).reduce(concatPaths, []);
    }
    isRouteInfo(path2, objectOrClass) {
      return (0, shared_utils_1.isUndefined)(path2);
    }
    normalizeGlobalPath(path2) {
      const prefix = (0, shared_utils_1.addLeadingSlash)(path2);
      return prefix === "/" ? "" : prefix;
    }
    getRoutePath(route2) {
      return Reflect.getMetadata(constants_1.PATH_METADATA, route2);
    }
    getHostModuleOfController(metatype) {
      if (!metatype) {
        return;
      }
      const modulesContainer2 = this.container.getModules();
      const moduleRefsSet = router_module_1.targetModulesByContainer.get(modulesContainer2);
      if (!moduleRefsSet) {
        return;
      }
      const modules2 = Array.from(modulesContainer2.values()).filter((moduleRef2) => moduleRefsSet.has(moduleRef2));
      return modules2.find(({ routes }) => routes.has(metatype));
    }
    getModulePath(metatype) {
      if (!metatype) {
        return;
      }
      const modulesContainer2 = this.container.getModules();
      const modulePath = Reflect.getMetadata(constants_1.MODULE_PATH + modulesContainer2.applicationId, metatype);
      return modulePath !== null && modulePath !== void 0 ? modulePath : Reflect.getMetadata(constants_1.MODULE_PATH, metatype);
    }
  }
  routesMapper.RoutesMapper = RoutesMapper;
  return routesMapper;
}
var hasRequiredMiddlewareModule;
function requireMiddlewareModule() {
  if (hasRequiredMiddlewareModule)
    return middlewareModule;
  hasRequiredMiddlewareModule = 1;
  Object.defineProperty(middlewareModule, "__esModule", { value: true });
  middlewareModule.MiddlewareModule = void 0;
  const common_1 = requireCommon$3();
  const request_method_enum_1 = requireRequestMethod_enum();
  const shared_utils_1 = requireShared_utils();
  const invalid_middleware_exception_1 = requireInvalidMiddleware_exception();
  const runtime_exception_1 = requireRuntime_exception();
  const context_id_factory_1 = requireContextIdFactory();
  const execution_context_host_1 = requireExecutionContextHost();
  const constants_1 = requireConstants$2();
  const request_constants_1 = requireRequestConstants();
  const router_exception_filters_1 = requireRouterExceptionFilters();
  const router_proxy_1 = requireRouterProxy();
  const utils_12 = requireUtils$4();
  const builder_1 = requireBuilder();
  const resolver_1 = requireResolver();
  const route_info_path_extractor_1 = requireRouteInfoPathExtractor();
  const routes_mapper_1 = requireRoutesMapper();
  class MiddlewareModule {
    constructor() {
      this.routerProxy = new router_proxy_1.RouterProxy();
      this.exceptionFiltersCache = /* @__PURE__ */ new WeakMap();
      this.logger = new common_1.Logger(MiddlewareModule.name);
    }
    async register(middlewareContainer, container2, config2, injector2, httpAdapter3, graphInspector2, options) {
      this.appOptions = options;
      const appRef = container2.getHttpAdapterRef();
      this.routerExceptionFilter = new router_exception_filters_1.RouterExceptionFilters(container2, config2, appRef);
      this.routesMapper = new routes_mapper_1.RoutesMapper(container2);
      this.resolver = new resolver_1.MiddlewareResolver(middlewareContainer, injector2);
      this.routeInfoPathExtractor = new route_info_path_extractor_1.RouteInfoPathExtractor(config2);
      this.injector = injector2;
      this.container = container2;
      this.httpAdapter = httpAdapter3;
      this.graphInspector = graphInspector2;
      const modules2 = container2.getModules();
      await this.resolveMiddleware(middlewareContainer, modules2);
    }
    async resolveMiddleware(middlewareContainer, modules2) {
      const moduleEntries = [...modules2.entries()];
      const loadMiddlewareConfiguration = async ([moduleName, moduleRef2]) => {
        await this.loadConfiguration(middlewareContainer, moduleRef2, moduleName);
        await this.resolver.resolveInstances(moduleRef2, moduleName);
      };
      await Promise.all(moduleEntries.map(loadMiddlewareConfiguration));
    }
    async loadConfiguration(middlewareContainer, moduleRef2, moduleKey) {
      const { instance } = moduleRef2;
      if (!instance.configure) {
        return;
      }
      const middlewareBuilder = new builder_1.MiddlewareBuilder(this.routesMapper, this.httpAdapter, this.routeInfoPathExtractor);
      try {
        await instance.configure(middlewareBuilder);
      } catch (err) {
        if (!this.appOptions.preview) {
          throw err;
        }
        const warningMessage = `Warning! "${moduleRef2.name}" module exposes a "configure" method that throws an exception in the preview mode (possibly due to missing dependencies). Note: you can ignore this message, just be aware that some of those conditional middlewares will not be reflected in your graph.`;
        this.logger.warn(warningMessage);
      }
      if (!(middlewareBuilder instanceof builder_1.MiddlewareBuilder)) {
        return;
      }
      const config2 = middlewareBuilder.build();
      middlewareContainer.insertConfig(config2, moduleKey);
    }
    async registerMiddleware(middlewareContainer, applicationRef) {
      const configs = middlewareContainer.getConfigurations();
      const registerAllConfigs = async (moduleKey, middlewareConfig) => {
        for (const config2 of middlewareConfig) {
          await this.registerMiddlewareConfig(middlewareContainer, config2, moduleKey, applicationRef);
        }
      };
      const entriesSortedByDistance = [...configs.entries()].sort(([moduleA], [moduleB]) => {
        return this.container.getModuleByKey(moduleA).distance - this.container.getModuleByKey(moduleB).distance;
      });
      for (const [moduleRef2, moduleConfigurations] of entriesSortedByDistance) {
        await registerAllConfigs(moduleRef2, [...moduleConfigurations]);
      }
    }
    async registerMiddlewareConfig(middlewareContainer, config2, moduleKey, applicationRef) {
      const { forRoutes } = config2;
      for (const routeInfo of forRoutes) {
        await this.registerRouteMiddleware(middlewareContainer, routeInfo, config2, moduleKey, applicationRef);
      }
    }
    async registerRouteMiddleware(middlewareContainer, routeInfo, config2, moduleKey, applicationRef) {
      var _a;
      const middlewareCollection = [].concat(config2.middleware);
      const moduleRef2 = this.container.getModuleByKey(moduleKey);
      for (const metatype of middlewareCollection) {
        const collection = middlewareContainer.getMiddlewareCollection(moduleKey);
        const instanceWrapper2 = collection.get(metatype);
        if ((0, shared_utils_1.isUndefined)(instanceWrapper2)) {
          throw new runtime_exception_1.RuntimeException();
        }
        if (instanceWrapper2.isTransient) {
          return;
        }
        this.graphInspector.insertClassNode(moduleRef2, instanceWrapper2, "middleware");
        const middlewareDefinition = {
          type: "middleware",
          methodName: "use",
          className: instanceWrapper2.name,
          classNodeId: instanceWrapper2.id,
          metadata: {
            key: routeInfo.path,
            path: routeInfo.path,
            requestMethod: (_a = request_method_enum_1.RequestMethod[routeInfo.method]) !== null && _a !== void 0 ? _a : "ALL",
            version: routeInfo.version
          }
        };
        this.graphInspector.insertEntrypointDefinition(middlewareDefinition, instanceWrapper2.id);
        await this.bindHandler(instanceWrapper2, applicationRef, routeInfo, moduleRef2, collection);
      }
    }
    async bindHandler(wrapper, applicationRef, routeInfo, moduleRef2, collection) {
      const { instance, metatype } = wrapper;
      if ((0, shared_utils_1.isUndefined)(instance === null || instance === void 0 ? void 0 : instance.use)) {
        throw new invalid_middleware_exception_1.InvalidMiddlewareException(metatype.name);
      }
      const isStatic = wrapper.isDependencyTreeStatic();
      if (isStatic) {
        const proxy = await this.createProxy(instance);
        return this.registerHandler(applicationRef, routeInfo, proxy);
      }
      const isTreeDurable = wrapper.isDependencyTreeDurable();
      await this.registerHandler(applicationRef, routeInfo, async (req, res, next) => {
        try {
          const contextId = this.getContextId(req, isTreeDurable);
          const contextInstance = await this.injector.loadPerContext(instance, moduleRef2, collection, contextId);
          const proxy = await this.createProxy(contextInstance, contextId);
          return proxy(req, res, next);
        } catch (err) {
          let exceptionsHandler2 = this.exceptionFiltersCache.get(instance.use);
          if (!exceptionsHandler2) {
            exceptionsHandler2 = this.routerExceptionFilter.create(instance, instance.use, void 0);
            this.exceptionFiltersCache.set(instance.use, exceptionsHandler2);
          }
          const host = new execution_context_host_1.ExecutionContextHost([req, res, next]);
          exceptionsHandler2.next(err, host);
        }
      });
    }
    async createProxy(instance, contextId = constants_1.STATIC_CONTEXT) {
      const exceptionsHandler2 = this.routerExceptionFilter.create(instance, instance.use, void 0, contextId);
      const middleware2 = instance.use.bind(instance);
      return this.routerProxy.createProxy(middleware2, exceptionsHandler2);
    }
    async registerHandler(applicationRef, routeInfo, proxy) {
      const { method } = routeInfo;
      const paths = this.routeInfoPathExtractor.extractPathsFrom(routeInfo);
      const isMethodAll = (0, utils_12.isRequestMethodAll)(method);
      const requestMethod = request_method_enum_1.RequestMethod[method];
      const router2 = await applicationRef.createMiddlewareFactory(method);
      const middlewareFunction = isMethodAll ? proxy : (req, res, next) => {
        if (applicationRef.getRequestMethod(req) === requestMethod) {
          return proxy(req, res, next);
        }
        return next();
      };
      paths.forEach((path2) => router2(path2, middlewareFunction));
    }
    getContextId(request2, isTreeDurable) {
      const contextId = context_id_factory_1.ContextIdFactory.getByRequest(request2);
      if (!request2[request_constants_1.REQUEST_CONTEXT_ID]) {
        Object.defineProperty(request2, request_constants_1.REQUEST_CONTEXT_ID, {
          value: contextId,
          enumerable: false,
          writable: false,
          configurable: false
        });
        const requestProviderValue = isTreeDurable ? contextId.payload : request2;
        this.container.registerRequestProvider(requestProviderValue, contextId);
      }
      return contextId;
    }
  }
  middlewareModule.MiddlewareModule = MiddlewareModule;
  return middlewareModule;
}
var nestApplicationContext = {};
var hooks = {};
var onAppBootstrap_hook = {};
var transientInstances = {};
var hasRequiredTransientInstances;
function requireTransientInstances() {
  if (hasRequiredTransientInstances)
    return transientInstances;
  hasRequiredTransientInstances = 1;
  Object.defineProperty(transientInstances, "__esModule", { value: true });
  transientInstances.getNonTransientInstances = transientInstances.getTransientInstances = void 0;
  const iterare_1 = requireLib$4();
  function getTransientInstances(instances) {
    return (0, iterare_1.iterate)(instances).filter(([_, wrapper]) => wrapper.isDependencyTreeStatic()).map(([_, wrapper]) => wrapper.getStaticTransientInstances()).flatten().filter((item) => !!item).map(({ instance }) => instance).toArray();
  }
  transientInstances.getTransientInstances = getTransientInstances;
  function getNonTransientInstances(instances) {
    return (0, iterare_1.iterate)(instances).filter(([key, wrapper]) => wrapper.isDependencyTreeStatic() && !wrapper.isTransient).map(([key, { instance }]) => instance).toArray();
  }
  transientInstances.getNonTransientInstances = getNonTransientInstances;
  return transientInstances;
}
var hasRequiredOnAppBootstrap_hook;
function requireOnAppBootstrap_hook() {
  if (hasRequiredOnAppBootstrap_hook)
    return onAppBootstrap_hook;
  hasRequiredOnAppBootstrap_hook = 1;
  Object.defineProperty(onAppBootstrap_hook, "__esModule", { value: true });
  onAppBootstrap_hook.callModuleBootstrapHook = void 0;
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const transient_instances_1 = requireTransientInstances();
  function hasOnAppBootstrapHook(instance) {
    return (0, shared_utils_1.isFunction)(instance.onApplicationBootstrap);
  }
  function callOperator(instances) {
    return (0, iterare_1.iterate)(instances).filter((instance) => !(0, shared_utils_1.isNil)(instance)).filter(hasOnAppBootstrapHook).map(async (instance) => instance.onApplicationBootstrap()).toArray();
  }
  async function callModuleBootstrapHook(module2) {
    const providers = module2.getNonAliasProviders();
    const [_, moduleClassHost] = providers.shift();
    const instances = [
      ...module2.controllers,
      ...providers,
      ...module2.injectables,
      ...module2.middlewares
    ];
    const nonTransientInstances = (0, transient_instances_1.getNonTransientInstances)(instances);
    await Promise.all(callOperator(nonTransientInstances));
    const transientInstances2 = (0, transient_instances_1.getTransientInstances)(instances);
    await Promise.all(callOperator(transientInstances2));
    const moduleClassInstance = moduleClassHost.instance;
    if (moduleClassInstance && hasOnAppBootstrapHook(moduleClassInstance) && moduleClassHost.isDependencyTreeStatic()) {
      await moduleClassInstance.onApplicationBootstrap();
    }
  }
  onAppBootstrap_hook.callModuleBootstrapHook = callModuleBootstrapHook;
  return onAppBootstrap_hook;
}
var onAppShutdown_hook = {};
var hasRequiredOnAppShutdown_hook;
function requireOnAppShutdown_hook() {
  if (hasRequiredOnAppShutdown_hook)
    return onAppShutdown_hook;
  hasRequiredOnAppShutdown_hook = 1;
  Object.defineProperty(onAppShutdown_hook, "__esModule", { value: true });
  onAppShutdown_hook.callAppShutdownHook = void 0;
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const transient_instances_1 = requireTransientInstances();
  function hasOnAppShutdownHook(instance) {
    return (0, shared_utils_1.isFunction)(instance.onApplicationShutdown);
  }
  function callOperator(instances, signal) {
    return (0, iterare_1.iterate)(instances).filter((instance) => !(0, shared_utils_1.isNil)(instance)).filter(hasOnAppShutdownHook).map(async (instance) => instance.onApplicationShutdown(signal)).toArray();
  }
  async function callAppShutdownHook(module2, signal) {
    const providers = module2.getNonAliasProviders();
    const [_, moduleClassHost] = providers.shift();
    const instances = [
      ...module2.controllers,
      ...providers,
      ...module2.injectables,
      ...module2.middlewares
    ];
    const nonTransientInstances = (0, transient_instances_1.getNonTransientInstances)(instances);
    await Promise.all(callOperator(nonTransientInstances, signal));
    const transientInstances2 = (0, transient_instances_1.getTransientInstances)(instances);
    await Promise.all(callOperator(transientInstances2, signal));
    const moduleClassInstance = moduleClassHost.instance;
    if (moduleClassInstance && hasOnAppShutdownHook(moduleClassInstance) && moduleClassHost.isDependencyTreeStatic()) {
      await moduleClassInstance.onApplicationShutdown(signal);
    }
  }
  onAppShutdown_hook.callAppShutdownHook = callAppShutdownHook;
  return onAppShutdown_hook;
}
var onModuleDestroy_hook = {};
var hasRequiredOnModuleDestroy_hook;
function requireOnModuleDestroy_hook() {
  if (hasRequiredOnModuleDestroy_hook)
    return onModuleDestroy_hook;
  hasRequiredOnModuleDestroy_hook = 1;
  Object.defineProperty(onModuleDestroy_hook, "__esModule", { value: true });
  onModuleDestroy_hook.callModuleDestroyHook = void 0;
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const transient_instances_1 = requireTransientInstances();
  function hasOnModuleDestroyHook(instance) {
    return (0, shared_utils_1.isFunction)(instance.onModuleDestroy);
  }
  function callOperator(instances) {
    return (0, iterare_1.iterate)(instances).filter((instance) => !(0, shared_utils_1.isNil)(instance)).filter(hasOnModuleDestroyHook).map(async (instance) => instance.onModuleDestroy()).toArray();
  }
  async function callModuleDestroyHook(module2) {
    const providers = module2.getNonAliasProviders();
    const [_, moduleClassHost] = providers.shift();
    const instances = [
      ...module2.controllers,
      ...providers,
      ...module2.injectables,
      ...module2.middlewares
    ];
    const nonTransientInstances = (0, transient_instances_1.getNonTransientInstances)(instances);
    await Promise.all(callOperator(nonTransientInstances));
    const transientInstances2 = (0, transient_instances_1.getTransientInstances)(instances);
    await Promise.all(callOperator(transientInstances2));
    const moduleClassInstance = moduleClassHost.instance;
    if (moduleClassInstance && hasOnModuleDestroyHook(moduleClassInstance) && moduleClassHost.isDependencyTreeStatic()) {
      await moduleClassInstance.onModuleDestroy();
    }
  }
  onModuleDestroy_hook.callModuleDestroyHook = callModuleDestroyHook;
  return onModuleDestroy_hook;
}
var onModuleInit_hook = {};
var hasRequiredOnModuleInit_hook;
function requireOnModuleInit_hook() {
  if (hasRequiredOnModuleInit_hook)
    return onModuleInit_hook;
  hasRequiredOnModuleInit_hook = 1;
  Object.defineProperty(onModuleInit_hook, "__esModule", { value: true });
  onModuleInit_hook.callModuleInitHook = void 0;
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const transient_instances_1 = requireTransientInstances();
  function hasOnModuleInitHook(instance) {
    return (0, shared_utils_1.isFunction)(instance.onModuleInit);
  }
  function callOperator(instances) {
    return (0, iterare_1.iterate)(instances).filter((instance) => !(0, shared_utils_1.isNil)(instance)).filter(hasOnModuleInitHook).map(async (instance) => instance.onModuleInit()).toArray();
  }
  async function callModuleInitHook(module2) {
    const providers = module2.getNonAliasProviders();
    const [_, moduleClassHost] = providers.shift();
    const instances = [
      ...module2.controllers,
      ...providers,
      ...module2.injectables,
      ...module2.middlewares
    ];
    const nonTransientInstances = (0, transient_instances_1.getNonTransientInstances)(instances);
    await Promise.all(callOperator(nonTransientInstances));
    const transientInstances2 = (0, transient_instances_1.getTransientInstances)(instances);
    await Promise.all(callOperator(transientInstances2));
    const moduleClassInstance = moduleClassHost.instance;
    if (moduleClassInstance && hasOnModuleInitHook(moduleClassInstance) && moduleClassHost.isDependencyTreeStatic()) {
      await moduleClassInstance.onModuleInit();
    }
  }
  onModuleInit_hook.callModuleInitHook = callModuleInitHook;
  return onModuleInit_hook;
}
var beforeAppShutdown_hook = {};
var hasRequiredBeforeAppShutdown_hook;
function requireBeforeAppShutdown_hook() {
  if (hasRequiredBeforeAppShutdown_hook)
    return beforeAppShutdown_hook;
  hasRequiredBeforeAppShutdown_hook = 1;
  Object.defineProperty(beforeAppShutdown_hook, "__esModule", { value: true });
  beforeAppShutdown_hook.callBeforeAppShutdownHook = void 0;
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const transient_instances_1 = requireTransientInstances();
  function hasBeforeApplicationShutdownHook(instance) {
    return (0, shared_utils_1.isFunction)(instance.beforeApplicationShutdown);
  }
  function callOperator(instances, signal) {
    return (0, iterare_1.iterate)(instances).filter((instance) => !(0, shared_utils_1.isNil)(instance)).filter(hasBeforeApplicationShutdownHook).map(async (instance) => instance.beforeApplicationShutdown(signal)).toArray();
  }
  async function callBeforeAppShutdownHook(module2, signal) {
    const providers = module2.getNonAliasProviders();
    const [_, moduleClassHost] = providers.shift();
    const instances = [
      ...module2.controllers,
      ...providers,
      ...module2.injectables,
      ...module2.middlewares
    ];
    const nonTransientInstances = (0, transient_instances_1.getNonTransientInstances)(instances);
    await Promise.all(callOperator(nonTransientInstances, signal));
    const transientInstances2 = (0, transient_instances_1.getTransientInstances)(instances);
    await Promise.all(callOperator(transientInstances2, signal));
    const moduleClassInstance = moduleClassHost.instance;
    if (moduleClassInstance && hasBeforeApplicationShutdownHook(moduleClassInstance) && moduleClassHost.isDependencyTreeStatic()) {
      await moduleClassInstance.beforeApplicationShutdown(signal);
    }
  }
  beforeAppShutdown_hook.callBeforeAppShutdownHook = callBeforeAppShutdownHook;
  return beforeAppShutdown_hook;
}
var hasRequiredHooks;
function requireHooks() {
  if (hasRequiredHooks)
    return hooks;
  hasRequiredHooks = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireOnAppBootstrap_hook(), exports2);
    tslib_1.__exportStar(requireOnAppShutdown_hook(), exports2);
    tslib_1.__exportStar(requireOnModuleDestroy_hook(), exports2);
    tslib_1.__exportStar(requireOnModuleInit_hook(), exports2);
    tslib_1.__exportStar(requireBeforeAppShutdown_hook(), exports2);
  })(hooks);
  return hooks;
}
var hasRequiredNestApplicationContext;
function requireNestApplicationContext() {
  if (hasRequiredNestApplicationContext)
    return nestApplicationContext;
  hasRequiredNestApplicationContext = 1;
  Object.defineProperty(nestApplicationContext, "__esModule", { value: true });
  nestApplicationContext.NestApplicationContext = void 0;
  const common_1 = requireCommon$3();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const constants_1 = requireConstants$5();
  const exceptions_1 = requireExceptions();
  const context_id_factory_1 = requireContextIdFactory();
  const hooks_1 = requireHooks();
  const abstract_instance_resolver_1 = requireAbstractInstanceResolver();
  const compiler_1 = requireCompiler();
  const injector_1 = requireInjector$1();
  const instance_links_host_1 = requireInstanceLinksHost();
  class NestApplicationContext extends abstract_instance_resolver_1.AbstractInstanceResolver {
    get instanceLinksHost() {
      if (!this._instanceLinksHost) {
        this._instanceLinksHost = new instance_links_host_1.InstanceLinksHost(this.container);
      }
      return this._instanceLinksHost;
    }
    constructor(container2, appOptions = {}, contextModule = null, scope2 = new Array()) {
      super();
      this.container = container2;
      this.appOptions = appOptions;
      this.contextModule = contextModule;
      this.scope = scope2;
      this.isInitialized = false;
      this.logger = new common_1.Logger(NestApplicationContext.name, {
        timestamp: true
      });
      this.shouldFlushLogsOnOverride = false;
      this.activeShutdownSignals = new Array();
      this.moduleCompiler = new compiler_1.ModuleCompiler();
      this.injector = new injector_1.Injector();
      if (this.appOptions.preview) {
        this.printInPreviewModeWarning();
      }
    }
    selectContextModule() {
      const modules2 = this.container.getModules().values();
      this.contextModule = modules2.next().value;
    }
    /**
     * Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module.
     * @returns {INestApplicationContext}
     */
    select(moduleType) {
      const modulesContainer2 = this.container.getModules();
      const contextModuleCtor = this.contextModule.metatype;
      const scope2 = this.scope.concat(contextModuleCtor);
      const moduleTokenFactory2 = this.container.getModuleTokenFactory();
      const { type: type2, dynamicMetadata } = this.moduleCompiler.extractMetadata(moduleType);
      const token = moduleTokenFactory2.create(type2, dynamicMetadata);
      const selectedModule = modulesContainer2.get(token);
      if (!selectedModule) {
        throw new exceptions_1.UnknownModuleException();
      }
      return new NestApplicationContext(this.container, this.appOptions, selectedModule, scope2);
    }
    /**
     * Retrieves an instance (or a list of instances) of either injectable or controller, otherwise, throws exception.
     * @returns {TResult | Array<TResult>}
     */
    get(typeOrToken, options = { strict: false }) {
      var _a;
      return !(options && options.strict) ? this.find(typeOrToken, options) : this.find(typeOrToken, {
        moduleId: (_a = this.contextModule) === null || _a === void 0 ? void 0 : _a.id,
        each: options.each
      });
    }
    /**
     * Resolves transient or request-scoped instance (or a list of instances) of either injectable or controller, otherwise, throws exception.
     * @returns {Promise<TResult | Array<TResult>>}
     */
    resolve(typeOrToken, contextId = (0, context_id_factory_1.createContextId)(), options = { strict: false }) {
      return this.resolvePerContext(typeOrToken, this.contextModule, contextId, options);
    }
    /**
     * Registers the request/context object for a given context ID (DI container sub-tree).
     * @returns {void}
     */
    registerRequestByContextId(request2, contextId) {
      this.container.registerRequestProvider(request2, contextId);
    }
    /**
     * Initializes the Nest application.
     * Calls the Nest lifecycle events.
     *
     * @returns {Promise<this>} The NestApplicationContext instance as Promise
     */
    async init() {
      if (this.isInitialized) {
        return this;
      }
      await this.callInitHook();
      await this.callBootstrapHook();
      this.isInitialized = true;
      return this;
    }
    /**
     * Terminates the application
     * @returns {Promise<void>}
     */
    async close(signal) {
      await this.callDestroyHook();
      await this.callBeforeShutdownHook(signal);
      await this.dispose();
      await this.callShutdownHook(signal);
      this.unsubscribeFromProcessSignals();
    }
    /**
     * Sets custom logger service.
     * Flushes buffered logs if auto flush is on.
     * @returns {void}
     */
    useLogger(logger) {
      common_1.Logger.overrideLogger(logger);
      if (this.shouldFlushLogsOnOverride) {
        this.flushLogs();
      }
    }
    /**
     * Prints buffered logs and detaches buffer.
     * @returns {void}
     */
    flushLogs() {
      common_1.Logger.flush();
    }
    /**
     * Define that it must flush logs right after defining a custom logger.
     */
    flushLogsOnOverride() {
      this.shouldFlushLogsOnOverride = true;
    }
    /**
     * Enables the usage of shutdown hooks. Will call the
     * `onApplicationShutdown` function of a provider if the
     * process receives a shutdown signal.
     *
     * @param {ShutdownSignal[]} [signals=[]] The system signals it should listen to
     *
     * @returns {this} The Nest application context instance
     */
    enableShutdownHooks(signals = []) {
      if ((0, shared_utils_1.isEmpty)(signals)) {
        signals = Object.keys(common_1.ShutdownSignal).map((key) => common_1.ShutdownSignal[key]);
      } else {
        signals = Array.from(new Set(signals));
      }
      signals = (0, iterare_1.iterate)(signals).map((signal) => signal.toString().toUpperCase().trim()).filter((signal) => !this.activeShutdownSignals.includes(signal)).toArray();
      this.listenToShutdownSignals(signals);
      return this;
    }
    async dispose() {
      return Promise.resolve();
    }
    /**
     * Listens to shutdown signals by listening to
     * process events
     *
     * @param {string[]} signals The system signals it should listen to
     */
    listenToShutdownSignals(signals) {
      let receivedSignal = false;
      const cleanup = async (signal) => {
        try {
          if (receivedSignal) {
            return;
          }
          receivedSignal = true;
          await this.callDestroyHook();
          await this.callBeforeShutdownHook(signal);
          await this.dispose();
          await this.callShutdownHook(signal);
          signals.forEach((sig) => process.removeListener(sig, cleanup));
          process.kill(process.pid, signal);
        } catch (err) {
          common_1.Logger.error(constants_1.MESSAGES.ERROR_DURING_SHUTDOWN, err === null || err === void 0 ? void 0 : err.stack, NestApplicationContext.name);
          process.exit(1);
        }
      };
      this.shutdownCleanupRef = cleanup;
      signals.forEach((signal) => {
        this.activeShutdownSignals.push(signal);
        process.on(signal, cleanup);
      });
    }
    /**
     * Unsubscribes from shutdown signals (process events)
     */
    unsubscribeFromProcessSignals() {
      if (!this.shutdownCleanupRef) {
        return;
      }
      this.activeShutdownSignals.forEach((signal) => {
        process.removeListener(signal, this.shutdownCleanupRef);
      });
    }
    /**
     * Calls the `onModuleInit` function on the registered
     * modules and its children.
     */
    async callInitHook() {
      const modulesSortedByDistance = this.getModulesToTriggerHooksOn();
      for (const module2 of modulesSortedByDistance) {
        await (0, hooks_1.callModuleInitHook)(module2);
      }
    }
    /**
     * Calls the `onModuleDestroy` function on the registered
     * modules and its children.
     */
    async callDestroyHook() {
      const modulesSortedByDistance = this.getModulesToTriggerHooksOn();
      for (const module2 of modulesSortedByDistance) {
        await (0, hooks_1.callModuleDestroyHook)(module2);
      }
    }
    /**
     * Calls the `onApplicationBootstrap` function on the registered
     * modules and its children.
     */
    async callBootstrapHook() {
      const modulesSortedByDistance = this.getModulesToTriggerHooksOn();
      for (const module2 of modulesSortedByDistance) {
        await (0, hooks_1.callModuleBootstrapHook)(module2);
      }
    }
    /**
     * Calls the `onApplicationShutdown` function on the registered
     * modules and children.
     */
    async callShutdownHook(signal) {
      const modulesSortedByDistance = this.getModulesToTriggerHooksOn();
      for (const module2 of modulesSortedByDistance) {
        await (0, hooks_1.callAppShutdownHook)(module2, signal);
      }
    }
    /**
     * Calls the `beforeApplicationShutdown` function on the registered
     * modules and children.
     */
    async callBeforeShutdownHook(signal) {
      const modulesSortedByDistance = this.getModulesToTriggerHooksOn();
      for (const module2 of modulesSortedByDistance) {
        await (0, hooks_1.callBeforeAppShutdownHook)(module2, signal);
      }
    }
    assertNotInPreviewMode(methodName) {
      if (this.appOptions.preview) {
        const error2 = `Calling the "${methodName}" in the preview mode is not supported.`;
        this.logger.error(error2);
        throw new Error(error2);
      }
    }
    getModulesToTriggerHooksOn() {
      var _a;
      if (this._moduleRefsForHooksByDistance) {
        return this._moduleRefsForHooksByDistance;
      }
      const modulesContainer2 = this.container.getModules();
      const compareFn = (a, b) => b.distance - a.distance;
      const modulesSortedByDistance = Array.from(modulesContainer2.values()).sort(compareFn);
      this._moduleRefsForHooksByDistance = ((_a = this.appOptions) === null || _a === void 0 ? void 0 : _a.preview) ? modulesSortedByDistance.filter((moduleRef2) => moduleRef2.initOnPreview) : modulesSortedByDistance;
      return this._moduleRefsForHooksByDistance;
    }
    printInPreviewModeWarning() {
      this.logger.warn("------------------------------------------------");
      this.logger.warn("Application is running in the PREVIEW mode!");
      this.logger.warn("Providers/controllers will not be instantiated.");
      this.logger.warn("------------------------------------------------");
    }
  }
  nestApplicationContext.NestApplicationContext = NestApplicationContext;
  return nestApplicationContext;
}
var routesResolver = {};
var messages = {};
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages)
    return messages;
  hasRequiredMessages = 1;
  Object.defineProperty(messages, "__esModule", { value: true });
  messages.INVALID_EXECUTION_CONTEXT = messages.VERSIONED_CONTROLLER_MAPPING_MESSAGE = messages.CONTROLLER_MAPPING_MESSAGE = messages.VERSIONED_ROUTE_MAPPED_MESSAGE = messages.ROUTE_MAPPED_MESSAGE = messages.MODULE_INIT_MESSAGE = void 0;
  const request_method_enum_1 = requireRequestMethod_enum();
  const version_options_interface_1 = requireVersionOptions_interface();
  const MODULE_INIT_MESSAGE = (text, module2) => `${module2} dependencies initialized`;
  messages.MODULE_INIT_MESSAGE = MODULE_INIT_MESSAGE;
  const ROUTE_MAPPED_MESSAGE = (path2, method) => `Mapped {${path2}, ${request_method_enum_1.RequestMethod[method]}} route`;
  messages.ROUTE_MAPPED_MESSAGE = ROUTE_MAPPED_MESSAGE;
  const VERSIONED_ROUTE_MAPPED_MESSAGE = (path2, method, version) => {
    const controllerVersions = Array.isArray(version) ? version : [version];
    const versions = controllerVersions.map((version2) => version2 === version_options_interface_1.VERSION_NEUTRAL ? "Neutral" : version2).join(",");
    return `Mapped {${path2}, ${request_method_enum_1.RequestMethod[method]}} (version: ${versions}) route`;
  };
  messages.VERSIONED_ROUTE_MAPPED_MESSAGE = VERSIONED_ROUTE_MAPPED_MESSAGE;
  const CONTROLLER_MAPPING_MESSAGE = (name, path2) => `${name} {${path2}}:`;
  messages.CONTROLLER_MAPPING_MESSAGE = CONTROLLER_MAPPING_MESSAGE;
  const VERSIONED_CONTROLLER_MAPPING_MESSAGE = (name, path2, version) => {
    const controllerVersions = Array.isArray(version) ? version : [version];
    const versions = controllerVersions.map((version2) => version2 === version_options_interface_1.VERSION_NEUTRAL ? "Neutral" : version2).join(",");
    return `${name} {${path2}} (version: ${versions}):`;
  };
  messages.VERSIONED_CONTROLLER_MAPPING_MESSAGE = VERSIONED_CONTROLLER_MAPPING_MESSAGE;
  const INVALID_EXECUTION_CONTEXT = (methodName, currentContext) => `Calling ${methodName} is not allowed in this context. Your current execution context is "${currentContext}".`;
  messages.INVALID_EXECUTION_CONTEXT = INVALID_EXECUTION_CONTEXT;
  return messages;
}
var routerExplorer = {};
var unknownRequestMapping_exception = {};
var hasRequiredUnknownRequestMapping_exception;
function requireUnknownRequestMapping_exception() {
  if (hasRequiredUnknownRequestMapping_exception)
    return unknownRequestMapping_exception;
  hasRequiredUnknownRequestMapping_exception = 1;
  Object.defineProperty(unknownRequestMapping_exception, "__esModule", { value: true });
  unknownRequestMapping_exception.UnknownRequestMappingException = void 0;
  const runtime_exception_1 = requireRuntime_exception();
  const messages_1 = requireMessages$1();
  class UnknownRequestMappingException extends runtime_exception_1.RuntimeException {
    constructor(metatype) {
      super((0, messages_1.UNKNOWN_REQUEST_MAPPING)(metatype));
    }
  }
  unknownRequestMapping_exception.UnknownRequestMappingException = UnknownRequestMappingException;
  return unknownRequestMapping_exception;
}
var routerMethodFactory = {};
var hasRequiredRouterMethodFactory;
function requireRouterMethodFactory() {
  if (hasRequiredRouterMethodFactory)
    return routerMethodFactory;
  hasRequiredRouterMethodFactory = 1;
  Object.defineProperty(routerMethodFactory, "__esModule", { value: true });
  routerMethodFactory.RouterMethodFactory = void 0;
  const request_method_enum_1 = requireRequestMethod_enum();
  class RouterMethodFactory {
    get(target, requestMethod) {
      switch (requestMethod) {
        case request_method_enum_1.RequestMethod.POST:
          return target.post;
        case request_method_enum_1.RequestMethod.ALL:
          return target.all;
        case request_method_enum_1.RequestMethod.DELETE:
          return target.delete;
        case request_method_enum_1.RequestMethod.PUT:
          return target.put;
        case request_method_enum_1.RequestMethod.PATCH:
          return target.patch;
        case request_method_enum_1.RequestMethod.OPTIONS:
          return target.options;
        case request_method_enum_1.RequestMethod.HEAD:
          return target.head;
        case request_method_enum_1.RequestMethod.GET:
          return target.get;
        default: {
          return target.use;
        }
      }
    }
  }
  routerMethodFactory.RouterMethodFactory = RouterMethodFactory;
  return routerMethodFactory;
}
var routeParamsFactory = {};
var hasRequiredRouteParamsFactory;
function requireRouteParamsFactory() {
  if (hasRequiredRouteParamsFactory)
    return routeParamsFactory;
  hasRequiredRouteParamsFactory = 1;
  Object.defineProperty(routeParamsFactory, "__esModule", { value: true });
  routeParamsFactory.RouteParamsFactory = void 0;
  const route_paramtypes_enum_1 = requireRouteParamtypes_enum();
  class RouteParamsFactory {
    exchangeKeyForValue(key, data, { req, res, next }) {
      switch (key) {
        case route_paramtypes_enum_1.RouteParamtypes.NEXT:
          return next;
        case route_paramtypes_enum_1.RouteParamtypes.REQUEST:
          return req;
        case route_paramtypes_enum_1.RouteParamtypes.RESPONSE:
          return res;
        case route_paramtypes_enum_1.RouteParamtypes.BODY:
          return data && req.body ? req.body[data] : req.body;
        case route_paramtypes_enum_1.RouteParamtypes.PARAM:
          return data ? req.params[data] : req.params;
        case route_paramtypes_enum_1.RouteParamtypes.HOST:
          const hosts = req.hosts || {};
          return data ? hosts[data] : hosts;
        case route_paramtypes_enum_1.RouteParamtypes.QUERY:
          return data ? req.query[data] : req.query;
        case route_paramtypes_enum_1.RouteParamtypes.HEADERS:
          return data ? req.headers[data.toLowerCase()] : req.headers;
        case route_paramtypes_enum_1.RouteParamtypes.SESSION:
          return req.session;
        case route_paramtypes_enum_1.RouteParamtypes.FILE:
          return req[data || "file"];
        case route_paramtypes_enum_1.RouteParamtypes.FILES:
          return req.files;
        case route_paramtypes_enum_1.RouteParamtypes.IP:
          return req.ip;
        default:
          return null;
      }
    }
  }
  routeParamsFactory.RouteParamsFactory = RouteParamsFactory;
  return routeParamsFactory;
}
var routerExecutionContext = {};
var routerResponseController = {};
var sseStream = {};
var hasRequiredSseStream;
function requireSseStream() {
  if (hasRequiredSseStream)
    return sseStream;
  hasRequiredSseStream = 1;
  Object.defineProperty(sseStream, "__esModule", { value: true });
  sseStream.SseStream = void 0;
  const shared_utils_1 = requireShared_utils();
  const stream_12 = require$$0$4;
  function toDataString(data) {
    if ((0, shared_utils_1.isObject)(data)) {
      return toDataString(JSON.stringify(data));
    }
    return data.split(/\r\n|\r|\n/).map((line) => `data: ${line}
`).join("");
  }
  class SseStream extends stream_12.Transform {
    constructor(req) {
      super({ objectMode: true });
      this.lastEventId = null;
      if (req && req.socket) {
        req.socket.setKeepAlive(true);
        req.socket.setNoDelay(true);
        req.socket.setTimeout(0);
      }
    }
    pipe(destination, options) {
      if (destination.writeHead) {
        destination.writeHead(200, Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.additionalHeaders), {
          // See https://github.com/dunglas/mercure/blob/master/hub/subscribe.go#L124-L130
          "Content-Type": "text/event-stream",
          Connection: "keep-alive",
          // Disable cache, even for old browsers and proxies
          "Cache-Control": "private, no-cache, no-store, must-revalidate, max-age=0, no-transform",
          Pragma: "no-cache",
          Expire: "0",
          // NGINX support https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/#x-accel-buffering
          "X-Accel-Buffering": "no"
        }));
        destination.flushHeaders();
      }
      destination.write("\n");
      return super.pipe(destination, options);
    }
    _transform(message, encoding2, callback) {
      let data = message.type ? `event: ${message.type}
` : "";
      data += message.id ? `id: ${message.id}
` : "";
      data += message.retry ? `retry: ${message.retry}
` : "";
      data += message.data ? toDataString(message.data) : "";
      data += "\n";
      this.push(data);
      callback();
    }
    /**
     * Calls `.write` but handles the drain if needed
     */
    writeMessage(message, cb) {
      if (!message.id) {
        this.lastEventId++;
        message.id = this.lastEventId.toString();
      }
      if (!this.write(message, "utf-8", cb)) {
        this.once("drain", cb);
      } else {
        process.nextTick(cb);
      }
    }
  }
  sseStream.SseStream = SseStream;
  return sseStream;
}
var hasRequiredRouterResponseController;
function requireRouterResponseController() {
  if (hasRequiredRouterResponseController)
    return routerResponseController;
  hasRequiredRouterResponseController = 1;
  Object.defineProperty(routerResponseController, "__esModule", { value: true });
  routerResponseController.RouterResponseController = void 0;
  const common_1 = requireCommon$3();
  const shared_utils_1 = requireShared_utils();
  const rxjs_1 = requireCjs();
  const operators_1 = requireOperators();
  const sse_stream_1 = requireSseStream();
  class RouterResponseController {
    constructor(applicationRef) {
      this.applicationRef = applicationRef;
      this.logger = new common_1.Logger(RouterResponseController.name);
    }
    async apply(result, response2, httpStatusCode) {
      return this.applicationRef.reply(response2, result, httpStatusCode);
    }
    async redirect(resultOrDeferred, response2, redirectResponse) {
      const result = await this.transformToResult(resultOrDeferred);
      const statusCode = result && result.statusCode ? result.statusCode : redirectResponse.statusCode ? redirectResponse.statusCode : common_1.HttpStatus.FOUND;
      const url2 = result && result.url ? result.url : redirectResponse.url;
      this.applicationRef.redirect(response2, statusCode, url2);
    }
    async render(resultOrDeferred, response2, template) {
      const result = await this.transformToResult(resultOrDeferred);
      return this.applicationRef.render(response2, template, result);
    }
    async transformToResult(resultOrDeferred) {
      if ((0, rxjs_1.isObservable)(resultOrDeferred)) {
        return (0, rxjs_1.lastValueFrom)(resultOrDeferred);
      }
      return resultOrDeferred;
    }
    getStatusByMethod(requestMethod) {
      switch (requestMethod) {
        case common_1.RequestMethod.POST:
          return common_1.HttpStatus.CREATED;
        default:
          return common_1.HttpStatus.OK;
      }
    }
    setHeaders(response2, headers) {
      headers.forEach(({ name, value }) => this.applicationRef.setHeader(response2, name, value));
    }
    setStatus(response2, statusCode) {
      this.applicationRef.status(response2, statusCode);
    }
    sse(result, response2, request2, options) {
      if (response2.writableEnded) {
        return;
      }
      this.assertObservable(result);
      const stream2 = new sse_stream_1.SseStream(request2);
      stream2.pipe(response2, options);
      const subscription = result.pipe((0, operators_1.map)((message) => {
        if ((0, shared_utils_1.isObject)(message)) {
          return message;
        }
        return { data: message };
      }), (0, operators_1.debounce)((message) => new Promise((resolve2) => stream2.writeMessage(message, () => resolve2()))), (0, operators_1.catchError)((err) => {
        const data = err instanceof Error ? err.message : err;
        stream2.writeMessage({ type: "error", data }, (writeError) => {
          if (writeError) {
            this.logger.error(writeError);
          }
        });
        return rxjs_1.EMPTY;
      })).subscribe({
        complete: () => {
          response2.end();
        }
      });
      request2.on("close", () => {
        subscription.unsubscribe();
      });
    }
    assertObservable(value) {
      if (!(0, rxjs_1.isObservable)(value)) {
        throw new ReferenceError("You must return an Observable stream to use Server-Sent Events (SSE).");
      }
    }
  }
  routerResponseController.RouterResponseController = RouterResponseController;
  return routerResponseController;
}
var hasRequiredRouterExecutionContext;
function requireRouterExecutionContext() {
  if (hasRequiredRouterExecutionContext)
    return routerExecutionContext;
  hasRequiredRouterExecutionContext = 1;
  Object.defineProperty(routerExecutionContext, "__esModule", { value: true });
  routerExecutionContext.RouterExecutionContext = void 0;
  const common_1 = requireCommon$3();
  const constants_1 = requireConstants$4();
  const route_paramtypes_enum_1 = requireRouteParamtypes_enum();
  const shared_utils_1 = requireShared_utils();
  const guards_1 = requireGuards();
  const context_utils_1 = requireContextUtils();
  const handler_metadata_storage_1 = requireHandlerMetadataStorage();
  const constants_2 = requireConstants$2();
  const router_response_controller_1 = requireRouterResponseController();
  class RouterExecutionContext {
    constructor(paramsFactory, pipesContextCreator2, pipesConsumer2, guardsContextCreator2, guardsConsumer2, interceptorsContextCreator2, interceptorsConsumer2, applicationRef) {
      this.paramsFactory = paramsFactory;
      this.pipesContextCreator = pipesContextCreator2;
      this.pipesConsumer = pipesConsumer2;
      this.guardsContextCreator = guardsContextCreator2;
      this.guardsConsumer = guardsConsumer2;
      this.interceptorsContextCreator = interceptorsContextCreator2;
      this.interceptorsConsumer = interceptorsConsumer2;
      this.applicationRef = applicationRef;
      this.handlerMetadataStorage = new handler_metadata_storage_1.HandlerMetadataStorage();
      this.contextUtils = new context_utils_1.ContextUtils();
      this.responseController = new router_response_controller_1.RouterResponseController(applicationRef);
    }
    create(instance, callback, methodName, moduleKey, requestMethod, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      const contextType = "http";
      const { argsLength, fnHandleResponse, paramtypes, getParamsMetadata, httpStatusCode, responseHeaders, hasCustomHeaders } = this.getMetadata(instance, callback, methodName, moduleKey, requestMethod, contextType);
      const paramsOptions = this.contextUtils.mergeParamsMetatypes(getParamsMetadata(moduleKey, contextId, inquirerId), paramtypes);
      const pipes2 = this.pipesContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);
      const guards2 = this.guardsContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);
      const interceptors2 = this.interceptorsContextCreator.create(instance, callback, moduleKey, contextId, inquirerId);
      const fnCanActivate = this.createGuardsFn(guards2, instance, callback, contextType);
      const fnApplyPipes = this.createPipesFn(pipes2, paramsOptions);
      const handler = (args2, req, res, next) => async () => {
        fnApplyPipes && await fnApplyPipes(args2, req, res, next);
        return callback.apply(instance, args2);
      };
      return async (req, res, next) => {
        const args2 = this.contextUtils.createNullArray(argsLength);
        fnCanActivate && await fnCanActivate([req, res, next]);
        this.responseController.setStatus(res, httpStatusCode);
        hasCustomHeaders && this.responseController.setHeaders(res, responseHeaders);
        const result = await this.interceptorsConsumer.intercept(interceptors2, [req, res, next], instance, callback, handler(args2, req, res, next), contextType);
        await fnHandleResponse(result, res, req);
      };
    }
    getMetadata(instance, callback, methodName, moduleKey, requestMethod, contextType) {
      const cacheMetadata = this.handlerMetadataStorage.get(instance, methodName);
      if (cacheMetadata) {
        return cacheMetadata;
      }
      const metadata2 = this.contextUtils.reflectCallbackMetadata(instance, methodName, constants_1.ROUTE_ARGS_METADATA) || {};
      const keys = Object.keys(metadata2);
      const argsLength = this.contextUtils.getArgumentsLength(keys, metadata2);
      const paramtypes = this.contextUtils.reflectCallbackParamtypes(instance, methodName);
      const contextFactory = this.contextUtils.getContextFactory(contextType, instance, callback);
      const getParamsMetadata = (moduleKey2, contextId = constants_2.STATIC_CONTEXT, inquirerId) => this.exchangeKeysForValues(keys, metadata2, moduleKey2, contextId, inquirerId, contextFactory);
      const paramsMetadata = getParamsMetadata(moduleKey);
      const isResponseHandled = this.isResponseHandled(instance, methodName, paramsMetadata);
      const httpRedirectResponse = this.reflectRedirect(callback);
      const fnHandleResponse = this.createHandleResponseFn(callback, isResponseHandled, httpRedirectResponse);
      const httpCode = this.reflectHttpStatusCode(callback);
      const httpStatusCode = httpCode ? httpCode : this.responseController.getStatusByMethod(requestMethod);
      const responseHeaders = this.reflectResponseHeaders(callback);
      const hasCustomHeaders = !(0, shared_utils_1.isEmpty)(responseHeaders);
      const handlerMetadata = {
        argsLength,
        fnHandleResponse,
        paramtypes,
        getParamsMetadata,
        httpStatusCode,
        hasCustomHeaders,
        responseHeaders
      };
      this.handlerMetadataStorage.set(instance, methodName, handlerMetadata);
      return handlerMetadata;
    }
    reflectRedirect(callback) {
      return Reflect.getMetadata(constants_1.REDIRECT_METADATA, callback);
    }
    reflectHttpStatusCode(callback) {
      return Reflect.getMetadata(constants_1.HTTP_CODE_METADATA, callback);
    }
    reflectRenderTemplate(callback) {
      return Reflect.getMetadata(constants_1.RENDER_METADATA, callback);
    }
    reflectResponseHeaders(callback) {
      return Reflect.getMetadata(constants_1.HEADERS_METADATA, callback) || [];
    }
    reflectSse(callback) {
      return Reflect.getMetadata(constants_1.SSE_METADATA, callback);
    }
    exchangeKeysForValues(keys, metadata2, moduleContext, contextId = constants_2.STATIC_CONTEXT, inquirerId, contextFactory) {
      this.pipesContextCreator.setModuleContext(moduleContext);
      return keys.map((key) => {
        const { index, data, pipes: pipesCollection } = metadata2[key];
        const pipes2 = this.pipesContextCreator.createConcreteContext(pipesCollection, contextId, inquirerId);
        const type2 = this.contextUtils.mapParamType(key);
        if (key.includes(constants_1.CUSTOM_ROUTE_ARGS_METADATA)) {
          const { factory: factory2 } = metadata2[key];
          const customExtractValue = this.contextUtils.getCustomFactory(factory2, data, contextFactory);
          return { index, extractValue: customExtractValue, type: type2, data, pipes: pipes2 };
        }
        const numericType = Number(type2);
        const extractValue = (req, res, next) => this.paramsFactory.exchangeKeyForValue(numericType, data, {
          req,
          res,
          next
        });
        return { index, extractValue, type: numericType, data, pipes: pipes2 };
      });
    }
    async getParamValue(value, { metatype, type: type2, data }, pipes2) {
      if (!(0, shared_utils_1.isEmpty)(pipes2)) {
        return this.pipesConsumer.apply(value, { metatype, type: type2, data }, pipes2);
      }
      return value;
    }
    isPipeable(type2) {
      return type2 === route_paramtypes_enum_1.RouteParamtypes.BODY || type2 === route_paramtypes_enum_1.RouteParamtypes.QUERY || type2 === route_paramtypes_enum_1.RouteParamtypes.PARAM || type2 === route_paramtypes_enum_1.RouteParamtypes.FILE || type2 === route_paramtypes_enum_1.RouteParamtypes.FILES || (0, shared_utils_1.isString)(type2);
    }
    createGuardsFn(guards2, instance, callback, contextType) {
      const canActivateFn = async (args2) => {
        const canActivate = await this.guardsConsumer.tryActivate(guards2, args2, instance, callback, contextType);
        if (!canActivate) {
          throw new common_1.ForbiddenException(guards_1.FORBIDDEN_MESSAGE);
        }
      };
      return guards2.length ? canActivateFn : null;
    }
    createPipesFn(pipes2, paramsOptions) {
      const pipesFn = async (args2, req, res, next) => {
        const resolveParamValue = async (param) => {
          const { index, extractValue, type: type2, data, metatype, pipes: paramPipes } = param;
          const value = extractValue(req, res, next);
          args2[index] = this.isPipeable(type2) ? await this.getParamValue(value, { metatype, type: type2, data }, pipes2.concat(paramPipes)) : value;
        };
        await Promise.all(paramsOptions.map(resolveParamValue));
      };
      return paramsOptions.length ? pipesFn : null;
    }
    createHandleResponseFn(callback, isResponseHandled, redirectResponse, httpStatusCode) {
      const renderTemplate = this.reflectRenderTemplate(callback);
      if (renderTemplate) {
        return async (result, res) => {
          return await this.responseController.render(result, res, renderTemplate);
        };
      }
      if (redirectResponse && (0, shared_utils_1.isString)(redirectResponse.url)) {
        return async (result, res) => {
          await this.responseController.redirect(result, res, redirectResponse);
        };
      }
      const isSseHandler = !!this.reflectSse(callback);
      if (isSseHandler) {
        return (result, res, req) => {
          var _a;
          this.responseController.sse(result, res.raw || res, req.raw || req, { additionalHeaders: (_a = res.getHeaders) === null || _a === void 0 ? void 0 : _a.call(res) });
        };
      }
      return async (result, res) => {
        result = await this.responseController.transformToResult(result);
        !isResponseHandled && await this.responseController.apply(result, res, httpStatusCode);
        return res;
      };
    }
    isResponseHandled(instance, methodName, paramsMetadata) {
      const hasResponseOrNextDecorator = paramsMetadata.some(({ type: type2 }) => type2 === route_paramtypes_enum_1.RouteParamtypes.RESPONSE || type2 === route_paramtypes_enum_1.RouteParamtypes.NEXT);
      const isPassthroughEnabled = this.contextUtils.reflectPassthrough(instance, methodName);
      return hasResponseOrNextDecorator && !isPassthroughEnabled;
    }
  }
  routerExecutionContext.RouterExecutionContext = RouterExecutionContext;
  return routerExecutionContext;
}
var hasRequiredRouterExplorer;
function requireRouterExplorer() {
  if (hasRequiredRouterExplorer)
    return routerExplorer;
  hasRequiredRouterExplorer = 1;
  Object.defineProperty(routerExplorer, "__esModule", { value: true });
  routerExplorer.RouterExplorer = void 0;
  const constants_1 = requireConstants$4();
  const enums_1 = requireEnums();
  const exceptions_1 = requireExceptions$2();
  const logger_service_1 = requireLogger_service();
  const shared_utils_1 = requireShared_utils();
  const pathToRegexp2 = requirePathToRegexp$1();
  const unknown_request_mapping_exception_1 = requireUnknownRequestMapping_exception();
  const guards_1 = requireGuards();
  const context_id_factory_1 = requireContextIdFactory();
  const execution_context_host_1 = requireExecutionContextHost();
  const messages_1 = requireMessages();
  const router_method_factory_1 = requireRouterMethodFactory();
  const constants_2 = requireConstants$2();
  const interceptors_1 = requireInterceptors$1();
  const pipes_1 = requirePipes();
  const paths_explorer_1 = requirePathsExplorer();
  const request_constants_1 = requireRequestConstants();
  const route_params_factory_1 = requireRouteParamsFactory();
  const router_execution_context_1 = requireRouterExecutionContext();
  class RouterExplorer {
    constructor(metadataScanner2, container2, injector2, routerProxy2, exceptionsFilter, config2, routePathFactory2, graphInspector2) {
      this.container = container2;
      this.injector = injector2;
      this.routerProxy = routerProxy2;
      this.exceptionsFilter = exceptionsFilter;
      this.routePathFactory = routePathFactory2;
      this.graphInspector = graphInspector2;
      this.routerMethodFactory = new router_method_factory_1.RouterMethodFactory();
      this.logger = new logger_service_1.Logger(RouterExplorer.name, {
        timestamp: true
      });
      this.exceptionFiltersCache = /* @__PURE__ */ new WeakMap();
      this.pathsExplorer = new paths_explorer_1.PathsExplorer(metadataScanner2);
      const routeParamsFactory2 = new route_params_factory_1.RouteParamsFactory();
      const pipesContextCreator2 = new pipes_1.PipesContextCreator(container2, config2);
      const pipesConsumer2 = new pipes_1.PipesConsumer();
      const guardsContextCreator2 = new guards_1.GuardsContextCreator(container2, config2);
      const guardsConsumer2 = new guards_1.GuardsConsumer();
      const interceptorsContextCreator2 = new interceptors_1.InterceptorsContextCreator(container2, config2);
      const interceptorsConsumer2 = new interceptors_1.InterceptorsConsumer();
      this.executionContextCreator = new router_execution_context_1.RouterExecutionContext(routeParamsFactory2, pipesContextCreator2, pipesConsumer2, guardsContextCreator2, guardsConsumer2, interceptorsContextCreator2, interceptorsConsumer2, container2.getHttpAdapterRef());
    }
    explore(instanceWrapper2, moduleKey, applicationRef, host, routePathMetadata) {
      const { instance } = instanceWrapper2;
      const routerPaths = this.pathsExplorer.scanForPaths(instance);
      this.applyPathsToRouterProxy(applicationRef, routerPaths, instanceWrapper2, moduleKey, routePathMetadata, host);
    }
    extractRouterPath(metatype) {
      const path2 = Reflect.getMetadata(constants_1.PATH_METADATA, metatype);
      if ((0, shared_utils_1.isUndefined)(path2)) {
        throw new unknown_request_mapping_exception_1.UnknownRequestMappingException(metatype);
      }
      if (Array.isArray(path2)) {
        return path2.map((p) => (0, shared_utils_1.addLeadingSlash)(p));
      }
      return [(0, shared_utils_1.addLeadingSlash)(path2)];
    }
    applyPathsToRouterProxy(router2, routeDefinitions, instanceWrapper2, moduleKey, routePathMetadata, host) {
      (routeDefinitions || []).forEach((routeDefinition) => {
        const { version: methodVersion } = routeDefinition;
        routePathMetadata.methodVersion = methodVersion;
        this.applyCallbackToRouter(router2, routeDefinition, instanceWrapper2, moduleKey, routePathMetadata, host);
      });
    }
    applyCallbackToRouter(router2, routeDefinition, instanceWrapper2, moduleKey, routePathMetadata, host) {
      const { path: paths, requestMethod, targetCallback, methodName } = routeDefinition;
      const { instance } = instanceWrapper2;
      const routerMethodRef = this.routerMethodFactory.get(router2, requestMethod).bind(router2);
      const isRequestScoped = !instanceWrapper2.isDependencyTreeStatic();
      const proxy = isRequestScoped ? this.createRequestScopedHandler(instanceWrapper2, requestMethod, this.container.getModuleByKey(moduleKey), moduleKey, methodName) : this.createCallbackProxy(instance, targetCallback, methodName, moduleKey, requestMethod);
      const isVersioned = (routePathMetadata.methodVersion || routePathMetadata.controllerVersion) && routePathMetadata.versioningOptions;
      let routeHandler = this.applyHostFilter(host, proxy);
      paths.forEach((path2) => {
        if (isVersioned && routePathMetadata.versioningOptions.type !== enums_1.VersioningType.URI) {
          routeHandler = this.applyVersionFilter(router2, routePathMetadata, routeHandler);
        }
        routePathMetadata.methodPath = path2;
        const pathsToRegister = this.routePathFactory.create(routePathMetadata, requestMethod);
        pathsToRegister.forEach((path3) => {
          const entrypointDefinition = {
            type: "http-endpoint",
            methodName,
            className: instanceWrapper2.name,
            classNodeId: instanceWrapper2.id,
            metadata: {
              key: path3,
              path: path3,
              requestMethod: enums_1.RequestMethod[requestMethod],
              methodVersion: routePathMetadata.methodVersion,
              controllerVersion: routePathMetadata.controllerVersion
            }
          };
          routerMethodRef(path3, routeHandler);
          this.graphInspector.insertEntrypointDefinition(entrypointDefinition, instanceWrapper2.id);
        });
        const pathsToLog = this.routePathFactory.create(Object.assign(Object.assign({}, routePathMetadata), { versioningOptions: void 0 }), requestMethod);
        pathsToLog.forEach((path3) => {
          if (isVersioned) {
            const version = this.routePathFactory.getVersion(routePathMetadata);
            this.logger.log((0, messages_1.VERSIONED_ROUTE_MAPPED_MESSAGE)(path3, requestMethod, version));
          } else {
            this.logger.log((0, messages_1.ROUTE_MAPPED_MESSAGE)(path3, requestMethod));
          }
        });
      });
    }
    applyHostFilter(host, handler) {
      if (!host) {
        return handler;
      }
      const httpAdapterRef = this.container.getHttpAdapterRef();
      const hosts = Array.isArray(host) ? host : [host];
      const hostRegExps = hosts.map((host2) => {
        const keys = [];
        const regexp = pathToRegexp2(host2, keys);
        return { regexp, keys };
      });
      const unsupportedFilteringErrorMessage = Array.isArray(host) ? `HTTP adapter does not support filtering on hosts: ["${host.join('", "')}"]` : `HTTP adapter does not support filtering on host: "${host}"`;
      return (req, res, next) => {
        req.hosts = {};
        const hostname = httpAdapterRef.getRequestHostname(req) || "";
        for (const exp of hostRegExps) {
          const match = hostname.match(exp.regexp);
          if (match) {
            exp.keys.forEach((key, i) => req.hosts[key.name] = match[i + 1]);
            return handler(req, res, next);
          }
        }
        if (!next) {
          throw new exceptions_1.InternalServerErrorException(unsupportedFilteringErrorMessage);
        }
        return next();
      };
    }
    applyVersionFilter(router2, routePathMetadata, handler) {
      const version = this.routePathFactory.getVersion(routePathMetadata);
      return router2.applyVersionFilter(handler, version, routePathMetadata.versioningOptions);
    }
    createCallbackProxy(instance, callback, methodName, moduleRef2, requestMethod, contextId = constants_2.STATIC_CONTEXT, inquirerId) {
      const executionContext = this.executionContextCreator.create(instance, callback, methodName, moduleRef2, requestMethod, contextId, inquirerId);
      const exceptionFilter = this.exceptionsFilter.create(instance, callback, moduleRef2, contextId, inquirerId);
      return this.routerProxy.createProxy(executionContext, exceptionFilter);
    }
    createRequestScopedHandler(instanceWrapper2, requestMethod, moduleRef2, moduleKey, methodName) {
      const { instance } = instanceWrapper2;
      const collection = moduleRef2.controllers;
      const isTreeDurable = instanceWrapper2.isDependencyTreeDurable();
      return async (req, res, next) => {
        try {
          const contextId = this.getContextId(req, isTreeDurable);
          const contextInstance = await this.injector.loadPerContext(instance, moduleRef2, collection, contextId);
          await this.createCallbackProxy(contextInstance, contextInstance[methodName], methodName, moduleKey, requestMethod, contextId, instanceWrapper2.id)(req, res, next);
        } catch (err) {
          let exceptionFilter = this.exceptionFiltersCache.get(instance[methodName]);
          if (!exceptionFilter) {
            exceptionFilter = this.exceptionsFilter.create(instance, instance[methodName], moduleKey);
            this.exceptionFiltersCache.set(instance[methodName], exceptionFilter);
          }
          const host = new execution_context_host_1.ExecutionContextHost([req, res, next]);
          exceptionFilter.next(err, host);
        }
      };
    }
    getContextId(request2, isTreeDurable) {
      const contextId = context_id_factory_1.ContextIdFactory.getByRequest(request2);
      if (!request2[request_constants_1.REQUEST_CONTEXT_ID]) {
        Object.defineProperty(request2, request_constants_1.REQUEST_CONTEXT_ID, {
          value: contextId,
          enumerable: false,
          writable: false,
          configurable: false
        });
        const requestProviderValue = isTreeDurable ? contextId.payload : request2;
        this.container.registerRequestProvider(requestProviderValue, contextId);
      }
      return contextId;
    }
  }
  routerExplorer.RouterExplorer = RouterExplorer;
  return routerExplorer;
}
var hasRequiredRoutesResolver;
function requireRoutesResolver() {
  if (hasRequiredRoutesResolver)
    return routesResolver;
  hasRequiredRoutesResolver = 1;
  Object.defineProperty(routesResolver, "__esModule", { value: true });
  routesResolver.RoutesResolver = void 0;
  const common_1 = requireCommon$3();
  const constants_1 = requireConstants$4();
  const logger_service_1 = requireLogger_service();
  const messages_1 = requireMessages();
  const metadata_scanner_1 = requireMetadataScanner();
  const route_path_factory_1 = requireRoutePathFactory();
  const router_exception_filters_1 = requireRouterExceptionFilters();
  const router_explorer_1 = requireRouterExplorer();
  const router_proxy_1 = requireRouterProxy();
  class RoutesResolver {
    constructor(container2, applicationConfig2, injector2, graphInspector2) {
      this.container = container2;
      this.applicationConfig = applicationConfig2;
      this.injector = injector2;
      this.logger = new logger_service_1.Logger(RoutesResolver.name, {
        timestamp: true
      });
      this.routerProxy = new router_proxy_1.RouterProxy();
      const httpAdapterRef = container2.getHttpAdapterRef();
      this.routerExceptionsFilter = new router_exception_filters_1.RouterExceptionFilters(container2, applicationConfig2, httpAdapterRef);
      this.routePathFactory = new route_path_factory_1.RoutePathFactory(this.applicationConfig);
      const metadataScanner2 = new metadata_scanner_1.MetadataScanner();
      this.routerExplorer = new router_explorer_1.RouterExplorer(metadataScanner2, this.container, this.injector, this.routerProxy, this.routerExceptionsFilter, this.applicationConfig, this.routePathFactory, graphInspector2);
    }
    resolve(applicationRef, globalPrefix) {
      const modules2 = this.container.getModules();
      modules2.forEach(({ controllers, metatype }, moduleName) => {
        const modulePath = this.getModulePathMetadata(metatype);
        this.registerRouters(controllers, moduleName, globalPrefix, modulePath, applicationRef);
      });
    }
    registerRouters(routes, moduleName, globalPrefix, modulePath, applicationRef) {
      routes.forEach((instanceWrapper2) => {
        const { metatype } = instanceWrapper2;
        const host = this.getHostMetadata(metatype);
        const routerPaths = this.routerExplorer.extractRouterPath(metatype);
        const controllerVersion = this.getVersionMetadata(metatype);
        const controllerName = metatype.name;
        routerPaths.forEach((path2) => {
          const pathsToLog = this.routePathFactory.create({
            ctrlPath: path2,
            modulePath,
            globalPrefix
          });
          if (!controllerVersion) {
            pathsToLog.forEach((path3) => {
              const logMessage = (0, messages_1.CONTROLLER_MAPPING_MESSAGE)(controllerName, path3);
              this.logger.log(logMessage);
            });
          } else {
            pathsToLog.forEach((path3) => {
              const logMessage = (0, messages_1.VERSIONED_CONTROLLER_MAPPING_MESSAGE)(controllerName, path3, controllerVersion);
              this.logger.log(logMessage);
            });
          }
          const versioningOptions = this.applicationConfig.getVersioning();
          const routePathMetadata = {
            ctrlPath: path2,
            modulePath,
            globalPrefix,
            controllerVersion,
            versioningOptions
          };
          this.routerExplorer.explore(instanceWrapper2, moduleName, applicationRef, host, routePathMetadata);
        });
      });
    }
    registerNotFoundHandler() {
      const applicationRef = this.container.getHttpAdapterRef();
      const callback = (req, res) => {
        const method = applicationRef.getRequestMethod(req);
        const url2 = applicationRef.getRequestUrl(req);
        throw new common_1.NotFoundException(`Cannot ${method} ${url2}`);
      };
      const handler = this.routerExceptionsFilter.create({}, callback, void 0);
      const proxy = this.routerProxy.createProxy(callback, handler);
      applicationRef.setNotFoundHandler && applicationRef.setNotFoundHandler(proxy, this.applicationConfig.getGlobalPrefix());
    }
    registerExceptionHandler() {
      const callback = (err, req, res, next) => {
        throw this.mapExternalException(err);
      };
      const handler = this.routerExceptionsFilter.create({}, callback, void 0);
      const proxy = this.routerProxy.createExceptionLayerProxy(callback, handler);
      const applicationRef = this.container.getHttpAdapterRef();
      applicationRef.setErrorHandler && applicationRef.setErrorHandler(proxy, this.applicationConfig.getGlobalPrefix());
    }
    mapExternalException(err) {
      switch (true) {
        case (err instanceof SyntaxError || err instanceof URIError):
          return new common_1.BadRequestException(err.message);
        default:
          return err;
      }
    }
    getModulePathMetadata(metatype) {
      const modulesContainer2 = this.container.getModules();
      const modulePath = Reflect.getMetadata(constants_1.MODULE_PATH + modulesContainer2.applicationId, metatype);
      return modulePath !== null && modulePath !== void 0 ? modulePath : Reflect.getMetadata(constants_1.MODULE_PATH, metatype);
    }
    getHostMetadata(metatype) {
      return Reflect.getMetadata(constants_1.HOST_METADATA, metatype);
    }
    getVersionMetadata(metatype) {
      var _a;
      const versioningConfig = this.applicationConfig.getVersioning();
      if (versioningConfig) {
        return (_a = Reflect.getMetadata(constants_1.VERSION_METADATA, metatype)) !== null && _a !== void 0 ? _a : versioningConfig.defaultVersion;
      }
    }
  }
  routesResolver.RoutesResolver = RoutesResolver;
  return routesResolver;
}
const core$a = {};
const core$b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: core$a
}, Symbol.toStringTag, { value: "Module" }));
const require$$15 = /* @__PURE__ */ getAugmentedNamespace(core$b);
const core$8 = {};
const core$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: core$8
}, Symbol.toStringTag, { value: "Module" }));
const require$$16 = /* @__PURE__ */ getAugmentedNamespace(core$9);
const core$6 = {};
const core$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: core$6
}, Symbol.toStringTag, { value: "Module" }));
const require$$18 = /* @__PURE__ */ getAugmentedNamespace(core$7);
var hasRequiredNestApplication;
function requireNestApplication() {
  if (hasRequiredNestApplication)
    return nestApplication;
  hasRequiredNestApplication = 1;
  Object.defineProperty(nestApplication, "__esModule", { value: true });
  nestApplication.NestApplication = void 0;
  const common_1 = requireCommon$3();
  const logger_service_1 = requireLogger_service();
  const load_package_util_1 = requireLoadPackage_util();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const os_1 = require$$1$2;
  const application_config_1 = requireApplicationConfig();
  const constants_1 = requireConstants$5();
  const optional_require_1 = requireOptionalRequire();
  const injector_1 = requireInjector$1();
  const container_1 = requireContainer();
  const middleware_module_1 = requireMiddlewareModule();
  const utils_12 = requireUtils$3();
  const nest_application_context_1 = requireNestApplicationContext();
  const routes_resolver_1 = requireRoutesResolver();
  const { SocketModule } = (0, optional_require_1.optionalRequire)("@nestjs/websockets/socket-module", () => require$$15);
  const { MicroservicesModule } = (0, optional_require_1.optionalRequire)("@nestjs/microservices/microservices-module", () => require$$16);
  class NestApplication extends nest_application_context_1.NestApplicationContext {
    constructor(container2, httpAdapter3, config2, graphInspector2, appOptions = {}) {
      super(container2, appOptions);
      this.httpAdapter = httpAdapter3;
      this.config = config2;
      this.graphInspector = graphInspector2;
      this.logger = new logger_service_1.Logger(NestApplication.name, {
        timestamp: true
      });
      this.middlewareContainer = new container_1.MiddlewareContainer(this.container);
      this.microservicesModule = MicroservicesModule && new MicroservicesModule();
      this.socketModule = SocketModule && new SocketModule();
      this.microservices = [];
      this.isListening = false;
      this.selectContextModule();
      this.registerHttpServer();
      this.injector = new injector_1.Injector({ preview: this.appOptions.preview });
      this.middlewareModule = new middleware_module_1.MiddlewareModule();
      this.routesResolver = new routes_resolver_1.RoutesResolver(this.container, this.config, this.injector, this.graphInspector);
    }
    async dispose() {
      this.socketModule && await this.socketModule.close();
      this.microservicesModule && await this.microservicesModule.close();
      this.httpAdapter && await this.httpAdapter.close();
      await Promise.all((0, iterare_1.iterate)(this.microservices).map(async (microservice) => {
        microservice.setIsTerminated(true);
        await microservice.close();
      }));
    }
    getHttpAdapter() {
      return this.httpAdapter;
    }
    registerHttpServer() {
      this.httpServer = this.createServer();
    }
    getUnderlyingHttpServer() {
      return this.httpAdapter.getHttpServer();
    }
    applyOptions() {
      if (!this.appOptions || !this.appOptions.cors) {
        return void 0;
      }
      const passCustomOptions = (0, shared_utils_1.isObject)(this.appOptions.cors) || (0, shared_utils_1.isFunction)(this.appOptions.cors);
      if (!passCustomOptions) {
        return this.enableCors();
      }
      return this.enableCors(this.appOptions.cors);
    }
    createServer() {
      this.httpAdapter.initHttpServer(this.appOptions);
      return this.httpAdapter.getHttpServer();
    }
    async registerModules() {
      this.registerWsModule();
      if (this.microservicesModule) {
        this.microservicesModule.register(this.container, this.graphInspector, this.config, this.appOptions);
        this.microservicesModule.setupClients(this.container);
      }
      await this.middlewareModule.register(this.middlewareContainer, this.container, this.config, this.injector, this.httpAdapter, this.graphInspector, this.appOptions);
    }
    registerWsModule() {
      if (!this.socketModule) {
        return;
      }
      this.socketModule.register(this.container, this.config, this.graphInspector, this.appOptions, this.httpServer);
    }
    async init() {
      var _a;
      this.applyOptions();
      await ((_a = this.httpAdapter) === null || _a === void 0 ? void 0 : _a.init());
      const useBodyParser = this.appOptions && this.appOptions.bodyParser !== false;
      useBodyParser && this.registerParserMiddleware();
      await this.registerModules();
      await this.registerRouter();
      await this.callInitHook();
      await this.registerRouterHooks();
      await this.callBootstrapHook();
      this.isInitialized = true;
      this.logger.log(constants_1.MESSAGES.APPLICATION_READY);
      return this;
    }
    registerParserMiddleware() {
      var _a;
      const prefix = this.config.getGlobalPrefix();
      const rawBody2 = !!((_a = this.appOptions) === null || _a === void 0 ? void 0 : _a.rawBody);
      this.httpAdapter.registerParserMiddleware(prefix, rawBody2);
    }
    async registerRouter() {
      await this.registerMiddleware(this.httpAdapter);
      const prefix = this.config.getGlobalPrefix();
      const basePath = (0, shared_utils_1.addLeadingSlash)(prefix);
      this.routesResolver.resolve(this.httpAdapter, basePath);
    }
    async registerRouterHooks() {
      this.routesResolver.registerNotFoundHandler();
      this.routesResolver.registerExceptionHandler();
    }
    connectMicroservice(microserviceOptions, hybridAppOptions = {}) {
      const { NestMicroservice } = (0, load_package_util_1.loadPackage)("@nestjs/microservices", "NestFactory", () => require$$18);
      const { inheritAppConfig } = hybridAppOptions;
      const applicationConfig2 = inheritAppConfig ? this.config : new application_config_1.ApplicationConfig();
      const instance = new NestMicroservice(this.container, microserviceOptions, this.graphInspector, applicationConfig2);
      instance.registerListeners();
      instance.setIsInitialized(true);
      instance.setIsInitHookCalled(true);
      this.microservices.push(instance);
      return instance;
    }
    getMicroservices() {
      return this.microservices;
    }
    getHttpServer() {
      return this.httpServer;
    }
    async startAllMicroservices() {
      this.assertNotInPreviewMode("startAllMicroservices");
      await Promise.all(this.microservices.map((msvc) => msvc.listen()));
      return this;
    }
    use(...args2) {
      this.httpAdapter.use(...args2);
      return this;
    }
    useBodyParser(...args2) {
      if (!("useBodyParser" in this.httpAdapter)) {
        this.logger.warn("Your HTTP Adapter does not support `.useBodyParser`.");
        return this;
      }
      const [parserType, ...otherArgs] = args2;
      const rawBody2 = !!this.appOptions.rawBody;
      this.httpAdapter.useBodyParser(...[parserType, rawBody2, ...otherArgs]);
      return this;
    }
    enableCors(options) {
      this.httpAdapter.enableCors(options);
    }
    enableVersioning(options = { type: common_1.VersioningType.URI }) {
      this.config.enableVersioning(options);
      return this;
    }
    async listen(port, ...args2) {
      this.assertNotInPreviewMode("listen");
      !this.isInitialized && await this.init();
      return new Promise((resolve2, reject) => {
        const errorHandler = (e) => {
          var _a;
          this.logger.error((_a = e === null || e === void 0 ? void 0 : e.toString) === null || _a === void 0 ? void 0 : _a.call(e));
          reject(e);
        };
        this.httpServer.once("error", errorHandler);
        const isCallbackInOriginalArgs = (0, shared_utils_1.isFunction)(args2[args2.length - 1]);
        const listenFnArgs = isCallbackInOriginalArgs ? args2.slice(0, args2.length - 1) : args2;
        this.httpAdapter.listen(port, ...listenFnArgs, (...originalCallbackArgs) => {
          var _a, _b;
          if ((_b = (_a = this.appOptions) === null || _a === void 0 ? void 0 : _a.autoFlushLogs) !== null && _b !== void 0 ? _b : true) {
            this.flushLogs();
          }
          if (originalCallbackArgs[0] instanceof Error) {
            return reject(originalCallbackArgs[0]);
          }
          const address = this.httpServer.address();
          if (address) {
            this.httpServer.removeListener("error", errorHandler);
            this.isListening = true;
            resolve2(this.httpServer);
          }
          if (isCallbackInOriginalArgs) {
            args2[args2.length - 1](...originalCallbackArgs);
          }
        });
      });
    }
    async getUrl() {
      return new Promise((resolve2, reject) => {
        if (!this.isListening) {
          this.logger.error(constants_1.MESSAGES.CALL_LISTEN_FIRST);
          reject(constants_1.MESSAGES.CALL_LISTEN_FIRST);
          return;
        }
        const address = this.httpServer.address();
        resolve2(this.formatAddress(address));
      });
    }
    formatAddress(address) {
      if ((0, shared_utils_1.isString)(address)) {
        if ((0, os_1.platform)() === "win32") {
          return address;
        }
        const basePath = encodeURIComponent(address);
        return `${this.getProtocol()}+unix://${basePath}`;
      }
      let host = this.host();
      if (address && address.family === "IPv6") {
        if (host === "::") {
          host = "[::1]";
        } else {
          host = `[${host}]`;
        }
      } else if (host === "0.0.0.0") {
        host = "127.0.0.1";
      }
      return `${this.getProtocol()}://${host}:${address.port}`;
    }
    setGlobalPrefix(prefix, options) {
      this.config.setGlobalPrefix(prefix);
      if (options) {
        const exclude = (options === null || options === void 0 ? void 0 : options.exclude) ? (0, utils_12.mapToExcludeRoute)(options.exclude) : [];
        this.config.setGlobalPrefixOptions(Object.assign(Object.assign({}, options), { exclude }));
      }
      return this;
    }
    useWebSocketAdapter(adapter) {
      this.config.setIoAdapter(adapter);
      return this;
    }
    useGlobalFilters(...filters) {
      this.config.useGlobalFilters(...filters);
      filters.forEach((item) => this.graphInspector.insertOrphanedEnhancer({
        subtype: "filter",
        ref: item
      }));
      return this;
    }
    useGlobalPipes(...pipes2) {
      this.config.useGlobalPipes(...pipes2);
      pipes2.forEach((item) => this.graphInspector.insertOrphanedEnhancer({
        subtype: "pipe",
        ref: item
      }));
      return this;
    }
    useGlobalInterceptors(...interceptors2) {
      this.config.useGlobalInterceptors(...interceptors2);
      interceptors2.forEach((item) => this.graphInspector.insertOrphanedEnhancer({
        subtype: "interceptor",
        ref: item
      }));
      return this;
    }
    useGlobalGuards(...guards2) {
      this.config.useGlobalGuards(...guards2);
      guards2.forEach((item) => this.graphInspector.insertOrphanedEnhancer({
        subtype: "guard",
        ref: item
      }));
      return this;
    }
    useStaticAssets(pathOrOptions, options) {
      this.httpAdapter.useStaticAssets && this.httpAdapter.useStaticAssets(pathOrOptions, options);
      return this;
    }
    setBaseViewsDir(path2) {
      this.httpAdapter.setBaseViewsDir && this.httpAdapter.setBaseViewsDir(path2);
      return this;
    }
    setViewEngine(engineOrOptions) {
      this.httpAdapter.setViewEngine && this.httpAdapter.setViewEngine(engineOrOptions);
      return this;
    }
    host() {
      const address = this.httpServer.address();
      if ((0, shared_utils_1.isString)(address)) {
        return void 0;
      }
      return address && address.address;
    }
    getProtocol() {
      return this.appOptions && this.appOptions.httpsOptions ? "https" : "http";
    }
    async registerMiddleware(instance) {
      await this.middlewareModule.registerMiddleware(this.middlewareContainer, instance);
    }
  }
  nestApplication.NestApplication = NestApplication;
  return nestApplication;
}
var nestFactory = {};
var exceptionsZone = {};
var exceptionHandler = {};
var hasRequiredExceptionHandler;
function requireExceptionHandler() {
  if (hasRequiredExceptionHandler)
    return exceptionHandler;
  hasRequiredExceptionHandler = 1;
  Object.defineProperty(exceptionHandler, "__esModule", { value: true });
  exceptionHandler.ExceptionHandler = void 0;
  const runtime_exception_1 = requireRuntime_exception();
  const logger_service_1 = requireLogger_service();
  class ExceptionHandler {
    handle(exception) {
      if (!(exception instanceof runtime_exception_1.RuntimeException)) {
        ExceptionHandler.logger.error(exception.message, exception.stack);
        return;
      }
      ExceptionHandler.logger.error(exception.what(), exception.stack);
    }
  }
  ExceptionHandler.logger = new logger_service_1.Logger(ExceptionHandler.name);
  exceptionHandler.ExceptionHandler = ExceptionHandler;
  return exceptionHandler;
}
var hasRequiredExceptionsZone;
function requireExceptionsZone() {
  if (hasRequiredExceptionsZone)
    return exceptionsZone;
  hasRequiredExceptionsZone = 1;
  Object.defineProperty(exceptionsZone, "__esModule", { value: true });
  exceptionsZone.ExceptionsZone = void 0;
  const common_1 = requireCommon$3();
  const exception_handler_1 = requireExceptionHandler();
  const DEFAULT_TEARDOWN = () => process.exit(1);
  class ExceptionsZone {
    static run(callback, teardown = DEFAULT_TEARDOWN, autoFlushLogs) {
      try {
        callback();
      } catch (e) {
        this.exceptionHandler.handle(e);
        if (autoFlushLogs) {
          common_1.Logger.flush();
        }
        teardown(e);
      }
    }
    static async asyncRun(callback, teardown = DEFAULT_TEARDOWN, autoFlushLogs) {
      try {
        await callback();
      } catch (e) {
        this.exceptionHandler.handle(e);
        if (autoFlushLogs) {
          common_1.Logger.flush();
        }
        teardown(e);
      }
    }
  }
  ExceptionsZone.exceptionHandler = new exception_handler_1.ExceptionHandler();
  exceptionsZone.ExceptionsZone = ExceptionsZone;
  return exceptionsZone;
}
var loadAdapter = {};
var hasRequiredLoadAdapter;
function requireLoadAdapter() {
  if (hasRequiredLoadAdapter)
    return loadAdapter;
  hasRequiredLoadAdapter = 1;
  Object.defineProperty(loadAdapter, "__esModule", { value: true });
  loadAdapter.loadAdapter = void 0;
  const common_1 = requireCommon$3();
  const MISSING_REQUIRED_DEPENDENCY = (defaultPlatform, transport) => `No driver (${transport}) has been selected. In order to take advantage of the default driver, please, ensure to install the "${defaultPlatform}" package ($ npm install ${defaultPlatform}).`;
  const logger = new common_1.Logger("PackageLoader");
  function loadAdapter$1(defaultPlatform, transport, loaderFn) {
    try {
      return loaderFn ? loaderFn() : commonjsRequire(defaultPlatform);
    } catch (e) {
      logger.error(MISSING_REQUIRED_DEPENDENCY(defaultPlatform, transport));
      process.exit(1);
    }
  }
  loadAdapter.loadAdapter = loadAdapter$1;
  return loadAdapter;
}
var rethrow = {};
var hasRequiredRethrow;
function requireRethrow() {
  if (hasRequiredRethrow)
    return rethrow;
  hasRequiredRethrow = 1;
  Object.defineProperty(rethrow, "__esModule", { value: true });
  rethrow.rethrow = void 0;
  const rethrow$1 = (err) => {
    throw err;
  };
  rethrow.rethrow = rethrow$1;
  return rethrow;
}
var instanceLoader = {};
var hasRequiredInstanceLoader;
function requireInstanceLoader() {
  if (hasRequiredInstanceLoader)
    return instanceLoader;
  hasRequiredInstanceLoader = 1;
  Object.defineProperty(instanceLoader, "__esModule", { value: true });
  instanceLoader.InstanceLoader = void 0;
  const common_1 = requireCommon$3();
  const messages_1 = requireMessages();
  const internal_core_module_1 = requireInternalCoreModule();
  class InstanceLoader {
    constructor(container2, injector2, graphInspector2, logger = new common_1.Logger(InstanceLoader.name, {
      timestamp: true
    })) {
      this.container = container2;
      this.injector = injector2;
      this.graphInspector = graphInspector2;
      this.logger = logger;
    }
    setLogger(logger) {
      this.logger = logger;
    }
    async createInstancesOfDependencies(modules2 = this.container.getModules()) {
      this.createPrototypes(modules2);
      try {
        await this.createInstances(modules2);
      } catch (err) {
        this.graphInspector.inspectModules(modules2);
        this.graphInspector.registerPartial(err);
        throw err;
      }
      this.graphInspector.inspectModules(modules2);
    }
    createPrototypes(modules2) {
      modules2.forEach((moduleRef2) => {
        this.createPrototypesOfProviders(moduleRef2);
        this.createPrototypesOfInjectables(moduleRef2);
        this.createPrototypesOfControllers(moduleRef2);
      });
    }
    async createInstances(modules2) {
      await Promise.all([...modules2.values()].map(async (moduleRef2) => {
        await this.createInstancesOfProviders(moduleRef2);
        await this.createInstancesOfInjectables(moduleRef2);
        await this.createInstancesOfControllers(moduleRef2);
        const { name } = moduleRef2;
        this.isModuleWhitelisted(name) && this.logger.log((0, messages_1.MODULE_INIT_MESSAGE)`${name}`);
      }));
    }
    createPrototypesOfProviders(moduleRef2) {
      const { providers } = moduleRef2;
      providers.forEach((wrapper) => this.injector.loadPrototype(wrapper, providers));
    }
    async createInstancesOfProviders(moduleRef2) {
      const { providers } = moduleRef2;
      const wrappers = [...providers.values()];
      await Promise.all(wrappers.map(async (item) => {
        await this.injector.loadProvider(item, moduleRef2);
        this.graphInspector.inspectInstanceWrapper(item, moduleRef2);
      }));
    }
    createPrototypesOfControllers(moduleRef2) {
      const { controllers } = moduleRef2;
      controllers.forEach((wrapper) => this.injector.loadPrototype(wrapper, controllers));
    }
    async createInstancesOfControllers(moduleRef2) {
      const { controllers } = moduleRef2;
      const wrappers = [...controllers.values()];
      await Promise.all(wrappers.map(async (item) => {
        await this.injector.loadController(item, moduleRef2);
        this.graphInspector.inspectInstanceWrapper(item, moduleRef2);
      }));
    }
    createPrototypesOfInjectables(moduleRef2) {
      const { injectables } = moduleRef2;
      injectables.forEach((wrapper) => this.injector.loadPrototype(wrapper, injectables));
    }
    async createInstancesOfInjectables(moduleRef2) {
      const { injectables } = moduleRef2;
      const wrappers = [...injectables.values()];
      await Promise.all(wrappers.map(async (item) => {
        await this.injector.loadInjectable(item, moduleRef2);
        this.graphInspector.inspectInstanceWrapper(item, moduleRef2);
      }));
    }
    isModuleWhitelisted(name) {
      return name !== internal_core_module_1.InternalCoreModule.name;
    }
  }
  instanceLoader.InstanceLoader = InstanceLoader;
  return instanceLoader;
}
var noopGraphInspector = {};
var hasRequiredNoopGraphInspector;
function requireNoopGraphInspector() {
  if (hasRequiredNoopGraphInspector)
    return noopGraphInspector;
  hasRequiredNoopGraphInspector = 1;
  Object.defineProperty(noopGraphInspector, "__esModule", { value: true });
  noopGraphInspector.NoopGraphInspector = void 0;
  const graph_inspector_1 = requireGraphInspector();
  const noop2 = () => {
  };
  noopGraphInspector.NoopGraphInspector = new Proxy(graph_inspector_1.GraphInspector.prototype, {
    get: () => noop2
  });
  return noopGraphInspector;
}
var scanner = {};
var invalidClassModule_exception = {};
var hasRequiredInvalidClassModule_exception;
function requireInvalidClassModule_exception() {
  if (hasRequiredInvalidClassModule_exception)
    return invalidClassModule_exception;
  hasRequiredInvalidClassModule_exception = 1;
  Object.defineProperty(invalidClassModule_exception, "__esModule", { value: true });
  invalidClassModule_exception.InvalidClassModuleException = void 0;
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class InvalidClassModuleException extends runtime_exception_1.RuntimeException {
    constructor(metatypeUsedAsAModule, scope2) {
      super((0, messages_1.USING_INVALID_CLASS_AS_A_MODULE_MESSAGE)(metatypeUsedAsAModule, scope2));
    }
  }
  invalidClassModule_exception.InvalidClassModuleException = InvalidClassModuleException;
  return invalidClassModule_exception;
}
var invalidModule_exception = {};
var hasRequiredInvalidModule_exception;
function requireInvalidModule_exception() {
  if (hasRequiredInvalidModule_exception)
    return invalidModule_exception;
  hasRequiredInvalidModule_exception = 1;
  Object.defineProperty(invalidModule_exception, "__esModule", { value: true });
  invalidModule_exception.InvalidModuleException = void 0;
  const messages_1 = requireMessages$1();
  const runtime_exception_1 = requireRuntime_exception();
  class InvalidModuleException extends runtime_exception_1.RuntimeException {
    constructor(parentModule, index, scope2) {
      super((0, messages_1.INVALID_MODULE_MESSAGE)(parentModule, index, scope2));
    }
  }
  invalidModule_exception.InvalidModuleException = InvalidModuleException;
  return invalidModule_exception;
}
var undefinedModule_exception = {};
var hasRequiredUndefinedModule_exception;
function requireUndefinedModule_exception() {
  if (hasRequiredUndefinedModule_exception)
    return undefinedModule_exception;
  hasRequiredUndefinedModule_exception = 1;
  Object.defineProperty(undefinedModule_exception, "__esModule", { value: true });
  undefinedModule_exception.UndefinedModuleException = void 0;
  const runtime_exception_1 = requireRuntime_exception();
  const messages_1 = requireMessages$1();
  class UndefinedModuleException extends runtime_exception_1.RuntimeException {
    constructor(parentModule, index, scope2) {
      super((0, messages_1.UNDEFINED_MODULE_MESSAGE)(parentModule, index, scope2));
    }
  }
  undefinedModule_exception.UndefinedModuleException = UndefinedModuleException;
  return undefinedModule_exception;
}
var internalCoreModuleFactory = {};
var hasRequiredInternalCoreModuleFactory;
function requireInternalCoreModuleFactory() {
  if (hasRequiredInternalCoreModuleFactory)
    return internalCoreModuleFactory;
  hasRequiredInternalCoreModuleFactory = 1;
  Object.defineProperty(internalCoreModuleFactory, "__esModule", { value: true });
  internalCoreModuleFactory.InternalCoreModuleFactory = void 0;
  const common_1 = requireCommon$3();
  const external_context_creator_1 = requireExternalContextCreator();
  const http_adapter_host_1 = requireHttpAdapterHost();
  const serialized_graph_1 = requireSerializedGraph();
  const injector_1 = requireInjector$1();
  const instance_loader_1 = requireInstanceLoader();
  const lazy_module_loader_1 = requireLazyModuleLoader();
  const modules_container_1 = requireModulesContainer();
  const internal_core_module_1 = requireInternalCoreModule();
  class InternalCoreModuleFactory {
    static create(container2, scanner2, moduleCompiler, httpAdapterHost2, graphInspector2) {
      const lazyModuleLoaderFactory = () => {
        const logger = new common_1.Logger(lazy_module_loader_1.LazyModuleLoader.name, {
          timestamp: false
        });
        const injector2 = new injector_1.Injector();
        const instanceLoader2 = new instance_loader_1.InstanceLoader(container2, injector2, graphInspector2, logger);
        return new lazy_module_loader_1.LazyModuleLoader(scanner2, instanceLoader2, moduleCompiler, container2.getModules());
      };
      return internal_core_module_1.InternalCoreModule.register([
        {
          provide: external_context_creator_1.ExternalContextCreator,
          useValue: external_context_creator_1.ExternalContextCreator.fromContainer(container2)
        },
        {
          provide: modules_container_1.ModulesContainer,
          useValue: container2.getModules()
        },
        {
          provide: http_adapter_host_1.HttpAdapterHost,
          useValue: httpAdapterHost2
        },
        {
          provide: http_adapter_host_1.HttpAdapterHost.name,
          useExisting: http_adapter_host_1.HttpAdapterHost
        },
        {
          provide: lazy_module_loader_1.LazyModuleLoader,
          useFactory: lazyModuleLoaderFactory
        },
        {
          provide: serialized_graph_1.SerializedGraph,
          useValue: container2.serializedGraph
        }
      ]);
    }
  }
  internalCoreModuleFactory.InternalCoreModuleFactory = InternalCoreModuleFactory;
  return internalCoreModuleFactory;
}
var hasRequiredScanner;
function requireScanner() {
  if (hasRequiredScanner)
    return scanner;
  hasRequiredScanner = 1;
  Object.defineProperty(scanner, "__esModule", { value: true });
  scanner.DependenciesScanner = void 0;
  const constants_1 = requireConstants$4();
  const interfaces_1 = requireInterfaces$3();
  const shared_utils_1 = requireShared_utils();
  const iterare_1 = requireLib$4();
  const application_config_1 = requireApplicationConfig();
  const constants_2 = requireConstants$5();
  const circular_dependency_exception_1 = requireCircularDependency_exception();
  const invalid_class_module_exception_1 = requireInvalidClassModule_exception();
  const invalid_module_exception_1 = requireInvalidModule_exception();
  const undefined_module_exception_1 = requireUndefinedModule_exception();
  const get_class_scope_1 = requireGetClassScope();
  const internal_core_module_factory_1 = requireInternalCoreModuleFactory();
  const uuid_factory_1 = requireUuidFactory();
  class DependenciesScanner {
    constructor(container2, metadataScanner2, graphInspector2, applicationConfig2 = new application_config_1.ApplicationConfig()) {
      this.container = container2;
      this.metadataScanner = metadataScanner2;
      this.graphInspector = graphInspector2;
      this.applicationConfig = applicationConfig2;
      this.applicationProvidersApplyMap = [];
    }
    async scan(module2) {
      await this.registerCoreModule();
      await this.scanForModules(module2);
      await this.scanModulesForDependencies();
      this.calculateModulesDistance();
      this.addScopedEnhancersMetadata();
      this.container.bindGlobalScope();
    }
    async scanForModules(moduleDefinition, scope2 = [], ctxRegistry = []) {
      const moduleInstance = await this.insertModule(moduleDefinition, scope2);
      moduleDefinition = moduleDefinition instanceof Promise ? await moduleDefinition : moduleDefinition;
      ctxRegistry.push(moduleDefinition);
      if (this.isForwardReference(moduleDefinition)) {
        moduleDefinition = moduleDefinition.forwardRef();
      }
      const modules2 = !this.isDynamicModule(moduleDefinition) ? this.reflectMetadata(constants_1.MODULE_METADATA.IMPORTS, moduleDefinition) : [
        ...this.reflectMetadata(constants_1.MODULE_METADATA.IMPORTS, moduleDefinition.module),
        ...moduleDefinition.imports || []
      ];
      let registeredModuleRefs = [];
      for (const [index, innerModule] of modules2.entries()) {
        if (innerModule === void 0) {
          throw new undefined_module_exception_1.UndefinedModuleException(moduleDefinition, index, scope2);
        }
        if (!innerModule) {
          throw new invalid_module_exception_1.InvalidModuleException(moduleDefinition, index, scope2);
        }
        if (ctxRegistry.includes(innerModule)) {
          continue;
        }
        const moduleRefs = await this.scanForModules(innerModule, [].concat(scope2, moduleDefinition), ctxRegistry);
        registeredModuleRefs = registeredModuleRefs.concat(moduleRefs);
      }
      if (!moduleInstance) {
        return registeredModuleRefs;
      }
      return [moduleInstance].concat(registeredModuleRefs);
    }
    async insertModule(moduleDefinition, scope2) {
      const moduleToAdd = this.isForwardReference(moduleDefinition) ? moduleDefinition.forwardRef() : moduleDefinition;
      if (this.isInjectable(moduleToAdd) || this.isController(moduleToAdd) || this.isExceptionFilter(moduleToAdd)) {
        throw new invalid_class_module_exception_1.InvalidClassModuleException(moduleDefinition, scope2);
      }
      return this.container.addModule(moduleToAdd, scope2);
    }
    async scanModulesForDependencies(modules2 = this.container.getModules()) {
      for (const [token, { metatype }] of modules2) {
        await this.reflectImports(metatype, token, metatype.name);
        this.reflectProviders(metatype, token);
        this.reflectControllers(metatype, token);
        this.reflectExports(metatype, token);
      }
    }
    async reflectImports(module2, token, context) {
      const modules2 = [
        ...this.reflectMetadata(constants_1.MODULE_METADATA.IMPORTS, module2),
        ...this.container.getDynamicMetadataByToken(token, constants_1.MODULE_METADATA.IMPORTS)
      ];
      for (const related of modules2) {
        await this.insertImport(related, token, context);
      }
    }
    reflectProviders(module2, token) {
      const providers = [
        ...this.reflectMetadata(constants_1.MODULE_METADATA.PROVIDERS, module2),
        ...this.container.getDynamicMetadataByToken(token, constants_1.MODULE_METADATA.PROVIDERS)
      ];
      providers.forEach((provider) => {
        this.insertProvider(provider, token);
        this.reflectDynamicMetadata(provider, token);
      });
    }
    reflectControllers(module2, token) {
      const controllers = [
        ...this.reflectMetadata(constants_1.MODULE_METADATA.CONTROLLERS, module2),
        ...this.container.getDynamicMetadataByToken(token, constants_1.MODULE_METADATA.CONTROLLERS)
      ];
      controllers.forEach((item) => {
        this.insertController(item, token);
        this.reflectDynamicMetadata(item, token);
      });
    }
    reflectDynamicMetadata(cls, token) {
      if (!cls || !cls.prototype) {
        return;
      }
      this.reflectInjectables(cls, token, constants_1.GUARDS_METADATA);
      this.reflectInjectables(cls, token, constants_1.INTERCEPTORS_METADATA);
      this.reflectInjectables(cls, token, constants_1.EXCEPTION_FILTERS_METADATA);
      this.reflectInjectables(cls, token, constants_1.PIPES_METADATA);
      this.reflectParamInjectables(cls, token, constants_1.ROUTE_ARGS_METADATA);
    }
    reflectExports(module2, token) {
      const exports2 = [
        ...this.reflectMetadata(constants_1.MODULE_METADATA.EXPORTS, module2),
        ...this.container.getDynamicMetadataByToken(token, constants_1.MODULE_METADATA.EXPORTS)
      ];
      exports2.forEach((exportedProvider) => this.insertExportedProvider(exportedProvider, token));
    }
    reflectInjectables(component, token, metadataKey) {
      const controllerInjectables = this.reflectMetadata(metadataKey, component);
      const methodInjectables = this.metadataScanner.getAllMethodNames(component.prototype).reduce((acc, method) => {
        const methodInjectable = this.reflectKeyMetadata(component, metadataKey, method);
        if (methodInjectable) {
          acc.push(methodInjectable);
        }
        return acc;
      }, []);
      controllerInjectables.forEach((injectable) => this.insertInjectable(injectable, token, component, constants_1.ENHANCER_KEY_TO_SUBTYPE_MAP[metadataKey]));
      methodInjectables.forEach((methodInjectable) => {
        methodInjectable.metadata.forEach((injectable) => this.insertInjectable(injectable, token, component, constants_1.ENHANCER_KEY_TO_SUBTYPE_MAP[metadataKey], methodInjectable.methodKey));
      });
    }
    reflectParamInjectables(component, token, metadataKey) {
      const paramsMethods = this.metadataScanner.getAllMethodNames(component.prototype);
      paramsMethods.forEach((methodKey) => {
        const metadata2 = Reflect.getMetadata(metadataKey, component, methodKey);
        if (!metadata2) {
          return;
        }
        const params = Object.values(metadata2);
        params.map((item) => item.pipes).flat(1).forEach((injectable) => this.insertInjectable(injectable, token, component, "pipe", methodKey));
      });
    }
    reflectKeyMetadata(component, key, methodKey) {
      let prototype2 = component.prototype;
      do {
        const descriptor = Reflect.getOwnPropertyDescriptor(prototype2, methodKey);
        if (!descriptor) {
          continue;
        }
        const metadata2 = Reflect.getMetadata(key, descriptor.value);
        if (!metadata2) {
          return;
        }
        return { methodKey, metadata: metadata2 };
      } while ((prototype2 = Reflect.getPrototypeOf(prototype2)) && prototype2 !== Object.prototype && prototype2);
      return void 0;
    }
    calculateModulesDistance() {
      const modulesGenerator = this.container.getModules().values();
      modulesGenerator.next();
      const modulesStack = [];
      const calculateDistance = (moduleRef2, distance = 1) => {
        if (!moduleRef2 || modulesStack.includes(moduleRef2)) {
          return;
        }
        modulesStack.push(moduleRef2);
        const moduleImports = moduleRef2.imports;
        moduleImports.forEach((importedModuleRef) => {
          if (importedModuleRef) {
            if (distance > importedModuleRef.distance) {
              importedModuleRef.distance = distance;
            }
            calculateDistance(importedModuleRef, distance + 1);
          }
        });
      };
      const rootModule = modulesGenerator.next().value;
      calculateDistance(rootModule);
    }
    async insertImport(related, token, context) {
      if ((0, shared_utils_1.isUndefined)(related)) {
        throw new circular_dependency_exception_1.CircularDependencyException(context);
      }
      if (this.isForwardReference(related)) {
        return this.container.addImport(related.forwardRef(), token);
      }
      await this.container.addImport(related, token);
    }
    isCustomProvider(provider) {
      return provider && !(0, shared_utils_1.isNil)(provider.provide);
    }
    insertProvider(provider, token) {
      const isCustomProvider = this.isCustomProvider(provider);
      if (!isCustomProvider) {
        return this.container.addProvider(provider, token);
      }
      const applyProvidersMap = this.getApplyProvidersMap();
      const providersKeys = Object.keys(applyProvidersMap);
      const type2 = provider.provide;
      if (!providersKeys.includes(type2)) {
        return this.container.addProvider(provider, token);
      }
      const uuid = uuid_factory_1.UuidFactory.get(type2.toString());
      const providerToken = `${type2} (UUID: ${uuid})`;
      let scope2 = provider.scope;
      if ((0, shared_utils_1.isNil)(scope2) && provider.useClass) {
        scope2 = (0, get_class_scope_1.getClassScope)(provider.useClass);
      }
      this.applicationProvidersApplyMap.push({
        type: type2,
        moduleKey: token,
        providerKey: providerToken,
        scope: scope2
      });
      const newProvider = Object.assign(Object.assign({}, provider), { provide: providerToken, scope: scope2 });
      const enhancerSubtype = constants_2.ENHANCER_TOKEN_TO_SUBTYPE_MAP[type2];
      const factoryOrClassProvider = newProvider;
      if (this.isRequestOrTransient(factoryOrClassProvider.scope)) {
        return this.container.addInjectable(newProvider, token, enhancerSubtype);
      }
      this.container.addProvider(newProvider, token, enhancerSubtype);
    }
    insertInjectable(injectable, token, host, subtype, methodKey) {
      if ((0, shared_utils_1.isFunction)(injectable)) {
        const instanceWrapper2 = this.container.addInjectable(injectable, token, subtype, host);
        this.graphInspector.insertEnhancerMetadataCache({
          moduleToken: token,
          classRef: host,
          enhancerInstanceWrapper: instanceWrapper2,
          targetNodeId: instanceWrapper2.id,
          subtype,
          methodKey
        });
        return instanceWrapper2;
      } else {
        this.graphInspector.insertEnhancerMetadataCache({
          moduleToken: token,
          classRef: host,
          enhancerRef: injectable,
          methodKey,
          subtype
        });
      }
    }
    insertExportedProvider(exportedProvider, token) {
      this.container.addExportedProvider(exportedProvider, token);
    }
    insertController(controller, token) {
      this.container.addController(controller, token);
    }
    reflectMetadata(metadataKey, metatype) {
      return Reflect.getMetadata(metadataKey, metatype) || [];
    }
    async registerCoreModule() {
      const moduleDefinition = internal_core_module_factory_1.InternalCoreModuleFactory.create(this.container, this, this.container.getModuleCompiler(), this.container.getHttpAdapterHostRef(), this.graphInspector);
      const [instance] = await this.scanForModules(moduleDefinition);
      this.container.registerCoreModuleRef(instance);
    }
    /**
     * Add either request or transient globally scoped enhancers
     * to all controllers metadata storage
     */
    addScopedEnhancersMetadata() {
      (0, iterare_1.iterate)(this.applicationProvidersApplyMap).filter((wrapper) => this.isRequestOrTransient(wrapper.scope)).forEach(({ moduleKey, providerKey }) => {
        const modulesContainer2 = this.container.getModules();
        const { injectables } = modulesContainer2.get(moduleKey);
        const instanceWrapper2 = injectables.get(providerKey);
        const iterableIterator = modulesContainer2.values();
        (0, iterare_1.iterate)(iterableIterator).map((moduleRef2) => Array.from(moduleRef2.controllers.values()).concat(moduleRef2.entryProviders)).flatten().forEach((controllerOrEntryProvider) => controllerOrEntryProvider.addEnhancerMetadata(instanceWrapper2));
      });
    }
    applyApplicationProviders() {
      const applyProvidersMap = this.getApplyProvidersMap();
      const applyRequestProvidersMap = this.getApplyRequestProvidersMap();
      const getInstanceWrapper = (moduleKey, providerKey, collectionKey) => {
        const modules2 = this.container.getModules();
        const collection = modules2.get(moduleKey)[collectionKey];
        return collection.get(providerKey);
      };
      this.applicationProvidersApplyMap.forEach(({ moduleKey, providerKey, type: type2, scope: scope2 }) => {
        let instanceWrapper2;
        if (this.isRequestOrTransient(scope2)) {
          instanceWrapper2 = getInstanceWrapper(moduleKey, providerKey, "injectables");
          this.graphInspector.insertAttachedEnhancer(instanceWrapper2);
          return applyRequestProvidersMap[type2](instanceWrapper2);
        }
        instanceWrapper2 = getInstanceWrapper(moduleKey, providerKey, "providers");
        this.graphInspector.insertAttachedEnhancer(instanceWrapper2);
        applyProvidersMap[type2](instanceWrapper2.instance);
      });
    }
    getApplyProvidersMap() {
      return {
        [constants_2.APP_INTERCEPTOR]: (interceptor) => this.applicationConfig.addGlobalInterceptor(interceptor),
        [constants_2.APP_PIPE]: (pipe2) => this.applicationConfig.addGlobalPipe(pipe2),
        [constants_2.APP_GUARD]: (guard) => this.applicationConfig.addGlobalGuard(guard),
        [constants_2.APP_FILTER]: (filter3) => this.applicationConfig.addGlobalFilter(filter3)
      };
    }
    getApplyRequestProvidersMap() {
      return {
        [constants_2.APP_INTERCEPTOR]: (interceptor) => this.applicationConfig.addGlobalRequestInterceptor(interceptor),
        [constants_2.APP_PIPE]: (pipe2) => this.applicationConfig.addGlobalRequestPipe(pipe2),
        [constants_2.APP_GUARD]: (guard) => this.applicationConfig.addGlobalRequestGuard(guard),
        [constants_2.APP_FILTER]: (filter3) => this.applicationConfig.addGlobalRequestFilter(filter3)
      };
    }
    isDynamicModule(module2) {
      return module2 && !!module2.module;
    }
    /**
     * @param metatype
     * @returns `true` if `metatype` is annotated with the `@Injectable()` decorator.
     */
    isInjectable(metatype) {
      return !!Reflect.getMetadata(constants_1.INJECTABLE_WATERMARK, metatype);
    }
    /**
     * @param metatype
     * @returns `true` if `metatype` is annotated with the `@Controller()` decorator.
     */
    isController(metatype) {
      return !!Reflect.getMetadata(constants_1.CONTROLLER_WATERMARK, metatype);
    }
    /**
     * @param metatype
     * @returns `true` if `metatype` is annotated with the `@Catch()` decorator.
     */
    isExceptionFilter(metatype) {
      return !!Reflect.getMetadata(constants_1.CATCH_WATERMARK, metatype);
    }
    isForwardReference(module2) {
      return module2 && !!module2.forwardRef;
    }
    isRequestOrTransient(scope2) {
      return scope2 === interfaces_1.Scope.REQUEST || scope2 === interfaces_1.Scope.TRANSIENT;
    }
  }
  scanner.DependenciesScanner = DependenciesScanner;
  return scanner;
}
var platformExpress = {};
var adapters$1 = {};
var expressAdapter = {};
var bodyParser$1 = { exports: {} };
/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */
var depd_1;
var hasRequiredDepd;
function requireDepd() {
  if (hasRequiredDepd)
    return depd_1;
  hasRequiredDepd = 1;
  var relative = require$$0$6.relative;
  depd_1 = depd;
  var basePath = process.cwd();
  function containsNamespace(str, namespace) {
    var vals = str.split(/[ ,]+/);
    var ns = String(namespace).toLowerCase();
    for (var i = 0; i < vals.length; i++) {
      var val = vals[i];
      if (val && (val === "*" || val.toLowerCase() === ns)) {
        return true;
      }
    }
    return false;
  }
  function convertDataDescriptorToAccessor(obj, prop, message) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    var value = descriptor.value;
    descriptor.get = function getter() {
      return value;
    };
    if (descriptor.writable) {
      descriptor.set = function setter(val) {
        return value = val;
      };
    }
    delete descriptor.value;
    delete descriptor.writable;
    Object.defineProperty(obj, prop, descriptor);
    return descriptor;
  }
  function createArgumentsString(arity) {
    var str = "";
    for (var i = 0; i < arity; i++) {
      str += ", arg" + i;
    }
    return str.substr(2);
  }
  function createStackString(stack) {
    var str = this.name + ": " + this.namespace;
    if (this.message) {
      str += " deprecated " + this.message;
    }
    for (var i = 0; i < stack.length; i++) {
      str += "\n    at " + stack[i].toString();
    }
    return str;
  }
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError("argument namespace is required");
    }
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    var file2 = site[0];
    function deprecate(message) {
      log.call(deprecate, message);
    }
    deprecate._file = file2;
    deprecate._ignored = isignored(namespace);
    deprecate._namespace = namespace;
    deprecate._traced = istraced(namespace);
    deprecate._warned = /* @__PURE__ */ Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }
  function eehaslisteners(emitter, type2) {
    var count2 = typeof emitter.listenerCount !== "function" ? emitter.listeners(type2).length : emitter.listenerCount(type2);
    return count2 > 0;
  }
  function isignored(namespace) {
    if (process.noDeprecation) {
      return true;
    }
    var str = process.env.NO_DEPRECATION || "";
    return containsNamespace(str, namespace);
  }
  function istraced(namespace) {
    if (process.traceDeprecation) {
      return true;
    }
    var str = process.env.TRACE_DEPRECATION || "";
    return containsNamespace(str, namespace);
  }
  function log(message, site) {
    var haslisteners = eehaslisteners(process, "deprecation");
    if (!haslisteners && this._ignored) {
      return;
    }
    var caller;
    var callFile;
    var callSite;
    var depSite;
    var i = 0;
    var seen = false;
    var stack = getStack();
    var file2 = this._file;
    if (site) {
      depSite = site;
      callSite = callSiteLocation(stack[1]);
      callSite.name = depSite.name;
      file2 = callSite[0];
    } else {
      i = 2;
      depSite = callSiteLocation(stack[i]);
      callSite = depSite;
    }
    for (; i < stack.length; i++) {
      caller = callSiteLocation(stack[i]);
      callFile = caller[0];
      if (callFile === file2) {
        seen = true;
      } else if (callFile === this._file) {
        file2 = this._file;
      } else if (seen) {
        break;
      }
    }
    var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
    if (key !== void 0 && key in this._warned) {
      return;
    }
    this._warned[key] = true;
    var msg = message;
    if (!msg) {
      msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
    }
    if (haslisteners) {
      var err = DeprecationError(this._namespace, msg, stack.slice(i));
      process.emit("deprecation", err);
      return;
    }
    var format2 = process.stderr.isTTY ? formatColor : formatPlain;
    var output = format2.call(this, msg, caller, stack.slice(i));
    process.stderr.write(output + "\n", "utf8");
  }
  function callSiteLocation(callSite) {
    var file2 = callSite.getFileName() || "<anonymous>";
    var line = callSite.getLineNumber();
    var colm = callSite.getColumnNumber();
    if (callSite.isEval()) {
      file2 = callSite.getEvalOrigin() + ", " + file2;
    }
    var site = [file2, line, colm];
    site.callSite = callSite;
    site.name = callSite.getFunctionName();
    return site;
  }
  function defaultMessage(site) {
    var callSite = site.callSite;
    var funcName = site.name;
    if (!funcName) {
      funcName = "<anonymous@" + formatLocation(site) + ">";
    }
    var context = callSite.getThis();
    var typeName = context && callSite.getTypeName();
    if (typeName === "Object") {
      typeName = void 0;
    }
    if (typeName === "Function") {
      typeName = context.name || typeName;
    }
    return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
  }
  function formatPlain(msg, caller, stack) {
    var timestamp2 = (/* @__PURE__ */ new Date()).toUTCString();
    var formatted = timestamp2 + " " + this._namespace + " deprecated " + msg;
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += "\n    at " + stack[i].toString();
      }
      return formatted;
    }
    if (caller) {
      formatted += " at " + formatLocation(caller);
    }
    return formatted;
  }
  function formatColor(msg, caller, stack) {
    var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += "\n    \x1B[36mat " + stack[i].toString() + "\x1B[39m";
      }
      return formatted;
    }
    if (caller) {
      formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
    }
    return formatted;
  }
  function formatLocation(callSite) {
    return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
  }
  function getStack() {
    var limit2 = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = Math.max(10, limit2);
    Error.captureStackTrace(obj);
    var stack = obj.stack.slice(1);
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit2;
    return stack;
  }
  function prepareObjectStackTrace(obj, stack) {
    return stack;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    var args2 = createArgumentsString(fn.length);
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = fn.name;
    var deprecatedfn = new Function(
      "fn",
      "log",
      "deprecate",
      "message",
      "site",
      '"use strict"\nreturn function (' + args2 + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}"
    )(fn, log, this, message, site);
    return deprecatedfn;
  }
  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("argument obj must be object");
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError("must call property on owner object");
    }
    if (!descriptor.configurable) {
      throw new TypeError("property must be configurable");
    }
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = prop;
    if ("value" in descriptor) {
      descriptor = convertDataDescriptorToAccessor(obj, prop);
    }
    var get2 = descriptor.get;
    var set = descriptor.set;
    if (typeof get2 === "function") {
      descriptor.get = function getter() {
        log.call(deprecate, message, site);
        return get2.apply(this, arguments);
      };
    }
    if (typeof set === "function") {
      descriptor.set = function setter() {
        log.call(deprecate, message, site);
        return set.apply(this, arguments);
      };
    }
    Object.defineProperty(obj, prop, descriptor);
  }
  function DeprecationError(namespace, message, stack) {
    var error2 = new Error();
    var stackString;
    Object.defineProperty(error2, "constructor", {
      value: DeprecationError
    });
    Object.defineProperty(error2, "message", {
      configurable: true,
      enumerable: false,
      value: message,
      writable: true
    });
    Object.defineProperty(error2, "name", {
      enumerable: false,
      configurable: true,
      value: "DeprecationError",
      writable: true
    });
    Object.defineProperty(error2, "namespace", {
      configurable: true,
      enumerable: false,
      value: namespace,
      writable: true
    });
    Object.defineProperty(error2, "stack", {
      configurable: true,
      enumerable: false,
      get: function() {
        if (stackString !== void 0) {
          return stackString;
        }
        return stackString = createStackString.call(this, stack);
      },
      set: function setter(val) {
        stackString = val;
      }
    });
    return error2;
  }
  return depd_1;
}
var bytes = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes)
    return bytes.exports;
  hasRequiredBytes = 1;
  bytes.exports = bytes$1;
  bytes.exports.format = format2;
  bytes.exports.parse = parse2;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map2 = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value, options) {
    if (typeof value === "string") {
      return parse2(value);
    }
    if (typeof value === "number") {
      return format2(value, options);
    }
    return null;
  }
  function format2(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map2[unit.toLowerCase()]) {
      if (mag >= map2.pb) {
        unit = "PB";
      } else if (mag >= map2.tb) {
        unit = "TB";
      } else if (mag >= map2.gb) {
        unit = "GB";
      } else if (mag >= map2.mb) {
        unit = "MB";
      } else if (mag >= map2.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map2[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.split(".").map(function(s, i) {
        return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
      }).join(".");
    }
    return str + unitSeparator + unit;
  }
  function parse2(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map2[unit] * floatValue);
  }
  return bytes.exports;
}
var contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentType;
function requireContentType() {
  if (hasRequiredContentType)
    return contentType;
  hasRequiredContentType = 1;
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  contentType.format = format2;
  contentType.parse = parse2;
  function format2(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var type2 = obj.type;
    if (!type2 || !TYPE_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    var string = type2;
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse2(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    var header = typeof string === "object" ? getcontenttype(string) : string;
    if (typeof header !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = header.indexOf(";");
    var type2 = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (!TYPE_REGEXP.test(type2)) {
      throw new TypeError("invalid media type");
    }
    var obj = new ContentType(type2.toLowerCase());
    if (index !== -1) {
      var key;
      var match;
      var value;
      PARAM_REGEXP.lastIndex = index;
      while (match = PARAM_REGEXP.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value.charCodeAt(0) === 34) {
          value = value.slice(1, -1);
          if (value.indexOf("\\") !== -1) {
            value = value.replace(QESC_REGEXP, "$1");
          }
        }
        obj.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
    }
    return obj;
  }
  function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === "function") {
      header = obj.getHeader("content-type");
    } else if (typeof obj.headers === "object") {
      header = obj.headers && obj.headers["content-type"];
    }
    if (typeof header !== "string") {
      throw new TypeError("content-type header is missing from object");
    }
    return header;
  }
  function qstring(val) {
    var str = String(val);
    if (TOKEN_REGEXP.test(str)) {
      return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ContentType(type2) {
    this.parameters = /* @__PURE__ */ Object.create(null);
    this.type = type2;
  }
  return contentType;
}
var httpErrors = { exports: {} };
var setprototypeof;
var hasRequiredSetprototypeof;
function requireSetprototypeof() {
  if (hasRequiredSetprototypeof)
    return setprototypeof;
  hasRequiredSetprototypeof = 1;
  setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
  return setprototypeof;
}
const require$$0$2 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses;
var hasRequiredStatuses;
function requireStatuses() {
  if (hasRequiredStatuses)
    return statuses;
  hasRequiredStatuses = 1;
  var codes = require$$0$2;
  statuses = status;
  status.message = codes;
  status.code = createMessageToStatusCodeMap(codes);
  status.codes = createStatusCodeList(codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function createMessageToStatusCodeMap(codes2) {
    var map2 = {};
    Object.keys(codes2).forEach(function forEachCode(code2) {
      var message = codes2[code2];
      var status2 = Number(code2);
      map2[message.toLowerCase()] = status2;
    });
    return map2;
  }
  function createStatusCodeList(codes2) {
    return Object.keys(codes2).map(function mapCode(code2) {
      return Number(code2);
    });
  }
  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }
  function getStatusMessage(code2) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code2)) {
      throw new Error("invalid status code: " + code2);
    }
    return status.message[code2];
  }
  function status(code2) {
    if (typeof code2 === "number") {
      return getStatusMessage(code2);
    }
    if (typeof code2 !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code2, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code2);
  }
  return statuses;
}
var inherits$1 = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser)
    return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits)
    return inherits$1.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = require("util");
    if (typeof util2.inherits !== "function")
      throw "";
    inherits$1.exports = util2.inherits;
  } catch (e) {
    inherits$1.exports = requireInherits_browser();
  }
  return inherits$1.exports;
}
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier;
var hasRequiredToidentifier;
function requireToidentifier() {
  if (hasRequiredToidentifier)
    return toidentifier;
  hasRequiredToidentifier = 1;
  toidentifier = toIdentifier;
  function toIdentifier(str) {
    return str.split(" ").map(function(token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
  return toidentifier;
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredHttpErrors;
function requireHttpErrors() {
  if (hasRequiredHttpErrors)
    return httpErrors.exports;
  hasRequiredHttpErrors = 1;
  (function(module2) {
    var deprecate = requireDepd()("http-errors");
    var setPrototypeOf = requireSetprototypeof();
    var statuses2 = requireStatuses();
    var inherits2 = requireInherits();
    var toIdentifier = requireToidentifier();
    module2.exports = createError;
    module2.exports.HttpError = createHttpErrorConstructor();
    module2.exports.isHttpError = createIsHttpErrorFunction(module2.exports.HttpError);
    populateConstructorExports(module2.exports, statuses2.codes, module2.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type2 = typeof arg;
        if (type2 === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type2 === "number" && i === 0) {
          status = arg;
        } else if (type2 === "string") {
          msg = arg;
        } else if (type2 === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i + 1) + " unsupported type " + type2);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses2.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits2(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code2) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses2.message[code2];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits2(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code2;
      ClientError.prototype.statusCode = code2;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name, code2) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses2.message[code2];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits2(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code2;
      ServerError.prototype.statusCode = code2;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports2, codes, HttpError) {
      codes.forEach(function forEachCode(code2) {
        var CodeError;
        var name = toIdentifier(statuses2.message[code2]);
        switch (codeClass(code2)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code2);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code2);
            break;
        }
        if (CodeError) {
          exports2[code2] = CodeError;
          exports2[name] = CodeError;
        }
      });
    }
    function toClassName(name) {
      return name.substr(-5) !== "Error" ? name + "Error" : name;
    }
  })(httpErrors);
  return httpErrors.exports;
}
var src$3 = { exports: {} };
var browser$3 = { exports: {} };
var debug$8 = { exports: {} };
var ms$4;
var hasRequiredMs$4;
function requireMs$4() {
  if (hasRequiredMs$4)
    return ms$4;
  hasRequiredMs$4 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  ms$4 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    if (ms2 >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (ms2 >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (ms2 >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (ms2 >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    return plural(ms2, d, "day") || plural(ms2, h, "hour") || plural(ms2, m, "minute") || plural(ms2, s, "second") || ms2 + " ms";
  }
  function plural(ms2, n, name) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name;
    }
    return Math.ceil(ms2 / n) + " " + name + "s";
  }
  return ms$4;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug)
    return debug$8.exports;
  hasRequiredDebug = 1;
  (function(module2, exports2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce2;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = requireMs$4();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled)
          return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args2 = new Array(arguments.length);
        for (var i = 0; i < args2.length; i++) {
          args2[i] = arguments[i];
        }
        args2[0] = exports2.coerce(args2[0]);
        if ("string" !== typeof args2[0]) {
          args2.unshift("%O");
        }
        var index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args2);
        var logFn = debug2.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args2);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports2.enabled(namespace);
      debug2.useColors = exports2.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports2.init) {
        exports2.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$8, debug$8.exports);
  return debug$8.exports;
}
var hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3)
    return browser$3.exports;
  hasRequiredBrowser$3 = 1;
  (function(module2, exports2) {
    exports2 = module2.exports = requireDebug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args2) {
      var useColors2 = this.useColors;
      args2[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args2[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$3, browser$3.exports);
  return browser$3.exports;
}
var node$4 = { exports: {} };
var hasRequiredNode$4;
function requireNode$4() {
  if (hasRequiredNode$4)
    return node$4.exports;
  hasRequiredNode$4 = 1;
  (function(module2, exports2) {
    var tty = require$$0$7;
    var util2 = require$$1$1;
    exports2 = module2.exports = requireDebug();
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream2 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args2) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args2[0];
      }
    }
    function log() {
      return stream2.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream3;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream3 = new tty.WriteStream(fd2);
          stream3._type = "tty";
          if (stream3._handle && stream3._handle.unref) {
            stream3._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$1$3;
          stream3 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream3._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require$$4$1;
          stream3 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream3.readable = false;
          stream3.read = null;
          stream3._type = "pipe";
          if (stream3._handle && stream3._handle.unref) {
            stream3._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream3.fd = fd2;
      stream3._isStdio = true;
      return stream3;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  })(node$4, node$4.exports);
  return node$4.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src$3.exports;
  hasRequiredSrc = 1;
  if (typeof process !== "undefined" && process.type === "renderer") {
    src$3.exports = requireBrowser$3();
  } else {
    src$3.exports = requireNode$4();
  }
  return src$3.exports;
}
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var destroy_1$1;
var hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1)
    return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  var EventEmitter = require$$0$8.EventEmitter;
  var ReadStream = require$$1$3.ReadStream;
  var Stream2 = require$$0$4;
  var Zlib = zlib;
  destroy_1$1 = destroy2;
  function destroy2(stream2, suppress) {
    if (isFsReadStream(stream2)) {
      destroyReadStream(stream2);
    } else if (isZlibStream(stream2)) {
      destroyZlibStream(stream2);
    } else if (hasDestroy(stream2)) {
      stream2.destroy();
    }
    if (isEventEmitter(stream2) && suppress) {
      stream2.removeAllListeners("error");
      stream2.addListener("error", noop2);
    }
    return stream2;
  }
  function destroyReadStream(stream2) {
    stream2.destroy();
    if (typeof stream2.close === "function") {
      stream2.on("open", onOpenClose);
    }
  }
  function closeZlibStream(stream2) {
    if (stream2._hadError === true) {
      var prop = stream2._binding === null ? "_binding" : "_handle";
      stream2[prop] = {
        close: function() {
          this[prop] = null;
        }
      };
    }
    stream2.close();
  }
  function destroyZlibStream(stream2) {
    if (typeof stream2.destroy === "function") {
      if (stream2._binding) {
        stream2.destroy();
        if (stream2._processing) {
          stream2._needDrain = true;
          stream2.once("drain", onDrainClearBinding);
        } else {
          stream2._binding.clear();
        }
      } else if (stream2._destroy && stream2._destroy !== Stream2.Transform.prototype._destroy) {
        stream2.destroy();
      } else if (stream2._destroy && typeof stream2.close === "function") {
        stream2.destroyed = true;
        stream2.close();
      } else {
        stream2.destroy();
      }
    } else if (typeof stream2.close === "function") {
      closeZlibStream(stream2);
    }
  }
  function hasDestroy(stream2) {
    return stream2 instanceof Stream2 && typeof stream2.destroy === "function";
  }
  function isEventEmitter(val) {
    return val instanceof EventEmitter;
  }
  function isFsReadStream(stream2) {
    return stream2 instanceof ReadStream;
  }
  function isZlibStream(stream2) {
    return stream2 instanceof Zlib.Gzip || stream2 instanceof Zlib.Gunzip || stream2 instanceof Zlib.Deflate || stream2 instanceof Zlib.DeflateRaw || stream2 instanceof Zlib.Inflate || stream2 instanceof Zlib.InflateRaw || stream2 instanceof Zlib.Unzip;
  }
  function noop2() {
  }
  function onDrainClearBinding() {
    this._binding.clear();
  }
  function onOpenClose() {
    if (typeof this.fd === "number") {
      this.close();
    }
  }
  return destroy_1$1;
}
var lib$3 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer)
    return safer_1;
  hasRequiredSafer = 1;
  var buffer2 = require$$0$9;
  var Buffer2 = buffer2.Buffer;
  var safer = {};
  var key;
  for (key in buffer2) {
    if (!buffer2.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer2[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding2 === "string") {
        buf.fill(fill, encoding2);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling)
    return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder2, options) {
    this.encoder = encoder2;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder2, options) {
    this.decoder = decoder2;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal)
    return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$4.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16)
    return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding2 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding2 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0; i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0)
            asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0)
            asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7)
    return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec)
    return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0; i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData)
    return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated)
    return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec)
    return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48; j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>= 8)
      bytes2.push(addr & 255);
    if (bytes2.length == 0)
      bytes2.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      var val = node2[bytes2[i2]];
      if (val == UNASSIGNED) {
        node2[bytes2[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code2 = part.charCodeAt(l++);
          if (55296 <= code2 && code2 < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code2 - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code2 && code2 <= 4095) {
            var len = 4095 - code2 + 2;
            var seq = [];
            for (var m = 0; m < len; m++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code2;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED)
        node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0)
        ;
      else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$1 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
];
const require$$2$1 = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
];
const require$$3$2 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ]
];
const uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
];
const require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
];
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData)
    return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$1;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2$1;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3$2);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3$2);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [41676]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings)
    return encodings;
  hasRequiredEncodings = 1;
  (function(exports2) {
    var modules2 = [
      requireInternal(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules2.length; i++) {
      var module2 = modules2[i];
      for (var enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports2[enc] = module2[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams)
    return streams;
  hasRequiredStreams = 1;
  var Buffer2 = require$$0$9.Buffer, Transform = require$$0$4.Transform;
  streams = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding2, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding2, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding2, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding2, options), options);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding2, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding2, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length)
        this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res += chunk;
    });
    this.on("end", function() {
      cb(null, res);
    });
    return this;
  };
  return streams;
}
var extendNode;
var hasRequiredExtendNode;
function requireExtendNode() {
  if (hasRequiredExtendNode)
    return extendNode;
  hasRequiredExtendNode = 1;
  var Buffer2 = require$$0$9.Buffer;
  extendNode = function(iconv) {
    var original = void 0;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original)
        return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        "hex": true,
        "utf8": true,
        "utf-8": true,
        "ascii": true,
        "binary": true,
        "base64": true,
        "ucs2": true,
        "ucs-2": true,
        "utf16le": true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = require$$0$9.SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding2, start, end) {
        encoding2 = String(encoding2 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding2))
          return original.SlowBufferToString.call(this, encoding2, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding2);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string, offset, length, encoding2) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding2 = length;
            length = void 0;
          }
        } else {
          var swap = encoding2;
          encoding2 = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding2 = String(encoding2 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding2))
          return original.SlowBufferWrite.call(this, string, offset, length, encoding2);
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding2);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding2) {
        return Buffer2.isNativeEncoding(encoding2) || iconv.encodingExists(encoding2);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str, encoding2) {
        encoding2 = String(encoding2 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding2))
          return original.BufferByteLength.call(this, str, encoding2);
        return iconv.encode(str, encoding2).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding2, start, end) {
        encoding2 = String(encoding2 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding2))
          return original.BufferToString.call(this, encoding2, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding2);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string, offset, length, encoding2) {
        var _offset = offset, _length = length, _encoding = encoding2;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding2 = length;
            length = void 0;
          }
        } else {
          var swap = encoding2;
          encoding2 = offset;
          offset = length;
          length = swap;
        }
        encoding2 = String(encoding2 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding2))
          return original.BufferWrite.call(this, string, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding2);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable = require$$0$4.Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = require$$0$9.SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = require$$0$4.Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = void 0;
    };
  };
  return extendNode;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3)
    return lib$3.exports;
  hasRequiredLib$3 = 1;
  (function(module2) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode2(str, encoding2, options) {
      str = "" + (str || "");
      var encoder2 = iconv.getEncoder(encoding2, options);
      var res = encoder2.write(str);
      var trail = encoder2.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding2, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder2 = iconv.getDecoder(encoding2, options);
      var res = decoder2.write(buf);
      var trail = decoder2.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding2) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding2);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding2 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding2) {
      return ("" + encoding2).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding2, options) {
      var codec = iconv.getCodec(encoding2), encoder2 = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder2 = new bomHandling2.PrependBOM(encoder2, options);
      return encoder2;
    };
    iconv.getDecoder = function getDecoder(encoding2, options) {
      var codec = iconv.getCodec(encoding2), decoder2 = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder2 = new bomHandling2.StripBOM(decoder2, options);
      return decoder2;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        requireStreams()(iconv);
      }
      requireExtendNode()(iconv);
    }
  })(lib$3);
  return lib$3.exports;
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var unpipe_1;
var hasRequiredUnpipe;
function requireUnpipe() {
  if (hasRequiredUnpipe)
    return unpipe_1;
  hasRequiredUnpipe = 1;
  unpipe_1 = unpipe;
  function hasPipeDataListeners(stream2) {
    var listeners = stream2.listeners("data");
    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].name === "ondata") {
        return true;
      }
    }
    return false;
  }
  function unpipe(stream2) {
    if (!stream2) {
      throw new TypeError("argument stream is required");
    }
    if (typeof stream2.unpipe === "function") {
      stream2.unpipe();
      return;
    }
    if (!hasPipeDataListeners(stream2)) {
      return;
    }
    var listener;
    var listeners = stream2.listeners("close");
    for (var i = 0; i < listeners.length; i++) {
      listener = listeners[i];
      if (listener.name !== "cleanup" && listener.name !== "onclose") {
        continue;
      }
      listener.call(stream2);
    }
  }
  return unpipe_1;
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody$1;
var hasRequiredRawBody$1;
function requireRawBody$1() {
  if (hasRequiredRawBody$1)
    return rawBody$1;
  hasRequiredRawBody$1 = 1;
  var asyncHooks = tryRequireAsyncHooks();
  var bytes2 = requireBytes();
  var createError = requireHttpErrors();
  var iconv = requireLib$3();
  var unpipe = requireUnpipe();
  rawBody$1 = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding2) {
    if (!encoding2)
      return null;
    try {
      return iconv.getDecoder(encoding2);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
        throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream2, options, callback) {
    var done = callback;
    var opts = options || {};
    if (stream2 === void 0) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream2 !== "object" || stream2 === null || typeof stream2.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding2 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit2 = bytes2.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream2(stream2, encoding2, length, limit2, wrap2(done));
    }
    return new Promise(function executor(resolve2, reject) {
      readStream2(stream2, encoding2, length, limit2, function onRead(err, buf) {
        if (err)
          return reject(err);
        resolve2(buf);
      });
    });
  }
  function halt(stream2) {
    unpipe(stream2);
    if (typeof stream2.pause === "function") {
      stream2.pause();
    }
  }
  function readStream2(stream2, encoding2, length, limit2, callback) {
    var complete = false;
    var sync = true;
    if (limit2 !== null && length !== null && length > limit2) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit: limit2,
        type: "entity.too.large"
      }));
    }
    var state2 = stream2._readableState;
    if (stream2._decoder || state2 && (state2.encoding || state2.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream2.readable !== "undefined" && !stream2.readable) {
      return done(createError(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder2;
    try {
      decoder2 = getDecoder(encoding2);
    } catch (err) {
      return done(err);
    }
    var buffer2 = decoder2 ? "" : [];
    stream2.on("aborted", onAborted);
    stream2.on("close", cleanup);
    stream2.on("data", onData);
    stream2.on("end", onEnd);
    stream2.on("error", onEnd);
    sync = false;
    function done() {
      var args2 = new Array(arguments.length);
      for (var i = 0; i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args2[0]) {
          halt(stream2);
        }
        callback.apply(null, args2);
      }
    }
    function onAborted() {
      if (complete)
        return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete)
        return;
      received += chunk.length;
      if (limit2 !== null && received > limit2) {
        done(createError(413, "request entity too large", {
          limit: limit2,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder2) {
        buffer2 += decoder2.write(chunk);
      } else {
        buffer2.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete)
        return;
      if (err)
        return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder2 ? buffer2 + (decoder2.end() || "") : Buffer.concat(buffer2);
        done(null, string);
      }
    }
    function cleanup() {
      buffer2 = null;
      stream2.removeListener("aborted", onAborted);
      stream2.removeListener("data", onData);
      stream2.removeListener("end", onEnd);
      stream2.removeListener("error", onEnd);
      stream2.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap2(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return rawBody$1;
}
var onFinished = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst;
var hasRequiredEeFirst;
function requireEeFirst() {
  if (hasRequiredEeFirst)
    return eeFirst;
  hasRequiredEeFirst = 1;
  eeFirst = first2;
  function first2(stuff, done) {
    if (!Array.isArray(stuff))
      throw new TypeError("arg must be an array of [ee, events...] arrays");
    var cleanups = [];
    for (var i = 0; i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2)
        throw new TypeError("each array member must be [ee, events...]");
      var ee = arr[0];
      for (var j = 1; j < arr.length; j++) {
        var event = arr[j];
        var fn = listener(event, callback);
        ee.on(event, fn);
        cleanups.push({
          ee,
          event,
          fn
        });
      }
    }
    function callback() {
      cleanup();
      done.apply(null, arguments);
    }
    function cleanup() {
      var x;
      for (var i2 = 0; i2 < cleanups.length; i2++) {
        x = cleanups[i2];
        x.ee.removeListener(x.event, x.fn);
      }
    }
    function thunk(fn2) {
      done = fn2;
    }
    thunk.cancel = cleanup;
    return thunk;
  }
  function listener(event, done) {
    return function onevent(arg1) {
      var args2 = new Array(arguments.length);
      var ee = this;
      var err = event === "error" ? arg1 : null;
      for (var i = 0; i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      done(err, ee, event, args2);
    };
  }
  return eeFirst;
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredOnFinished;
function requireOnFinished() {
  if (hasRequiredOnFinished)
    return onFinished.exports;
  hasRequiredOnFinished = 1;
  onFinished.exports = onFinished$1;
  onFinished.exports.isFinished = isFinished;
  var asyncHooks = tryRequireAsyncHooks();
  var first2 = requireEeFirst();
  var defer2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  function onFinished$1(msg, listener) {
    if (isFinished(msg) !== false) {
      defer2(listener, null, msg);
      return msg;
    }
    attachListener(msg, wrap2(listener));
    return msg;
  }
  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === "boolean") {
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === "boolean") {
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }
    return void 0;
  }
  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error2) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error2);
    }
    eeMsg = eeSocket = first2([[msg, "end", "finish"]], onFinish);
    function onSocket(socket) {
      msg.removeListener("socket", onSocket);
      if (finished)
        return;
      if (eeMsg !== eeSocket)
        return;
      eeSocket = first2([[socket, "error", "close"]], onFinish);
    }
    if (msg.socket) {
      onSocket(msg.socket);
      return;
    }
    msg.on("socket", onSocket);
    if (msg.socket === void 0) {
      patchAssignSocket(msg, onSocket);
    }
  }
  function attachListener(msg, listener) {
    var attached = msg.__onFinished;
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }
  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener)
        msg.__onFinished = null;
      if (!listener.queue)
        return;
      var queue2 = listener.queue;
      listener.queue = null;
      for (var i = 0; i < queue2.length; i++) {
        queue2[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== "function")
      return;
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap2(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return onFinished.exports;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var read_1$1;
var hasRequiredRead$1;
function requireRead$1() {
  if (hasRequiredRead$1)
    return read_1$1;
  hasRequiredRead$1 = 1;
  var createError = requireHttpErrors();
  var destroy2 = requireDestroy$1();
  var getBody = requireRawBody$1();
  var iconv = requireLib$3();
  var onFinished2 = requireOnFinished();
  var unpipe = requireUnpipe();
  var zlib$1 = zlib;
  read_1$1 = read;
  function read(req, res, next, parse2, debug2, options) {
    var length;
    var opts = options;
    var stream2;
    req._body = true;
    var encoding2 = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream2 = contentstream(req, debug2, opts.inflate);
      length = stream2.length;
      stream2.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding2;
    if (opts.encoding === null && encoding2 !== null && !iconv.encodingExists(encoding2)) {
      return next(createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
        charset: encoding2.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug2("read body");
    getBody(stream2, opts, function(error2, body) {
      if (error2) {
        var _error;
        if (error2.type === "encoding.unsupported") {
          _error = createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
            charset: encoding2.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError(400, error2);
        }
        if (stream2 !== req) {
          unpipe(req);
          destroy2(stream2, true);
        }
        dump(req, function onfinished() {
          next(createError(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug2("verify body");
          verify(req, res, body, encoding2);
        } catch (err) {
          next(createError(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug2("parse body");
        str = typeof body !== "string" && encoding2 !== null ? iconv.decode(body, encoding2) : body;
        req.body = parse2(str);
      } catch (err) {
        next(createError(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req, debug2, inflate) {
    var encoding2 = (req.headers["content-encoding"] || "identity").toLowerCase();
    var length = req.headers["content-length"];
    var stream2;
    debug2('content-encoding "%s"', encoding2);
    if (inflate === false && encoding2 !== "identity") {
      throw createError(415, "content encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
    switch (encoding2) {
      case "deflate":
        stream2 = zlib$1.createInflate();
        debug2("inflate body");
        req.pipe(stream2);
        break;
      case "gzip":
        stream2 = zlib$1.createGunzip();
        debug2("gunzip body");
        req.pipe(stream2);
        break;
      case "identity":
        stream2 = req;
        stream2.length = length;
        break;
      default:
        throw createError(415, 'unsupported content encoding "' + encoding2 + '"', {
          encoding: encoding2,
          type: "encoding.unsupported"
        });
    }
    return stream2;
  }
  function dump(req, callback) {
    if (onFinished2.isFinished(req)) {
      callback(null);
    } else {
      onFinished2(req, callback);
      req.resume();
    }
  }
  return read_1$1;
}
var typeIs = { exports: {} };
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMediaTyper;
function requireMediaTyper() {
  if (hasRequiredMediaTyper)
    return mediaTyper;
  hasRequiredMediaTyper = 1;
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
  var qescRegExp = /\\([\u0000-\u007f])/g;
  var quoteRegExp = /([\\"])/g;
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  mediaTyper.format = format2;
  mediaTyper.parse = parse2;
  function format2(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type2 = obj.type;
    if (!type2 || !typeNameRegExp.test(type2)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string = type2 + "/" + subtype;
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string += "+" + suffix;
    }
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!tokenRegExp.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse2(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string === "object") {
      string = getcontenttype(string);
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = string.indexOf(";");
    var type2 = index !== -1 ? string.substr(0, index) : string;
    var key;
    var match;
    var obj = splitType(type2);
    var params = {};
    var value;
    paramRegExp.lastIndex = index;
    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    obj.parameters = params;
    return obj;
  }
  function getcontenttype(obj) {
    if (typeof obj.getHeader === "function") {
      return obj.getHeader("content-type");
    }
    if (typeof obj.headers === "object") {
      return obj.headers && obj.headers["content-type"];
    }
  }
  function qstring(val) {
    var str = String(val);
    if (tokenRegExp.test(str)) {
      return str;
    }
    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(quoteRegExp, "\\$1") + '"';
  }
  function splitType(string) {
    var match = typeRegExp.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type2 = match[1];
    var subtype = match[2];
    var suffix;
    var index = subtype.lastIndexOf("+");
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }
    var obj = {
      type: type2,
      subtype,
      suffix
    };
    return obj;
  }
  return mediaTyper;
}
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb = require$$0;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports2) {
  var db = mimeDb;
  var extname = require$$0$6.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset2;
  exports2.charsets = { lookup: charset2 };
  exports2.contentType = contentType2;
  exports2.extension = extension;
  exports2.extensions = /* @__PURE__ */ Object.create(null);
  exports2.lookup = lookup;
  exports2.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset2(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var mime2 = match && db[match[1].toLowerCase()];
    if (mime2 && mime2.charset) {
      return mime2.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType2(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime2 = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
    if (!mime2) {
      return false;
    }
    if (mime2.indexOf("charset") === -1) {
      var charset3 = exports2.charset(mime2);
      if (charset3)
        mime2 += "; charset=" + charset3.toLowerCase();
    }
    return mime2;
  }
  function extension(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var exts = match && exports2.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path2) {
    if (!path2 || typeof path2 !== "string") {
      return false;
    }
    var extension2 = extname("x." + path2).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports2.types[extension2] || false;
  }
  function populateMaps(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type2) {
      var mime2 = db[type2];
      var exts = mime2.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type2] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types2[extension2]) {
          var from2 = preference.indexOf(db[types2[extension2]].source);
          var to = preference.indexOf(mime2.source);
          if (types2[extension2] !== "application/octet-stream" && (from2 > to || from2 === to && types2[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types2[extension2] = type2;
      }
    });
  }
})(mimeTypes);
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredTypeIs;
function requireTypeIs() {
  if (hasRequiredTypeIs)
    return typeIs.exports;
  hasRequiredTypeIs = 1;
  var typer = requireMediaTyper();
  var mime2 = mimeTypes;
  typeIs.exports = typeofrequest;
  typeIs.exports.is = typeis;
  typeIs.exports.hasBody = hasbody;
  typeIs.exports.normalize = normalize2;
  typeIs.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types2 = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types2 && !Array.isArray(types2)) {
      types2 = new Array(arguments.length - 1);
      for (i = 0; i < types2.length; i++) {
        types2[i] = arguments[i + 1];
      }
    }
    if (!types2 || !types2.length) {
      return val;
    }
    var type2;
    for (i = 0; i < types2.length; i++) {
      if (mimeMatch(normalize2(type2 = types2[i]), val)) {
        return type2[0] === "+" || type2.indexOf("*") !== -1 ? val : type2;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    var types2 = types_;
    if (!hasbody(req)) {
      return null;
    }
    if (arguments.length > 2) {
      types2 = new Array(arguments.length - 1);
      for (var i = 0; i < types2.length; i++) {
        types2[i] = arguments[i + 1];
      }
    }
    var value = req.headers["content-type"];
    return typeis(value, types2);
  }
  function normalize2(type2) {
    if (typeof type2 !== "string") {
      return false;
    }
    switch (type2) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type2[0] === "+") {
      return "*/*" + type2;
    }
    return type2.indexOf("/") === -1 ? mime2.lookup(type2) : type2;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].substr(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type2 = typer.parse(value);
    type2.parameters = void 0;
    return typer.format(type2);
  }
  function tryNormalizeType(value) {
    if (!value) {
      return null;
    }
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
  return typeIs.exports;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var json_1$1;
var hasRequiredJson$1;
function requireJson$1() {
  if (hasRequiredJson$1)
    return json_1$1;
  hasRequiredJson$1 = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var createError = requireHttpErrors();
  var debug2 = requireSrc()("body-parser:json");
  var read = requireRead$1();
  var typeis = requireTypeIs();
  json_1$1 = json;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json(options) {
    var opts = options || {};
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var inflate = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type2 = opts.type || "application/json";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    function parse2(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first2 = firstchar(body);
        if (first2 !== "{" && first2 !== "[") {
          debug2("strict violation");
          throw createStrictSyntaxError(body, first2);
        }
      }
      try {
        debug2("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req, res, next) {
      if (req._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || "utf-8";
      if (charset2.slice(0, 4) !== "utf-") {
        debug2("invalid charset");
        next(createError(415, 'unsupported charset "' + charset2.toUpperCase() + '"', {
          charset: charset2,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse2, debug2, {
        encoding: charset2,
        inflate,
        limit: limit2,
        verify
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index = str.indexOf(char);
    var partial = "";
    if (index !== -1) {
      partial = str.substring(0, index) + JSON_SYNTAX_CHAR;
      for (var i = index + 1; i < str.length; i++) {
        partial += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str.substring(index, index + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    var match = FIRST_CHAR_REGEXP.exec(str);
    return match ? match[1] : void 0;
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function normalizeJsonSyntaxError(error2, obj) {
    var keys = Object.getOwnPropertyNames(error2);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key !== "stack" && key !== "message") {
        delete error2[key];
      }
    }
    error2.stack = obj.stack.replace(error2.message, obj.message);
    error2.message = obj.message;
    return error2;
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  return json_1$1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var raw_1$1;
var hasRequiredRaw$1;
function requireRaw$1() {
  if (hasRequiredRaw$1)
    return raw_1$1;
  hasRequiredRaw$1 = 1;
  var bytes2 = requireBytes();
  var debug2 = requireSrc()("body-parser:raw");
  var read = requireRead$1();
  var typeis = requireTypeIs();
  raw_1$1 = raw;
  function raw(options) {
    var opts = options || {};
    var inflate = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type2 = opts.type || "application/octet-stream";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    function parse2(buf) {
      return buf;
    }
    return function rawParser(req, res, next) {
      if (req._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      read(req, res, next, parse2, debug2, {
        encoding: null,
        inflate,
        limit: limit2,
        verify
      });
    };
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  return raw_1$1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var text_1$1;
var hasRequiredText$1;
function requireText$1() {
  if (hasRequiredText$1)
    return text_1$1;
  hasRequiredText$1 = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var debug2 = requireSrc()("body-parser:text");
  var read = requireRead$1();
  var typeis = requireTypeIs();
  text_1$1 = text;
  function text(options) {
    var opts = options || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type2 = opts.type || "text/plain";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    function parse2(buf) {
      return buf;
    }
    return function textParser(req, res, next) {
      if (req._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || defaultCharset;
      read(req, res, next, parse2, debug2, {
        encoding: charset2,
        inflate,
        limit: limit2,
        verify
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  return text_1$1;
}
var type$4 = TypeError;
var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
  if (hasRequiredUtil_inspect)
    return util_inspect;
  hasRequiredUtil_inspect = 1;
  util_inspect = require$$1$1.inspect;
  return util_inspect;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect)
    return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace2 = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat2 = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag2 = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace2.call(intStr, sepRegex, "$&_") + "." + $replace2.call($replace2.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace2.call(str, sepRegex, "$&_");
  }
  var utilInspect = requireUtil_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from2, noIndent) {
      if (from2) {
        seen = $arrSlice.call(seen);
        seen.push(from2);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp2(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace2.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat2.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate2(obj) && !isRegExp2(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag2 && Object(obj) === obj && toStringTag2 in obj ? $slice.call(toStr2(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat2.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace2.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag2 || !(typeof obj === "object" && (toStringTag2 in obj || typeof obj[toStringTag2] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr2(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate2(obj) {
    return toStr2(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp2(obj) {
    return toStr2(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError(obj) {
    return toStr2(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString2(obj) {
    return toStr2(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber2(obj) {
    return toStr2(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr2(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn2 = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn2.call(obj, key);
  }
  function toStr2(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace2.call($replace2.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList)
    return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect = requireObjectInspect();
  var $TypeError2 = type$4;
  var listGetNode = function(list, key, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    if (!objects) {
      return void 0;
    }
    var node2 = listGetNode(objects, key);
    return node2 && node2.value;
  };
  var listSet = function(objects, key, value) {
    var node2 = listGetNode(objects, key);
    if (node2) {
      node2.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  var listDelete = function(objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError2("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root && root === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key) {
        return listGet($o, key);
      },
      has: function(key) {
        return listHas($o, key);
      },
      set: function(key, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var esObjectAtoms = Object;
var esErrors = Error;
var _eval = EvalError;
var range$1 = RangeError;
var ref$2 = ReferenceError;
var syntax = SyntaxError;
var uri$4 = URIError;
var abs$1 = Math.abs;
var floor$1 = Math.floor;
var max$2 = Math.max;
var min$1 = Math.min;
var pow$1 = Math.pow;
var round$1 = Math.round;
var _isNaN = Number.isNaN || function isNaN2(a) {
  return a !== a;
};
var $isNaN = _isNaN;
var sign$1 = function sign(number) {
  if ($isNaN(number) || number === 0) {
    return number;
  }
  return number < 0 ? -1 : 1;
};
var gOPD = Object.getOwnPropertyDescriptor;
var $gOPD$1 = gOPD;
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var gopd = $gOPD$1;
var $defineProperty$2 = Object.defineProperty || false;
if ($defineProperty$2) {
  try {
    $defineProperty$2({}, "a", { value: 1 });
  } catch (e) {
    $defineProperty$2 = false;
  }
}
var esDefineProperty = $defineProperty$2;
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1)
    return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols$1;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$1;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf)
    return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf)
    return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object2 = esObjectAtoms;
  Object_getPrototypeOf = $Object2.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr = Object.prototype.toString;
var max$1 = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args2 = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        concatty(args2, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(
      that,
      concatty(args2, arguments)
    );
  };
  var boundLength = max$1(0, target.length - args2.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = "$" + i;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall)
    return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply)
    return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply)
    return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply)
    return actualApply;
  hasRequiredActualApply = 1;
  var bind3 = functionBind;
  var $apply2 = requireFunctionApply();
  var $call2 = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind3.call($call2, $apply2);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers)
    return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind3 = functionBind;
  var $TypeError2 = type$4;
  var $call2 = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args2) {
    if (args2.length < 1 || typeof args2[0] !== "function") {
      throw new $TypeError2("a function is required");
    }
    return $actualApply(bind3, $call2, args2);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet)
    return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = gopd;
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object2 = Object;
  var $getPrototypeOf = $Object2.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object2(value));
    }
  ) : false;
  return get;
}
var getProto$1;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto)
    return getProto$1;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto$1 = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto$1;
}
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$2 = functionBind;
var hasown = bind$2.call(call, $hasOwn);
var undefined$1;
var $Object = esObjectAtoms;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range$1;
var $ReferenceError = ref$2;
var $SyntaxError = syntax;
var $TypeError$1 = type$4;
var $URIError = uri$4;
var abs = abs$1;
var floor = floor$1;
var max = max$2;
var min = min$1;
var pow = pow$1;
var round = round$1;
var sign2 = sign$1;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = gopd;
var $defineProperty$1 = esDefineProperty;
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = requireHasSymbols()();
var getProto = requireGetProto();
var $ObjectGPO = requireObject_getPrototypeOf();
var $ReflectGPO = requireReflect_getPrototypeOf();
var $apply = requireFunctionApply();
var $call = requireFunctionCall();
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply,
  "%Object.defineProperty%": $defineProperty$1,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign2,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$1 = functionBind;
var hasOwn$2 = hasown;
var $concat = bind$1.call($call, Array.prototype.concat);
var $spliceApply = bind$1.call($apply, Array.prototype.splice);
var $replace = bind$1.call($call, String.prototype.replace);
var $strSlice = bind$1.call($call, String.prototype.slice);
var $exec = bind$1.call($call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first2 = $strSlice(string, 0, 1);
  var last2 = $strSlice(string, -1);
  if (first2 === "%" && last2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$2(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first2 = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$2(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$2(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic3 = getIntrinsic;
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic3("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic3(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap)
    return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic3 = getIntrinsic;
  var callBound2 = requireCallBound();
  var inspect = requireObjectInspect();
  var $TypeError2 = type$4;
  var $Map = GetIntrinsic3("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError2("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        if ($m) {
          var result = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result;
        }
        return false;
      },
      get: function(key) {
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function(key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function(key, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap)
    return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic3 = getIntrinsic;
  var callBound2 = requireCallBound();
  var inspect = requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError2 = type$4;
  var $WeakMap = GetIntrinsic3("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError2("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key);
            }
          }
          return false;
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          }
          return $m && $m.get(key);
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          }
          return !!$m && $m.has(key);
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel)
    return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError2 = type$4;
  var inspect = requireObjectInspect();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError2("Side channel does not contain " + inspect(key));
        }
      },
      "delete": function(key) {
        return !!$channelData && $channelData["delete"](key);
      },
      get: function(key) {
        return $channelData && $channelData.get(key);
      },
      has: function(key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function(key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats$1;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats)
    return formats$1;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats$1 = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats$1;
}
var utils$6;
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2)
    return utils$6;
  hasRequiredUtils$2 = 1;
  var formats2 = requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue2) {
    while (queue2.length > 1) {
      var item = queue2.pop();
      var obj = item.obj[item.prop];
      if (isArray2(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject2 = function arrayToObject3(source2, options) {
    var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var i = 0; i < source2.length; ++i) {
      if (typeof source2[i] !== "undefined") {
        obj[i] = source2[i];
      }
    }
    return obj;
  };
  var merge2 = function merge3(target, source2, options) {
    if (!source2) {
      return target;
    }
    if (typeof source2 !== "object") {
      if (isArray2(target)) {
        target.push(source2);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source2)) {
          target[source2] = true;
        }
      } else {
        return [target, source2];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source2);
    }
    var mergeTarget = target;
    if (isArray2(target) && !isArray2(source2)) {
      mergeTarget = arrayToObject2(target, options);
    }
    if (isArray2(target) && isArray2(source2)) {
      source2.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge3(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source2).reduce(function(acc, key) {
      var value = source2[key];
      if (has.call(acc, key)) {
        acc[key] = merge3(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source2) {
    return Object.keys(source2).reduce(function(acc, key) {
      acc[key] = source2[key];
      return acc;
    }, target);
  };
  var decode = function(str, decoder2, charset2) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset2 === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var encode2 = function encode3(str, defaultEncoder, charset2, kind, format2) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset2 === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var i = 0; i < string.length; ++i) {
      var c = string.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats2.RFC1738 && (c === 40 || c === 41)) {
        out += string.charAt(i);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue2 = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue2.length; ++i) {
      var item = queue2[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue2.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue2);
    return value;
  };
  var isRegExp2 = function isRegExp3(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer2 = function isBuffer3(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray2(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils$6 = {
    arrayToObject: arrayToObject2,
    assign,
    combine,
    compact,
    decode,
    encode: encode2,
    isBuffer: isBuffer2,
    isRegExp: isRegExp2,
    maybeMap,
    merge: merge2
  };
  return utils$6;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify)
    return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = requireUtils$2();
  var formats2 = requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat2(prefix) {
      return prefix;
    }
  };
  var isArray2 = Array.isArray;
  var split = String.prototype.split;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults2 = {
    addQueryPrefix: false,
    allowDots: false,
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder2, filter3, sort2, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset2, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter3 === "function") {
      obj = filter3(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder2 && !encodeValuesOnly ? encoder2(prefix, defaults2.encoder, charset2, "key", format2) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder2) {
        var keyValue = encodeValuesOnly ? prefix : encoder2(prefix, defaults2.encoder, charset2, "key", format2);
        if (generateArrayPrefix === "comma" && encodeValuesOnly) {
          var valuesArray = split.call(String(obj), ",");
          var valuesJoined = "";
          for (var i = 0; i < valuesArray.length; ++i) {
            valuesJoined += (i === 0 ? "" : ",") + formatter(encoder2(valuesArray[i], defaults2.encoder, charset2, "value", format2));
          }
          return [formatter(keyValue) + (commaRoundTrip && isArray2(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
        }
        return [formatter(keyValue) + "=" + formatter(encoder2(obj, defaults2.encoder, charset2, "value", format2))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray2(obj)) {
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray2(filter3)) {
      objKeys = filter3;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort2 ? keys.sort(sort2) : keys;
    }
    var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
    for (var j = 0; j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values, stringify2(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        strictNullHandling,
        skipNulls,
        encoder2,
        filter3,
        sort2,
        allowDots,
        serializeDate,
        format2,
        formatter,
        encodeValuesOnly,
        charset2,
        valueSideChannel
      ));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset2 = opts.charset || defaults2.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats2.formatters[format2];
    var filter3 = defaults2.filter;
    if (typeof opts.filter === "function" || isArray2(opts.filter)) {
      filter3 = opts.filter;
    }
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
      allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
      charset: charset2,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
      filter: filter3,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter3;
    if (typeof options.filter === "function") {
      filter3 = options.filter;
      obj = filter3("", obj);
    } else if (isArray2(options.filter)) {
      filter3 = options.filter;
      objKeys = filter3;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if (opts && "indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys, stringify(
        obj[key],
        key,
        generateArrayPrefix,
        commaRoundTrip,
        options.strictNullHandling,
        options.skipNulls,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse$8;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse)
    return parse$8;
  hasRequiredParse = 1;
  var utils2 = requireUtils$2();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var defaults2 = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    var limit2 = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit2);
    var skipIndex = -1;
    var i;
    var charset2 = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset2 = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset2 = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults2.decoder, charset2, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults2.decoder, charset2, "key");
        val = utils2.maybeMap(
          parseArrayValue(part.slice(pos + 1), options),
          function(encodedVal) {
            return options.decoder(encodedVal, defaults2.decoder, charset2, "value");
          }
        );
      }
      if (val && options.interpretNumericEntities && charset2 === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray2(val) ? [val] : val;
      }
      if (has.call(obj, key)) {
        obj[key] = utils2.combine(obj[key], val);
      } else {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj = [].concat(leaf);
      } else {
        obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var index = parseInt(cleanRoot, 10);
        if (!options.parseArrays && cleanRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else if (cleanRoot !== "__proto__") {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset2 = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
    return {
      allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
      charset: charset2,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  parse$8 = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils2.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse$8;
}
var lib$2;
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2)
    return lib$2;
  hasRequiredLib$2 = 1;
  var stringify = requireStringify();
  var parse2 = requireParse();
  var formats2 = requireFormats();
  lib$2 = {
    formats: formats2,
    parse: parse2,
    stringify
  };
  return lib$2;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var urlencoded_1$1;
var hasRequiredUrlencoded$2;
function requireUrlencoded$2() {
  if (hasRequiredUrlencoded$2)
    return urlencoded_1$1;
  hasRequiredUrlencoded$2 = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var createError = requireHttpErrors();
  var debug2 = requireSrc()("body-parser:urlencoded");
  var deprecate = requireDepd()("body-parser");
  var read = requireRead$1();
  var typeis = requireTypeIs();
  urlencoded_1$1 = urlencoded2;
  var parsers = /* @__PURE__ */ Object.create(null);
  function urlencoded2(options) {
    var opts = options || {};
    if (opts.extended === void 0) {
      deprecate("undefined extended: provide extended option");
    }
    var extended = opts.extended !== false;
    var inflate = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type2 = opts.type || "application/x-www-form-urlencoded";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    function parse2(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req, res, next) {
      if (req._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || "utf-8";
      if (charset2 !== "utf-8") {
        debug2("invalid charset");
        next(createError(415, 'unsupported charset "' + charset2.toUpperCase() + '"', {
          charset: charset2,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse2, debug2, {
        debug: debug2,
        encoding: charset2,
        inflate,
        limit: limit2,
        verify
      });
    };
  }
  function extendedparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug2("parse extended urlencoding");
      return parse2(body, {
        allowPrototypes: true,
        arrayLimit,
        depth: Infinity,
        parameterLimit
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function parameterCount(body, limit2) {
    var count2 = 0;
    var index = 0;
    while ((index = body.indexOf("&", index)) !== -1) {
      count2++;
      index++;
      if (count2 === limit2) {
        return void 0;
      }
    }
    return count2;
  }
  function parser(name) {
    var mod = parsers[name];
    if (mod !== void 0) {
      return mod.parse;
    }
    switch (name) {
      case "qs":
        mod = requireLib$2();
        break;
      case "querystring":
        mod = require$$8;
        break;
    }
    parsers[name] = mod;
    return mod.parse;
  }
  function simpleparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug2("parse urlencoding");
      return parse2(body, void 0, void 0, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  return urlencoded_1$1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredBodyParser$1;
function requireBodyParser$1() {
  if (hasRequiredBodyParser$1)
    return bodyParser$1.exports;
  hasRequiredBodyParser$1 = 1;
  (function(module2, exports2) {
    var deprecate = requireDepd()("body-parser");
    var parsers = /* @__PURE__ */ Object.create(null);
    exports2 = module2.exports = deprecate.function(
      bodyParser2,
      "bodyParser: use individual json/urlencoded middlewares"
    );
    Object.defineProperty(exports2, "json", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("json")
    });
    Object.defineProperty(exports2, "raw", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("raw")
    });
    Object.defineProperty(exports2, "text", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("text")
    });
    Object.defineProperty(exports2, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("urlencoded")
    });
    function bodyParser2(options) {
      var opts = Object.create(options || null, {
        type: {
          configurable: true,
          enumerable: true,
          value: void 0,
          writable: true
        }
      });
      var _urlencoded = exports2.urlencoded(opts);
      var _json = exports2.json(opts);
      return function bodyParser3(req, res, next) {
        _json(req, res, function(err) {
          if (err)
            return next(err);
          _urlencoded(req, res, next);
        });
      };
    }
    function createParserGetter(name) {
      return function get2() {
        return loadParser(name);
      };
    }
    function loadParser(parserName) {
      var parser = parsers[parserName];
      if (parser !== void 0) {
        return parser;
      }
      switch (parserName) {
        case "json":
          parser = requireJson$1();
          break;
        case "raw":
          parser = requireRaw$1();
          break;
        case "text":
          parser = requireText$1();
          break;
        case "urlencoded":
          parser = requireUrlencoded$2();
          break;
      }
      return parsers[parserName] = parser;
    }
  })(bodyParser$1, bodyParser$1.exports);
  return bodyParser$1.exports;
}
var lib$1 = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
    var from2;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from2 = Object(arguments[s]);
      for (var key in from2) {
        if (hasOwnProperty2.call(from2, key)) {
          to[key] = from2[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from2);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from2, symbols[i])) {
            to[symbols[i]] = from2[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var vary = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredVary;
function requireVary() {
  if (hasRequiredVary)
    return vary.exports;
  hasRequiredVary = 1;
  vary.exports = vary$1;
  vary.exports.append = append2;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append2(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse2(String(field)) : field;
    for (var j = 0; j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse2(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0; i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse2(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length; i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary$1(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append2(header, field)) {
      res.setHeader("Vary", val);
    }
  }
  return vary.exports;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1)
    return lib$1.exports;
  hasRequiredLib$1 = 1;
  (function() {
    var assign = requireObjectAssign();
    var vary2 = requireVary();
    var defaults2 = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204
    };
    function isString2(s) {
      return typeof s === "string" || s instanceof String;
    }
    function isOriginAllowed(origin2, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i = 0; i < allowedOrigin.length; ++i) {
          if (isOriginAllowed(origin2, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (isString2(allowedOrigin)) {
        return origin2 === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin2);
      } else {
        return !!allowedOrigin;
      }
    }
    function configureOrigin(options, req) {
      var requestOrigin = req.headers.origin, headers = [], isAllowed;
      if (!options.origin || options.origin === "*") {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: "*"
        }]);
      } else if (isString2(options.origin)) {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: options.origin
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options.origin);
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: isAllowed ? requestOrigin : false
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      }
      return headers;
    }
    function configureMethods(options) {
      var methods2 = options.methods;
      if (methods2.join) {
        methods2 = options.methods.join(",");
      }
      return {
        key: "Access-Control-Allow-Methods",
        value: methods2
      };
    }
    function configureCredentials(options) {
      if (options.credentials === true) {
        return {
          key: "Access-Control-Allow-Credentials",
          value: "true"
        };
      }
      return null;
    }
    function configureAllowedHeaders(options, req) {
      var allowedHeaders = options.allowedHeaders || options.headers;
      var headers = [];
      if (!allowedHeaders) {
        allowedHeaders = req.headers["access-control-request-headers"];
        headers.push([{
          key: "Vary",
          value: "Access-Control-Request-Headers"
        }]);
      } else if (allowedHeaders.join) {
        allowedHeaders = allowedHeaders.join(",");
      }
      if (allowedHeaders && allowedHeaders.length) {
        headers.push([{
          key: "Access-Control-Allow-Headers",
          value: allowedHeaders
        }]);
      }
      return headers;
    }
    function configureExposedHeaders(options) {
      var headers = options.exposedHeaders;
      if (!headers) {
        return null;
      } else if (headers.join) {
        headers = headers.join(",");
      }
      if (headers && headers.length) {
        return {
          key: "Access-Control-Expose-Headers",
          value: headers
        };
      }
      return null;
    }
    function configureMaxAge(options) {
      var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: "Access-Control-Max-Age",
          value: maxAge
        };
      }
      return null;
    }
    function applyHeaders(headers, res) {
      for (var i = 0, n = headers.length; i < n; i++) {
        var header = headers[i];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === "Vary" && header.value) {
            vary2(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }
    function cors(options, req, res, next) {
      var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
      if (method === "OPTIONS") {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options));
        headers.push(configureMethods(options));
        headers.push(configureAllowedHeaders(options, req));
        headers.push(configureMaxAge(options));
        headers.push(configureExposedHeaders(options));
        applyHeaders(headers, res);
        if (options.preflightContinue) {
          next();
        } else {
          res.statusCode = options.optionsSuccessStatus;
          res.setHeader("Content-Length", "0");
          res.end();
        }
      } else {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options));
        headers.push(configureExposedHeaders(options));
        applyHeaders(headers, res);
        next();
      }
    }
    function middlewareWrapper(o) {
      var optionsCallback = null;
      if (typeof o === "function") {
        optionsCallback = o;
      } else {
        optionsCallback = function(req, cb) {
          cb(null, o);
        };
      }
      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function(err, options) {
          if (err) {
            next(err);
          } else {
            var corsOptions = assign({}, defaults2, options);
            var originCallback = null;
            if (corsOptions.origin && typeof corsOptions.origin === "function") {
              originCallback = corsOptions.origin;
            } else if (corsOptions.origin) {
              originCallback = function(origin2, cb) {
                cb(null, corsOptions.origin);
              };
            }
            if (originCallback) {
              originCallback(req.headers.origin, function(err2, origin2) {
                if (err2 || !origin2) {
                  next(err2);
                } else {
                  corsOptions.origin = origin2;
                  cors(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }
    lib$1.exports = middlewareWrapper;
  })();
  return lib$1.exports;
}
var express$1 = { exports: {} };
var bodyParser = { exports: {} };
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody)
    return rawBody;
  hasRequiredRawBody = 1;
  var asyncHooks = tryRequireAsyncHooks();
  var bytes2 = requireBytes();
  var createError = requireHttpErrors();
  var iconv = requireLib$3();
  var unpipe = requireUnpipe();
  rawBody = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding2) {
    if (!encoding2)
      return null;
    try {
      return iconv.getDecoder(encoding2);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
        throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream2, options, callback) {
    var done = callback;
    var opts = options || {};
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding2 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit2 = bytes2.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream2(stream2, encoding2, length, limit2, wrap2(done));
    }
    return new Promise(function executor(resolve2, reject) {
      readStream2(stream2, encoding2, length, limit2, function onRead(err, buf) {
        if (err)
          return reject(err);
        resolve2(buf);
      });
    });
  }
  function halt(stream2) {
    unpipe(stream2);
    if (typeof stream2.pause === "function") {
      stream2.pause();
    }
  }
  function readStream2(stream2, encoding2, length, limit2, callback) {
    var complete = false;
    var sync = true;
    if (limit2 !== null && length !== null && length > limit2) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit: limit2,
        type: "entity.too.large"
      }));
    }
    var state2 = stream2._readableState;
    if (stream2._decoder || state2 && (state2.encoding || state2.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream2.readable !== "undefined" && !stream2.readable) {
      return done(createError(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder2;
    try {
      decoder2 = getDecoder(encoding2);
    } catch (err) {
      return done(err);
    }
    var buffer2 = decoder2 ? "" : [];
    stream2.on("aborted", onAborted);
    stream2.on("close", cleanup);
    stream2.on("data", onData);
    stream2.on("end", onEnd);
    stream2.on("error", onEnd);
    sync = false;
    function done() {
      var args2 = new Array(arguments.length);
      for (var i = 0; i < args2.length; i++) {
        args2[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args2[0]) {
          halt(stream2);
        }
        callback.apply(null, args2);
      }
    }
    function onAborted() {
      if (complete)
        return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete)
        return;
      received += chunk.length;
      if (limit2 !== null && received > limit2) {
        done(createError(413, "request entity too large", {
          limit: limit2,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder2) {
        buffer2 += decoder2.write(chunk);
      } else {
        buffer2.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete)
        return;
      if (err)
        return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder2 ? buffer2 + (decoder2.end() || "") : Buffer.concat(buffer2);
        done(null, string);
      }
    }
    function cleanup() {
      buffer2 = null;
      stream2.removeListener("aborted", onAborted);
      stream2.removeListener("data", onData);
      stream2.removeListener("end", onEnd);
      stream2.removeListener("error", onEnd);
      stream2.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap2(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return rawBody;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var read_1;
var hasRequiredRead;
function requireRead() {
  if (hasRequiredRead)
    return read_1;
  hasRequiredRead = 1;
  var createError = requireHttpErrors();
  var destroy2 = requireDestroy$1();
  var getBody = requireRawBody();
  var iconv = requireLib$3();
  var onFinished2 = requireOnFinished();
  var unpipe = requireUnpipe();
  var zlib$1 = zlib;
  read_1 = read;
  function read(req, res, next, parse2, debug2, options) {
    var length;
    var opts = options;
    var stream2;
    req._body = true;
    var encoding2 = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream2 = contentstream(req, debug2, opts.inflate);
      length = stream2.length;
      stream2.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding2;
    if (opts.encoding === null && encoding2 !== null && !iconv.encodingExists(encoding2)) {
      return next(createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
        charset: encoding2.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug2("read body");
    getBody(stream2, opts, function(error2, body) {
      if (error2) {
        var _error;
        if (error2.type === "encoding.unsupported") {
          _error = createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
            charset: encoding2.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError(400, error2);
        }
        if (stream2 !== req) {
          unpipe(req);
          destroy2(stream2, true);
        }
        dump(req, function onfinished() {
          next(createError(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug2("verify body");
          verify(req, res, body, encoding2);
        } catch (err) {
          next(createError(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug2("parse body");
        str = typeof body !== "string" && encoding2 !== null ? iconv.decode(body, encoding2) : body;
        req.body = parse2(str);
      } catch (err) {
        next(createError(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req, debug2, inflate) {
    var encoding2 = (req.headers["content-encoding"] || "identity").toLowerCase();
    var length = req.headers["content-length"];
    var stream2;
    debug2('content-encoding "%s"', encoding2);
    if (inflate === false && encoding2 !== "identity") {
      throw createError(415, "content encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
    switch (encoding2) {
      case "deflate":
        stream2 = zlib$1.createInflate();
        debug2("inflate body");
        req.pipe(stream2);
        break;
      case "gzip":
        stream2 = zlib$1.createGunzip();
        debug2("gunzip body");
        req.pipe(stream2);
        break;
      case "identity":
        stream2 = req;
        stream2.length = length;
        break;
      default:
        throw createError(415, 'unsupported content encoding "' + encoding2 + '"', {
          encoding: encoding2,
          type: "encoding.unsupported"
        });
    }
    return stream2;
  }
  function dump(req, callback) {
    if (onFinished2.isFinished(req)) {
      callback(null);
    } else {
      onFinished2(req, callback);
      req.resume();
    }
  }
  return read_1;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson)
    return json_1;
  hasRequiredJson = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var createError = requireHttpErrors();
  var debug2 = requireSrc()("body-parser:json");
  var read = requireRead();
  var typeis = requireTypeIs();
  json_1 = json;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  function json(options) {
    var opts = options || {};
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var inflate = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type2 = opts.type || "application/json";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    function parse2(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first2 = firstchar(body);
        if (first2 !== "{" && first2 !== "[") {
          debug2("strict violation");
          throw createStrictSyntaxError(body, first2);
        }
      }
      try {
        debug2("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req, res, next) {
      if (req._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || "utf-8";
      if (charset2.slice(0, 4) !== "utf-") {
        debug2("invalid charset");
        next(createError(415, 'unsupported charset "' + charset2.toUpperCase() + '"', {
          charset: charset2,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse2, debug2, {
        encoding: charset2,
        inflate,
        limit: limit2,
        verify
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index = str.indexOf(char);
    var partial = index !== -1 ? str.substring(0, index) + "#" : "";
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace("#", char),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    var match = FIRST_CHAR_REGEXP.exec(str);
    return match ? match[1] : void 0;
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function normalizeJsonSyntaxError(error2, obj) {
    var keys = Object.getOwnPropertyNames(error2);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key !== "stack" && key !== "message") {
        delete error2[key];
      }
    }
    error2.stack = obj.stack.replace(error2.message, obj.message);
    error2.message = obj.message;
    return error2;
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  return json_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var raw_1;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw)
    return raw_1;
  hasRequiredRaw = 1;
  var bytes2 = requireBytes();
  var debug2 = requireSrc()("body-parser:raw");
  var read = requireRead();
  var typeis = requireTypeIs();
  raw_1 = raw;
  function raw(options) {
    var opts = options || {};
    var inflate = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type2 = opts.type || "application/octet-stream";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    function parse2(buf) {
      return buf;
    }
    return function rawParser(req, res, next) {
      if (req._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      read(req, res, next, parse2, debug2, {
        encoding: null,
        inflate,
        limit: limit2,
        verify
      });
    };
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  return raw_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var text_1;
var hasRequiredText;
function requireText() {
  if (hasRequiredText)
    return text_1;
  hasRequiredText = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var debug2 = requireSrc()("body-parser:text");
  var read = requireRead();
  var typeis = requireTypeIs();
  text_1 = text;
  function text(options) {
    var opts = options || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type2 = opts.type || "text/plain";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    function parse2(buf) {
      return buf;
    }
    return function textParser(req, res, next) {
      if (req._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || defaultCharset;
      read(req, res, next, parse2, debug2, {
        encoding: charset2,
        inflate,
        limit: limit2,
        verify
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  return text_1;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var urlencoded_1;
var hasRequiredUrlencoded$1;
function requireUrlencoded$1() {
  if (hasRequiredUrlencoded$1)
    return urlencoded_1;
  hasRequiredUrlencoded$1 = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var createError = requireHttpErrors();
  var debug2 = requireSrc()("body-parser:urlencoded");
  var deprecate = requireDepd()("body-parser");
  var read = requireRead();
  var typeis = requireTypeIs();
  urlencoded_1 = urlencoded2;
  var parsers = /* @__PURE__ */ Object.create(null);
  function urlencoded2(options) {
    var opts = options || {};
    if (opts.extended === void 0) {
      deprecate("undefined extended: provide extended option");
    }
    var extended = opts.extended !== false;
    var inflate = opts.inflate !== false;
    var limit2 = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type2 = opts.type || "application/x-www-form-urlencoded";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    function parse2(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req, res, next) {
      if (req._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req.body = req.body || {};
      if (!typeis.hasBody(req)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req.headers["content-type"]);
      if (!shouldParse(req)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset2 = getCharset(req) || "utf-8";
      if (charset2 !== "utf-8") {
        debug2("invalid charset");
        next(createError(415, 'unsupported charset "' + charset2.toUpperCase() + '"', {
          charset: charset2,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req, res, next, parse2, debug2, {
        debug: debug2,
        encoding: charset2,
        inflate,
        limit: limit2,
        verify
      });
    };
  }
  function extendedparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug2("parse extended urlencoding");
      return parse2(body, {
        allowPrototypes: true,
        arrayLimit,
        depth: Infinity,
        parameterLimit
      });
    };
  }
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function parameterCount(body, limit2) {
    var count2 = 0;
    var index = 0;
    while ((index = body.indexOf("&", index)) !== -1) {
      count2++;
      index++;
      if (count2 === limit2) {
        return void 0;
      }
    }
    return count2;
  }
  function parser(name) {
    var mod = parsers[name];
    if (mod !== void 0) {
      return mod.parse;
    }
    switch (name) {
      case "qs":
        mod = requireLib$2();
        break;
      case "querystring":
        mod = require$$8;
        break;
    }
    parsers[name] = mod;
    return mod.parse;
  }
  function simpleparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug2("parse urlencoding");
      return parse2(body, void 0, void 0, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  return urlencoded_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredBodyParser;
function requireBodyParser() {
  if (hasRequiredBodyParser)
    return bodyParser.exports;
  hasRequiredBodyParser = 1;
  (function(module2, exports2) {
    var deprecate = requireDepd()("body-parser");
    var parsers = /* @__PURE__ */ Object.create(null);
    exports2 = module2.exports = deprecate.function(
      bodyParser2,
      "bodyParser: use individual json/urlencoded middlewares"
    );
    Object.defineProperty(exports2, "json", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("json")
    });
    Object.defineProperty(exports2, "raw", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("raw")
    });
    Object.defineProperty(exports2, "text", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("text")
    });
    Object.defineProperty(exports2, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: createParserGetter("urlencoded")
    });
    function bodyParser2(options) {
      var opts = Object.create(options || null, {
        type: {
          configurable: true,
          enumerable: true,
          value: void 0,
          writable: true
        }
      });
      var _urlencoded = exports2.urlencoded(opts);
      var _json = exports2.json(opts);
      return function bodyParser3(req, res, next) {
        _json(req, res, function(err) {
          if (err)
            return next(err);
          _urlencoded(req, res, next);
        });
      };
    }
    function createParserGetter(name) {
      return function get2() {
        return loadParser(name);
      };
    }
    function loadParser(parserName) {
      var parser = parsers[parserName];
      if (parser !== void 0) {
        return parser;
      }
      switch (parserName) {
        case "json":
          parser = requireJson();
          break;
        case "raw":
          parser = requireRaw();
          break;
        case "text":
          parser = requireText();
          break;
        case "urlencoded":
          parser = requireUrlencoded$1();
          break;
      }
      return parsers[parserName] = parser;
    }
  })(bodyParser, bodyParser.exports);
  return bodyParser.exports;
}
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var mergeDescriptors;
var hasRequiredMergeDescriptors;
function requireMergeDescriptors() {
  if (hasRequiredMergeDescriptors)
    return mergeDescriptors;
  hasRequiredMergeDescriptors = 1;
  mergeDescriptors = merge2;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function merge2(dest, src2, redefine) {
    if (!dest) {
      throw new TypeError("argument dest is required");
    }
    if (!src2) {
      throw new TypeError("argument src is required");
    }
    if (redefine === void 0) {
      redefine = true;
    }
    Object.getOwnPropertyNames(src2).forEach(function forEachOwnPropertyName(name) {
      if (!redefine && hasOwnProperty2.call(dest, name)) {
        return;
      }
      var descriptor = Object.getOwnPropertyDescriptor(src2, name);
      Object.defineProperty(dest, name, descriptor);
    });
    return dest;
  }
  return mergeDescriptors;
}
var application = { exports: {} };
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl;
var hasRequiredEncodeurl;
function requireEncodeurl() {
  if (hasRequiredEncodeurl)
    return encodeurl;
  hasRequiredEncodeurl = 1;
  encodeurl = encodeUrl;
  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
  var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
  function encodeUrl(url2) {
    return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
  return encodeurl;
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var escapeHtml_1;
var hasRequiredEscapeHtml;
function requireEscapeHtml() {
  if (hasRequiredEscapeHtml)
    return escapeHtml_1;
  hasRequiredEscapeHtml = 1;
  var matchHtmlRegExp = /["'&<>]/;
  escapeHtml_1 = escapeHtml;
  function escapeHtml(string) {
    var str = "" + string;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape2;
    var html = "";
    var index = 0;
    var lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
      switch (str.charCodeAt(index)) {
        case 34:
          escape2 = "&quot;";
          break;
        case 38:
          escape2 = "&amp;";
          break;
        case 39:
          escape2 = "&#39;";
          break;
        case 60:
          escape2 = "&lt;";
          break;
        case 62:
          escape2 = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index) {
        html += str.substring(lastIndex, index);
      }
      lastIndex = index + 1;
      html += escape2;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
  }
  return escapeHtml_1;
}
var parseurl = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredParseurl;
function requireParseurl() {
  if (hasRequiredParseurl)
    return parseurl.exports;
  hasRequiredParseurl = 1;
  var url2 = require$$0$a;
  var parse2 = url2.parse;
  var Url = url2.Url;
  parseurl.exports = parseurl$1;
  parseurl.exports.original = originalurl;
  function parseurl$1(req) {
    var url3 = req.url;
    if (url3 === void 0) {
      return void 0;
    }
    var parsed = req._parsedUrl;
    if (fresh(url3, parsed)) {
      return parsed;
    }
    parsed = fastparse(url3);
    parsed._raw = url3;
    return req._parsedUrl = parsed;
  }
  function originalurl(req) {
    var url3 = req.originalUrl;
    if (typeof url3 !== "string") {
      return parseurl$1(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url3, parsed)) {
      return parsed;
    }
    parsed = fastparse(url3);
    parsed._raw = url3;
    return req._parsedOriginalUrl = parsed;
  }
  function fastparse(str) {
    if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
      return parse2(str);
    }
    var pathname = str;
    var query2 = null;
    var search = null;
    for (var i = 1; i < str.length; i++) {
      switch (str.charCodeAt(i)) {
        case 63:
          if (search === null) {
            pathname = str.substring(0, i);
            query2 = str.substring(i + 1);
            search = str.substring(i);
          }
          break;
        case 9:
        case 10:
        case 12:
        case 13:
        case 32:
        case 35:
        case 160:
        case 65279:
          return parse2(str);
      }
    }
    var url3 = Url !== void 0 ? new Url() : {};
    url3.path = str;
    url3.href = str;
    url3.pathname = pathname;
    if (search !== null) {
      url3.query = query2;
      url3.search = search;
    }
    return url3;
  }
  function fresh(url3, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url3;
  }
  return parseurl.exports;
}
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var finalhandler_1;
var hasRequiredFinalhandler;
function requireFinalhandler() {
  if (hasRequiredFinalhandler)
    return finalhandler_1;
  hasRequiredFinalhandler = 1;
  var debug2 = requireSrc()("finalhandler");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var onFinished2 = requireOnFinished();
  var parseUrl2 = requireParseurl();
  var statuses2 = requireStatuses();
  var unpipe = requireUnpipe();
  var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
  var NEWLINE_REGEXP = /\n/g;
  var defer2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  var isFinished = onFinished2.isFinished;
  function createHtmlDocument(message) {
    var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
  }
  finalhandler_1 = finalhandler;
  function finalhandler(req, res, options) {
    var opts = options || {};
    var env2 = opts.env || process.env.NODE_ENV || "development";
    var onerror = opts.onerror;
    return function(err) {
      var headers;
      var msg;
      var status;
      if (!err && headersSent(res)) {
        debug2("cannot 404 after headers sent");
        return;
      }
      if (err) {
        status = getErrorStatusCode(err);
        if (status === void 0) {
          status = getResponseStatusCode(res);
        } else {
          headers = getErrorHeaders(err);
        }
        msg = getErrorMessage(err, status, env2);
      } else {
        status = 404;
        msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
      }
      debug2("default %s", status);
      if (err && onerror) {
        defer2(onerror, err, req, res);
      }
      if (headersSent(res)) {
        debug2("cannot %d after headers sent", status);
        req.socket.destroy();
        return;
      }
      send2(req, res, status, headers, msg);
    };
  }
  function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== "object") {
      return void 0;
    }
    var headers = /* @__PURE__ */ Object.create(null);
    var keys = Object.keys(err.headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      headers[key] = err.headers[key];
    }
    return headers;
  }
  function getErrorMessage(err, status, env2) {
    var msg;
    if (env2 !== "production") {
      msg = err.stack;
      if (!msg && typeof err.toString === "function") {
        msg = err.toString();
      }
    }
    return msg || statuses2.message[status];
  }
  function getErrorStatusCode(err) {
    if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
      return err.status;
    }
    if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
      return err.statusCode;
    }
    return void 0;
  }
  function getResourceName(req) {
    try {
      return parseUrl2.original(req).pathname;
    } catch (e) {
      return "resource";
    }
  }
  function getResponseStatusCode(res) {
    var status = res.statusCode;
    if (typeof status !== "number" || status < 400 || status > 599) {
      status = 500;
    }
    return status;
  }
  function headersSent(res) {
    return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
  }
  function send2(req, res, status, headers, message) {
    function write() {
      var body = createHtmlDocument(message);
      res.statusCode = status;
      res.statusMessage = statuses2.message[status];
      res.removeHeader("Content-Encoding");
      res.removeHeader("Content-Language");
      res.removeHeader("Content-Range");
      setHeaders(res, headers);
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      res.end(body, "utf8");
    }
    if (isFinished(req)) {
      write();
      return;
    }
    unpipe(req);
    onFinished2(req, write);
    req.resume();
  }
  function setHeaders(res, headers) {
    if (!headers) {
      return;
    }
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
  return finalhandler_1;
}
var router$1 = { exports: {} };
var arrayFlatten_1;
var hasRequiredArrayFlatten;
function requireArrayFlatten() {
  if (hasRequiredArrayFlatten)
    return arrayFlatten_1;
  hasRequiredArrayFlatten = 1;
  arrayFlatten_1 = arrayFlatten;
  function flattenWithDepth(array, result, depth) {
    for (var i = 0; i < array.length; i++) {
      var value = array[i];
      if (depth > 0 && Array.isArray(value)) {
        flattenWithDepth(value, result, depth - 1);
      } else {
        result.push(value);
      }
    }
    return result;
  }
  function flattenForever(array, result) {
    for (var i = 0; i < array.length; i++) {
      var value = array[i];
      if (Array.isArray(value)) {
        flattenForever(value, result);
      } else {
        result.push(value);
      }
    }
    return result;
  }
  function arrayFlatten(array, depth) {
    if (depth == null) {
      return flattenForever(array, []);
    }
    return flattenWithDepth(array, [], depth);
  }
  return arrayFlatten_1;
}
var pathToRegexp;
var hasRequiredPathToRegexp;
function requirePathToRegexp() {
  if (hasRequiredPathToRegexp)
    return pathToRegexp;
  hasRequiredPathToRegexp = 1;
  pathToRegexp = pathtoRegexp;
  var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
  function pathtoRegexp(path2, keys, options) {
    options = options || {};
    keys = keys || [];
    var strict = options.strict;
    var end = options.end !== false;
    var flags = options.sensitive ? "" : "i";
    var extraOffset = 0;
    var keysOffset = keys.length;
    var i = 0;
    var name = 0;
    var m;
    if (path2 instanceof RegExp) {
      while (m = MATCHING_GROUP_REGEXP.exec(path2.source)) {
        keys.push({
          name: name++,
          optional: false,
          offset: m.index
        });
      }
      return path2;
    }
    if (Array.isArray(path2)) {
      path2 = path2.map(function(value) {
        return pathtoRegexp(value, keys, options).source;
      });
      return new RegExp("(?:" + path2.join("|") + ")", flags);
    }
    path2 = ("^" + path2 + (strict ? "" : path2[path2.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match, slash, format2, key, capture, star, optional, offset) {
      slash = slash || "";
      format2 = format2 || "";
      capture = capture || "([^\\/" + format2 + "]+?)";
      optional = optional || "";
      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });
      var result = "" + (optional ? "" : slash) + "(?:" + format2 + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format2 + "].+?)?)" : "") + ")" + optional;
      extraOffset += result.length - match.length;
      return result;
    }).replace(/\*/g, function(star, index2) {
      var len = keys.length;
      while (len-- > keysOffset && keys[len].offset > index2) {
        keys[len].offset += 3;
      }
      return "(.*)";
    });
    while (m = MATCHING_GROUP_REGEXP.exec(path2)) {
      var escapeCount = 0;
      var index = m.index;
      while (path2.charAt(--index) === "\\") {
        escapeCount++;
      }
      if (escapeCount % 2 === 1) {
        continue;
      }
      if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
        keys.splice(keysOffset + i, 0, {
          name: name++,
          // Unnamed matching groups must be consistently linear.
          optional: false,
          offset: m.index
        });
      }
      i++;
    }
    path2 += end ? "$" : path2[path2.length - 1] === "/" ? "" : "(?=\\/|$)";
    return new RegExp(path2, flags);
  }
  return pathToRegexp;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var layer;
var hasRequiredLayer;
function requireLayer() {
  if (hasRequiredLayer)
    return layer;
  hasRequiredLayer = 1;
  var pathRegexp = requirePathToRegexp();
  var debug2 = requireSrc()("express:router:layer");
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  layer = Layer;
  function Layer(path2, options, fn) {
    if (!(this instanceof Layer)) {
      return new Layer(path2, options, fn);
    }
    debug2("new %o", path2);
    var opts = options || {};
    this.handle = fn;
    this.name = fn.name || "<anonymous>";
    this.params = void 0;
    this.path = void 0;
    this.regexp = pathRegexp(path2, this.keys = [], opts);
    this.regexp.fast_star = path2 === "*";
    this.regexp.fast_slash = path2 === "/" && opts.end === false;
  }
  Layer.prototype.handle_error = function handle_error(error2, req, res, next) {
    var fn = this.handle;
    if (fn.length !== 4) {
      return next(error2);
    }
    try {
      fn(error2, req, res, next);
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.handle_request = function handle(req, res, next) {
    var fn = this.handle;
    if (fn.length > 3) {
      return next();
    }
    try {
      fn(req, res, next);
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.match = function match(path2) {
    var match2;
    if (path2 != null) {
      if (this.regexp.fast_slash) {
        this.params = {};
        this.path = "";
        return true;
      }
      if (this.regexp.fast_star) {
        this.params = { "0": decode_param(path2) };
        this.path = path2;
        return true;
      }
      match2 = this.regexp.exec(path2);
    }
    if (!match2) {
      this.params = void 0;
      this.path = void 0;
      return false;
    }
    this.params = {};
    this.path = match2[0];
    var keys = this.keys;
    var params = this.params;
    for (var i = 1; i < match2.length; i++) {
      var key = keys[i - 1];
      var prop = key.name;
      var val = decode_param(match2[i]);
      if (val !== void 0 || !hasOwnProperty2.call(params, prop)) {
        params[prop] = val;
      }
    }
    return true;
  };
  function decode_param(val) {
    if (typeof val !== "string" || val.length === 0) {
      return val;
    }
    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = "Failed to decode param '" + val + "'";
        err.status = err.statusCode = 400;
      }
      throw err;
    }
  }
  return layer;
}
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var methods;
var hasRequiredMethods;
function requireMethods() {
  if (hasRequiredMethods)
    return methods;
  hasRequiredMethods = 1;
  var http3 = require$$7$2;
  methods = getCurrentNodeMethods() || getBasicNodeMethods();
  function getCurrentNodeMethods() {
    return http3.METHODS && http3.METHODS.map(function lowerCaseMethod(method) {
      return method.toLowerCase();
    });
  }
  function getBasicNodeMethods() {
    return [
      "get",
      "post",
      "put",
      "head",
      "delete",
      "options",
      "trace",
      "copy",
      "lock",
      "mkcol",
      "move",
      "purge",
      "propfind",
      "proppatch",
      "unlock",
      "report",
      "mkactivity",
      "checkout",
      "merge",
      "m-search",
      "notify",
      "subscribe",
      "unsubscribe",
      "patch",
      "search",
      "connect"
    ];
  }
  return methods;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute)
    return route;
  hasRequiredRoute = 1;
  var debug2 = requireSrc()("express:router:route");
  var flatten2 = requireArrayFlatten();
  var Layer = requireLayer();
  var methods2 = requireMethods();
  var slice2 = Array.prototype.slice;
  var toString3 = Object.prototype.toString;
  route = Route;
  function Route(path2) {
    this.path = path2;
    this.stack = [];
    debug2("new %o", path2);
    this.methods = {};
  }
  Route.prototype._handles_method = function _handles_method(method) {
    if (this.methods._all) {
      return true;
    }
    var name = method.toLowerCase();
    if (name === "head" && !this.methods["head"]) {
      name = "get";
    }
    return Boolean(this.methods[name]);
  };
  Route.prototype._options = function _options() {
    var methods3 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
      methods3.push("head");
    }
    for (var i = 0; i < methods3.length; i++) {
      methods3[i] = methods3[i].toUpperCase();
    }
    return methods3;
  };
  Route.prototype.dispatch = function dispatch(req, res, done) {
    var idx = 0;
    var stack = this.stack;
    var sync = 0;
    if (stack.length === 0) {
      return done();
    }
    var method = req.method.toLowerCase();
    if (method === "head" && !this.methods["head"]) {
      method = "get";
    }
    req.route = this;
    next();
    function next(err) {
      if (err && err === "route") {
        return done();
      }
      if (err && err === "router") {
        return done(err);
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      var layer2 = stack[idx++];
      if (!layer2) {
        return done(err);
      }
      if (layer2.method && layer2.method !== method) {
        next(err);
      } else if (err) {
        layer2.handle_error(err, req, res, next);
      } else {
        layer2.handle_request(req, res, next);
      }
      sync = 0;
    }
  };
  Route.prototype.all = function all3() {
    var handles = flatten2(slice2.call(arguments));
    for (var i = 0; i < handles.length; i++) {
      var handle = handles[i];
      if (typeof handle !== "function") {
        var type2 = toString3.call(handle);
        var msg = "Route.all() requires a callback function but got a " + type2;
        throw new TypeError(msg);
      }
      var layer2 = Layer("/", {}, handle);
      layer2.method = void 0;
      this.methods._all = true;
      this.stack.push(layer2);
    }
    return this;
  };
  methods2.forEach(function(method) {
    Route.prototype[method] = function() {
      var handles = flatten2(slice2.call(arguments));
      for (var i = 0; i < handles.length; i++) {
        var handle = handles[i];
        if (typeof handle !== "function") {
          var type2 = toString3.call(handle);
          var msg = "Route." + method + "() requires a callback function but got a " + type2;
          throw new Error(msg);
        }
        debug2("%s %o", method, this.path);
        var layer2 = Layer("/", {}, handle);
        layer2.method = method;
        this.methods[method] = true;
        this.stack.push(layer2);
      }
      return this;
    };
  });
  return route;
}
var utilsMerge = { exports: {} };
var hasRequiredUtilsMerge;
function requireUtilsMerge() {
  if (hasRequiredUtilsMerge)
    return utilsMerge.exports;
  hasRequiredUtilsMerge = 1;
  (function(module2, exports2) {
    module2.exports = function(a, b) {
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    };
  })(utilsMerge);
  return utilsMerge.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredRouter$1;
function requireRouter$1() {
  if (hasRequiredRouter$1)
    return router$1.exports;
  hasRequiredRouter$1 = 1;
  var Route = requireRoute();
  var Layer = requireLayer();
  var methods2 = requireMethods();
  var mixin = requireUtilsMerge();
  var debug2 = requireSrc()("express:router");
  var deprecate = requireDepd()("express");
  var flatten2 = requireArrayFlatten();
  var parseUrl2 = requireParseurl();
  var setPrototypeOf = requireSetprototypeof();
  var objectRegExp = /^\[object (\S+)\]$/;
  var slice2 = Array.prototype.slice;
  var toString3 = Object.prototype.toString;
  var proto = router$1.exports = function(options) {
    var opts = options || {};
    function router2(req, res, next) {
      router2.handle(req, res, next);
    }
    setPrototypeOf(router2, proto);
    router2.params = {};
    router2._params = [];
    router2.caseSensitive = opts.caseSensitive;
    router2.mergeParams = opts.mergeParams;
    router2.strict = opts.strict;
    router2.stack = [];
    return router2;
  };
  proto.param = function param(name, fn) {
    if (typeof name === "function") {
      deprecate("router.param(fn): Refactor to use path params");
      this._params.push(name);
      return;
    }
    var params = this._params;
    var len = params.length;
    var ret;
    if (name[0] === ":") {
      deprecate("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
      name = name.slice(1);
    }
    for (var i = 0; i < len; ++i) {
      if (ret = params[i](name, fn)) {
        fn = ret;
      }
    }
    if ("function" !== typeof fn) {
      throw new Error("invalid param() call for " + name + ", got " + fn);
    }
    (this.params[name] = this.params[name] || []).push(fn);
    return this;
  };
  proto.handle = function handle(req, res, out) {
    var self2 = this;
    debug2("dispatching %s %s", req.method, req.url);
    var idx = 0;
    var protohost = getProtohost(req.url) || "";
    var removed = "";
    var slashAdded = false;
    var sync = 0;
    var paramcalled = {};
    var options = [];
    var stack = self2.stack;
    var parentParams = req.params;
    var parentUrl = req.baseUrl || "";
    var done = restore(out, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
      done = wrap2(done, function(old, err) {
        if (err || options.length === 0)
          return old(err);
        sendOptionsResponse(res, options, old);
      });
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
      var layerError = err === "route" ? null : err;
      if (slashAdded) {
        req.url = req.url.slice(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.baseUrl = parentUrl;
        req.url = protohost + removed + req.url.slice(protohost.length);
        removed = "";
      }
      if (layerError === "router") {
        setImmediate(done, null);
        return;
      }
      if (idx >= stack.length) {
        setImmediate(done, layerError);
        return;
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      var path2 = getPathname(req);
      if (path2 == null) {
        return done(layerError);
      }
      var layer2;
      var match;
      var route2;
      while (match !== true && idx < stack.length) {
        layer2 = stack[idx++];
        match = matchLayer(layer2, path2);
        route2 = layer2.route;
        if (typeof match !== "boolean") {
          layerError = layerError || match;
        }
        if (match !== true) {
          continue;
        }
        if (!route2) {
          continue;
        }
        if (layerError) {
          match = false;
          continue;
        }
        var method = req.method;
        var has_method = route2._handles_method(method);
        if (!has_method && method === "OPTIONS") {
          appendMethods(options, route2._options());
        }
        if (!has_method && method !== "HEAD") {
          match = false;
        }
      }
      if (match !== true) {
        return done(layerError);
      }
      if (route2) {
        req.route = route2;
      }
      req.params = self2.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
      var layerPath = layer2.path;
      self2.process_params(layer2, paramcalled, req, res, function(err2) {
        if (err2) {
          next(layerError || err2);
        } else if (route2) {
          layer2.handle_request(req, res, next);
        } else {
          trim_prefix(layer2, layerError, layerPath, path2);
        }
        sync = 0;
      });
    }
    function trim_prefix(layer2, layerError, layerPath, path2) {
      if (layerPath.length !== 0) {
        if (layerPath !== path2.slice(0, layerPath.length)) {
          next(layerError);
          return;
        }
        var c = path2[layerPath.length];
        if (c && c !== "/" && c !== ".")
          return next(layerError);
        debug2("trim prefix (%s) from url %s", layerPath, req.url);
        removed = layerPath;
        req.url = protohost + req.url.slice(protohost.length + removed.length);
        if (!protohost && req.url[0] !== "/") {
          req.url = "/" + req.url;
          slashAdded = true;
        }
        req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
      }
      debug2("%s %s : %s", layer2.name, layerPath, req.originalUrl);
      if (layerError) {
        layer2.handle_error(layerError, req, res, next);
      } else {
        layer2.handle_request(req, res, next);
      }
    }
  };
  proto.process_params = function process_params(layer2, called, req, res, done) {
    var params = this.params;
    var keys = layer2.keys;
    if (!keys || keys.length === 0) {
      return done();
    }
    var i = 0;
    var name;
    var paramIndex = 0;
    var key;
    var paramVal;
    var paramCallbacks;
    var paramCalled;
    function param(err) {
      if (err) {
        return done(err);
      }
      if (i >= keys.length) {
        return done();
      }
      paramIndex = 0;
      key = keys[i++];
      name = key.name;
      paramVal = req.params[name];
      paramCallbacks = params[name];
      paramCalled = called[name];
      if (paramVal === void 0 || !paramCallbacks) {
        return param();
      }
      if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
        req.params[name] = paramCalled.value;
        return param(paramCalled.error);
      }
      called[name] = paramCalled = {
        error: null,
        match: paramVal,
        value: paramVal
      };
      paramCallback();
    }
    function paramCallback(err) {
      var fn = paramCallbacks[paramIndex++];
      paramCalled.value = req.params[key.name];
      if (err) {
        paramCalled.error = err;
        param(err);
        return;
      }
      if (!fn)
        return param();
      try {
        fn(req, res, paramCallback, paramVal, key.name);
      } catch (e) {
        paramCallback(e);
      }
    }
    param();
  };
  proto.use = function use(fn) {
    var offset = 0;
    var path2 = "/";
    if (typeof fn !== "function") {
      var arg = fn;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path2 = fn;
      }
    }
    var callbacks = flatten2(slice2.call(arguments, offset));
    if (callbacks.length === 0) {
      throw new TypeError("Router.use() requires a middleware function");
    }
    for (var i = 0; i < callbacks.length; i++) {
      var fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
      }
      debug2("use %o %s", path2, fn.name || "<anonymous>");
      var layer2 = new Layer(path2, {
        sensitive: this.caseSensitive,
        strict: false,
        end: false
      }, fn);
      layer2.route = void 0;
      this.stack.push(layer2);
    }
    return this;
  };
  proto.route = function route2(path2) {
    var route3 = new Route(path2);
    var layer2 = new Layer(path2, {
      sensitive: this.caseSensitive,
      strict: this.strict,
      end: true
    }, route3.dispatch.bind(route3));
    layer2.route = route3;
    this.stack.push(layer2);
    return route3;
  };
  methods2.concat("all").forEach(function(method) {
    proto[method] = function(path2) {
      var route2 = this.route(path2);
      route2[method].apply(route2, slice2.call(arguments, 1));
      return this;
    };
  });
  function appendMethods(list, addition) {
    for (var i = 0; i < addition.length; i++) {
      var method = addition[i];
      if (list.indexOf(method) === -1) {
        list.push(method);
      }
    }
  }
  function getPathname(req) {
    try {
      return parseUrl2(req).pathname;
    } catch (err) {
      return void 0;
    }
  }
  function getProtohost(url2) {
    if (typeof url2 !== "string" || url2.length === 0 || url2[0] === "/") {
      return void 0;
    }
    var searchIndex = url2.indexOf("?");
    var pathLength = searchIndex !== -1 ? searchIndex : url2.length;
    var fqdnIndex = url2.slice(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url2.substring(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
  }
  function gettype(obj) {
    var type2 = typeof obj;
    if (type2 !== "object") {
      return type2;
    }
    return toString3.call(obj).replace(objectRegExp, "$1");
  }
  function matchLayer(layer2, path2) {
    try {
      return layer2.match(path2);
    } catch (err) {
      return err;
    }
  }
  function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
      return params;
    }
    var obj = mixin({}, parent);
    if (!(0 in params) || !(0 in parent)) {
      return mixin(obj, params);
    }
    var i = 0;
    var o = 0;
    while (i in params) {
      i++;
    }
    while (o in parent) {
      o++;
    }
    for (i--; i >= 0; i--) {
      params[i + o] = params[i];
      if (i < o) {
        delete params[i];
      }
    }
    return mixin(obj, params);
  }
  function restore(fn, obj) {
    var props = new Array(arguments.length - 2);
    var vals = new Array(arguments.length - 2);
    for (var i = 0; i < props.length; i++) {
      props[i] = arguments[i + 2];
      vals[i] = obj[props[i]];
    }
    return function() {
      for (var i2 = 0; i2 < props.length; i2++) {
        obj[props[i2]] = vals[i2];
      }
      return fn.apply(this, arguments);
    };
  }
  function sendOptionsResponse(res, options, next) {
    try {
      var body = options.join(",");
      res.set("Allow", body);
      res.send(body);
    } catch (err) {
      next(err);
    }
  }
  function wrap2(old, fn) {
    return function proxy() {
      var args2 = new Array(arguments.length + 1);
      args2[0] = old;
      for (var i = 0, len = arguments.length; i < len; i++) {
        args2[i + 1] = arguments[i];
      }
      fn.apply(this, args2);
    };
  }
  return router$1.exports;
}
var init = {};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredInit;
function requireInit() {
  if (hasRequiredInit)
    return init;
  hasRequiredInit = 1;
  var setPrototypeOf = requireSetprototypeof();
  init.init = function(app2) {
    return function expressInit(req, res, next) {
      if (app2.enabled("x-powered-by"))
        res.setHeader("X-Powered-By", "Express");
      req.res = res;
      res.req = req;
      req.next = next;
      setPrototypeOf(req, app2.request);
      setPrototypeOf(res, app2.response);
      res.locals = res.locals || /* @__PURE__ */ Object.create(null);
      next();
    };
  };
  return init;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var query;
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery)
    return query;
  hasRequiredQuery = 1;
  var merge2 = requireUtilsMerge();
  var parseUrl2 = requireParseurl();
  var qs = requireLib$2();
  query = function query2(options) {
    var opts = merge2({}, options);
    var queryparse = qs.parse;
    if (typeof options === "function") {
      queryparse = options;
      opts = void 0;
    }
    if (opts !== void 0 && opts.allowPrototypes === void 0) {
      opts.allowPrototypes = true;
    }
    return function query3(req, res, next) {
      if (!req.query) {
        var val = parseUrl2(req).query;
        req.query = queryparse(val, opts);
      }
      next();
    };
  };
  return query;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var view;
var hasRequiredView;
function requireView() {
  if (hasRequiredView)
    return view;
  hasRequiredView = 1;
  var debug2 = requireSrc()("express:view");
  var path2 = require$$0$6;
  var fs2 = require$$1$3;
  var dirname = path2.dirname;
  var basename = path2.basename;
  var extname = path2.extname;
  var join = path2.join;
  var resolve2 = path2.resolve;
  view = View;
  function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
      throw new Error("No default engine was specified and no extension was provided.");
    }
    var fileName = name;
    if (!this.ext) {
      this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
      fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
      var mod = this.ext.slice(1);
      debug2('require "%s"', mod);
      var fn = commonjsRequire(mod).__express;
      if (typeof fn !== "function") {
        throw new Error('Module "' + mod + '" does not provide a view engine.');
      }
      opts.engines[this.ext] = fn;
    }
    this.engine = opts.engines[this.ext];
    this.path = this.lookup(fileName);
  }
  View.prototype.lookup = function lookup(name) {
    var path3;
    var roots = [].concat(this.root);
    debug2('lookup "%s"', name);
    for (var i = 0; i < roots.length && !path3; i++) {
      var root = roots[i];
      var loc = resolve2(root, name);
      var dir = dirname(loc);
      var file2 = basename(loc);
      path3 = this.resolve(dir, file2);
    }
    return path3;
  };
  View.prototype.render = function render(options, callback) {
    debug2('render "%s"', this.path);
    this.engine(this.path, options, callback);
  };
  View.prototype.resolve = function resolve3(dir, file2) {
    var ext = this.ext;
    var path3 = join(dir, file2);
    var stat = tryStat(path3);
    if (stat && stat.isFile()) {
      return path3;
    }
    path3 = join(dir, basename(file2, ext), "index" + ext);
    stat = tryStat(path3);
    if (stat && stat.isFile()) {
      return path3;
    }
  };
  function tryStat(path3) {
    debug2('stat "%s"', path3);
    try {
      return fs2.statSync(path3);
    } catch (e) {
      return void 0;
    }
  }
  return view;
}
var utils$5 = {};
var safeBuffer$2 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$2;
function requireSafeBuffer$2() {
  if (hasRequiredSafeBuffer$2)
    return safeBuffer$2.exports;
  hasRequiredSafeBuffer$2 = 1;
  (function(module2, exports2) {
    var buffer2 = require$$0$9;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer$2, safeBuffer$2.exports);
  return safeBuffer$2.exports;
}
var contentDisposition = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentDisposition;
function requireContentDisposition() {
  if (hasRequiredContentDisposition)
    return contentDisposition.exports;
  hasRequiredContentDisposition = 1;
  contentDisposition.exports = contentDisposition$1;
  contentDisposition.exports.parse = parse2;
  var basename = require$$0$6.basename;
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
  var QESC_REGEXP = /\\([\u0000-\u007f])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function contentDisposition$1(filename, options) {
    var opts = options || {};
    var type2 = opts.type || "attachment";
    var params = createparams(filename, opts.fallback);
    return format2(new ContentDisposition(type2, params));
  }
  function createparams(filename, fallback) {
    if (filename === void 0) {
      return;
    }
    var params = {};
    if (typeof filename !== "string") {
      throw new TypeError("filename must be a string");
    }
    if (fallback === void 0) {
      fallback = true;
    }
    if (typeof fallback !== "string" && typeof fallback !== "boolean") {
      throw new TypeError("fallback must be a string or boolean");
    }
    if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError("fallback must be ISO-8859-1 string");
    }
    var name = basename(filename);
    var isQuotedString = TEXT_REGEXP.test(name);
    var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
      params["filename*"] = name;
    }
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name;
    }
    return params;
  }
  function format2(obj) {
    var parameters = obj.parameters;
    var type2 = obj.type;
    if (!type2 || typeof type2 !== "string" || !TOKEN_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    var string = String(type2).toLowerCase();
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
        string += "; " + param + "=" + val;
      }
    }
    return string;
  }
  function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
      throw new TypeError("invalid extended field value");
    }
    var charset2 = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset2) {
      case "iso-8859-1":
        value = getlatin1(binary);
        break;
      case "utf-8":
        value = Buffer2.from(binary, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return value;
  }
  function getlatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
  }
  function parse2(string) {
    if (!string || typeof string !== "string") {
      throw new TypeError("argument string is required");
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string);
    if (!match) {
      throw new TypeError("invalid type format");
    }
    var index = match[0].length;
    var type2 = match[1].toLowerCase();
    var key;
    var names2 = [];
    var params = {};
    var value;
    index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
    while (match = PARAM_REGEXP.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (names2.indexOf(key) !== -1) {
        throw new TypeError("invalid duplicate parameter");
      }
      names2.push(key);
      if (key.indexOf("*") + 1 === key.length) {
        key = key.slice(0, -1);
        value = decodefield(value);
        params[key] = value;
        continue;
      }
      if (typeof params[key] === "string") {
        continue;
      }
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    return new ContentDisposition(type2, params);
  }
  function pdecode(str, hex) {
    return String.fromCharCode(parseInt(hex, 16));
  }
  function pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
  }
  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ustring(val) {
    var str = String(val);
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
  }
  function ContentDisposition(type2, parameters) {
    this.type = type2;
    this.parameters = parameters;
  }
  return contentDisposition.exports;
}
var send = { exports: {} };
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var etag_1;
var hasRequiredEtag;
function requireEtag() {
  if (hasRequiredEtag)
    return etag_1;
  hasRequiredEtag = 1;
  etag_1 = etag;
  var crypto2 = require$$0$5;
  var Stats = require$$1$3.Stats;
  var toString3 = Object.prototype.toString;
  function entitytag(entity) {
    if (entity.length === 0) {
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    var hash = crypto2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
    var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
    return '"' + len.toString(16) + "-" + hash + '"';
  }
  function etag(entity, options) {
    if (entity == null) {
      throw new TypeError("argument entity is required");
    }
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
      throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
    }
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? "W/" + tag : tag;
  }
  function isstats(obj) {
    if (typeof Stats === "function" && obj instanceof Stats) {
      return true;
    }
    return obj && typeof obj === "object" && "ctime" in obj && toString3.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString3.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
  }
  function stattag(stat) {
    var mtime = stat.mtime.getTime().toString(16);
    var size = stat.size.toString(16);
    return '"' + size + "-" + mtime + '"';
  }
  return etag_1;
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var fresh_1;
var hasRequiredFresh;
function requireFresh() {
  if (hasRequiredFresh)
    return fresh_1;
  hasRequiredFresh = 1;
  var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
  fresh_1 = fresh;
  function fresh(reqHeaders, resHeaders) {
    var modifiedSince = reqHeaders["if-modified-since"];
    var noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
      return false;
    }
    var cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
      return false;
    }
    if (noneMatch && noneMatch !== "*") {
      var etag = resHeaders["etag"];
      if (!etag) {
        return false;
      }
      var etagStale = true;
      var matches = parseTokenList(noneMatch);
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (match === etag || match === "W/" + etag || "W/" + match === etag) {
          etagStale = false;
          break;
        }
      }
      if (etagStale) {
        return false;
      }
    }
    if (modifiedSince) {
      var lastModified = resHeaders["last-modified"];
      var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
      if (modifiedStale) {
        return false;
      }
    }
    return true;
  }
  function parseHttpDate(date) {
    var timestamp2 = date && Date.parse(date);
    return typeof timestamp2 === "number" ? timestamp2 : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
  return fresh_1;
}
const require$$2 = {
  "application/andrew-inset": [
    "ez"
  ],
  "application/applixware": [
    "aw"
  ],
  "application/atom+xml": [
    "atom"
  ],
  "application/atomcat+xml": [
    "atomcat"
  ],
  "application/atomsvc+xml": [
    "atomsvc"
  ],
  "application/bdoc": [
    "bdoc"
  ],
  "application/ccxml+xml": [
    "ccxml"
  ],
  "application/cdmi-capability": [
    "cdmia"
  ],
  "application/cdmi-container": [
    "cdmic"
  ],
  "application/cdmi-domain": [
    "cdmid"
  ],
  "application/cdmi-object": [
    "cdmio"
  ],
  "application/cdmi-queue": [
    "cdmiq"
  ],
  "application/cu-seeme": [
    "cu"
  ],
  "application/dash+xml": [
    "mpd"
  ],
  "application/davmount+xml": [
    "davmount"
  ],
  "application/docbook+xml": [
    "dbk"
  ],
  "application/dssc+der": [
    "dssc"
  ],
  "application/dssc+xml": [
    "xdssc"
  ],
  "application/ecmascript": [
    "ecma"
  ],
  "application/emma+xml": [
    "emma"
  ],
  "application/epub+zip": [
    "epub"
  ],
  "application/exi": [
    "exi"
  ],
  "application/font-tdpfr": [
    "pfr"
  ],
  "application/font-woff": [],
  "application/font-woff2": [],
  "application/geo+json": [
    "geojson"
  ],
  "application/gml+xml": [
    "gml"
  ],
  "application/gpx+xml": [
    "gpx"
  ],
  "application/gxf": [
    "gxf"
  ],
  "application/gzip": [
    "gz"
  ],
  "application/hyperstudio": [
    "stk"
  ],
  "application/inkml+xml": [
    "ink",
    "inkml"
  ],
  "application/ipfix": [
    "ipfix"
  ],
  "application/java-archive": [
    "jar",
    "war",
    "ear"
  ],
  "application/java-serialized-object": [
    "ser"
  ],
  "application/java-vm": [
    "class"
  ],
  "application/javascript": [
    "js",
    "mjs"
  ],
  "application/json": [
    "json",
    "map"
  ],
  "application/json5": [
    "json5"
  ],
  "application/jsonml+json": [
    "jsonml"
  ],
  "application/ld+json": [
    "jsonld"
  ],
  "application/lost+xml": [
    "lostxml"
  ],
  "application/mac-binhex40": [
    "hqx"
  ],
  "application/mac-compactpro": [
    "cpt"
  ],
  "application/mads+xml": [
    "mads"
  ],
  "application/manifest+json": [
    "webmanifest"
  ],
  "application/marc": [
    "mrc"
  ],
  "application/marcxml+xml": [
    "mrcx"
  ],
  "application/mathematica": [
    "ma",
    "nb",
    "mb"
  ],
  "application/mathml+xml": [
    "mathml"
  ],
  "application/mbox": [
    "mbox"
  ],
  "application/mediaservercontrol+xml": [
    "mscml"
  ],
  "application/metalink+xml": [
    "metalink"
  ],
  "application/metalink4+xml": [
    "meta4"
  ],
  "application/mets+xml": [
    "mets"
  ],
  "application/mods+xml": [
    "mods"
  ],
  "application/mp21": [
    "m21",
    "mp21"
  ],
  "application/mp4": [
    "mp4s",
    "m4p"
  ],
  "application/msword": [
    "doc",
    "dot"
  ],
  "application/mxf": [
    "mxf"
  ],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer"
  ],
  "application/oda": [
    "oda"
  ],
  "application/oebps-package+xml": [
    "opf"
  ],
  "application/ogg": [
    "ogx"
  ],
  "application/omdoc+xml": [
    "omdoc"
  ],
  "application/onenote": [
    "onetoc",
    "onetoc2",
    "onetmp",
    "onepkg"
  ],
  "application/oxps": [
    "oxps"
  ],
  "application/patch-ops-error+xml": [
    "xer"
  ],
  "application/pdf": [
    "pdf"
  ],
  "application/pgp-encrypted": [
    "pgp"
  ],
  "application/pgp-signature": [
    "asc",
    "sig"
  ],
  "application/pics-rules": [
    "prf"
  ],
  "application/pkcs10": [
    "p10"
  ],
  "application/pkcs7-mime": [
    "p7m",
    "p7c"
  ],
  "application/pkcs7-signature": [
    "p7s"
  ],
  "application/pkcs8": [
    "p8"
  ],
  "application/pkix-attr-cert": [
    "ac"
  ],
  "application/pkix-cert": [
    "cer"
  ],
  "application/pkix-crl": [
    "crl"
  ],
  "application/pkix-pkipath": [
    "pkipath"
  ],
  "application/pkixcmp": [
    "pki"
  ],
  "application/pls+xml": [
    "pls"
  ],
  "application/postscript": [
    "ai",
    "eps",
    "ps"
  ],
  "application/prs.cww": [
    "cww"
  ],
  "application/pskc+xml": [
    "pskcxml"
  ],
  "application/raml+yaml": [
    "raml"
  ],
  "application/rdf+xml": [
    "rdf"
  ],
  "application/reginfo+xml": [
    "rif"
  ],
  "application/relax-ng-compact-syntax": [
    "rnc"
  ],
  "application/resource-lists+xml": [
    "rl"
  ],
  "application/resource-lists-diff+xml": [
    "rld"
  ],
  "application/rls-services+xml": [
    "rs"
  ],
  "application/rpki-ghostbusters": [
    "gbr"
  ],
  "application/rpki-manifest": [
    "mft"
  ],
  "application/rpki-roa": [
    "roa"
  ],
  "application/rsd+xml": [
    "rsd"
  ],
  "application/rss+xml": [
    "rss"
  ],
  "application/rtf": [
    "rtf"
  ],
  "application/sbml+xml": [
    "sbml"
  ],
  "application/scvp-cv-request": [
    "scq"
  ],
  "application/scvp-cv-response": [
    "scs"
  ],
  "application/scvp-vp-request": [
    "spq"
  ],
  "application/scvp-vp-response": [
    "spp"
  ],
  "application/sdp": [
    "sdp"
  ],
  "application/set-payment-initiation": [
    "setpay"
  ],
  "application/set-registration-initiation": [
    "setreg"
  ],
  "application/shf+xml": [
    "shf"
  ],
  "application/smil+xml": [
    "smi",
    "smil"
  ],
  "application/sparql-query": [
    "rq"
  ],
  "application/sparql-results+xml": [
    "srx"
  ],
  "application/srgs": [
    "gram"
  ],
  "application/srgs+xml": [
    "grxml"
  ],
  "application/sru+xml": [
    "sru"
  ],
  "application/ssdl+xml": [
    "ssdl"
  ],
  "application/ssml+xml": [
    "ssml"
  ],
  "application/tei+xml": [
    "tei",
    "teicorpus"
  ],
  "application/thraud+xml": [
    "tfi"
  ],
  "application/timestamped-data": [
    "tsd"
  ],
  "application/vnd.3gpp.pic-bw-large": [
    "plb"
  ],
  "application/vnd.3gpp.pic-bw-small": [
    "psb"
  ],
  "application/vnd.3gpp.pic-bw-var": [
    "pvb"
  ],
  "application/vnd.3gpp2.tcap": [
    "tcap"
  ],
  "application/vnd.3m.post-it-notes": [
    "pwn"
  ],
  "application/vnd.accpac.simply.aso": [
    "aso"
  ],
  "application/vnd.accpac.simply.imp": [
    "imp"
  ],
  "application/vnd.acucobol": [
    "acu"
  ],
  "application/vnd.acucorp": [
    "atc",
    "acutc"
  ],
  "application/vnd.adobe.air-application-installer-package+zip": [
    "air"
  ],
  "application/vnd.adobe.formscentral.fcdt": [
    "fcdt"
  ],
  "application/vnd.adobe.fxp": [
    "fxp",
    "fxpl"
  ],
  "application/vnd.adobe.xdp+xml": [
    "xdp"
  ],
  "application/vnd.adobe.xfdf": [
    "xfdf"
  ],
  "application/vnd.ahead.space": [
    "ahead"
  ],
  "application/vnd.airzip.filesecure.azf": [
    "azf"
  ],
  "application/vnd.airzip.filesecure.azs": [
    "azs"
  ],
  "application/vnd.amazon.ebook": [
    "azw"
  ],
  "application/vnd.americandynamics.acc": [
    "acc"
  ],
  "application/vnd.amiga.ami": [
    "ami"
  ],
  "application/vnd.android.package-archive": [
    "apk"
  ],
  "application/vnd.anser-web-certificate-issue-initiation": [
    "cii"
  ],
  "application/vnd.anser-web-funds-transfer-initiation": [
    "fti"
  ],
  "application/vnd.antix.game-component": [
    "atx"
  ],
  "application/vnd.apple.installer+xml": [
    "mpkg"
  ],
  "application/vnd.apple.mpegurl": [
    "m3u8"
  ],
  "application/vnd.apple.pkpass": [
    "pkpass"
  ],
  "application/vnd.aristanetworks.swi": [
    "swi"
  ],
  "application/vnd.astraea-software.iota": [
    "iota"
  ],
  "application/vnd.audiograph": [
    "aep"
  ],
  "application/vnd.blueice.multipass": [
    "mpm"
  ],
  "application/vnd.bmi": [
    "bmi"
  ],
  "application/vnd.businessobjects": [
    "rep"
  ],
  "application/vnd.chemdraw+xml": [
    "cdxml"
  ],
  "application/vnd.chipnuts.karaoke-mmd": [
    "mmd"
  ],
  "application/vnd.cinderella": [
    "cdy"
  ],
  "application/vnd.claymore": [
    "cla"
  ],
  "application/vnd.cloanto.rp9": [
    "rp9"
  ],
  "application/vnd.clonk.c4group": [
    "c4g",
    "c4d",
    "c4f",
    "c4p",
    "c4u"
  ],
  "application/vnd.cluetrust.cartomobile-config": [
    "c11amc"
  ],
  "application/vnd.cluetrust.cartomobile-config-pkg": [
    "c11amz"
  ],
  "application/vnd.commonspace": [
    "csp"
  ],
  "application/vnd.contact.cmsg": [
    "cdbcmsg"
  ],
  "application/vnd.cosmocaller": [
    "cmc"
  ],
  "application/vnd.crick.clicker": [
    "clkx"
  ],
  "application/vnd.crick.clicker.keyboard": [
    "clkk"
  ],
  "application/vnd.crick.clicker.palette": [
    "clkp"
  ],
  "application/vnd.crick.clicker.template": [
    "clkt"
  ],
  "application/vnd.crick.clicker.wordbank": [
    "clkw"
  ],
  "application/vnd.criticaltools.wbs+xml": [
    "wbs"
  ],
  "application/vnd.ctc-posml": [
    "pml"
  ],
  "application/vnd.cups-ppd": [
    "ppd"
  ],
  "application/vnd.curl.car": [
    "car"
  ],
  "application/vnd.curl.pcurl": [
    "pcurl"
  ],
  "application/vnd.dart": [
    "dart"
  ],
  "application/vnd.data-vision.rdz": [
    "rdz"
  ],
  "application/vnd.dece.data": [
    "uvf",
    "uvvf",
    "uvd",
    "uvvd"
  ],
  "application/vnd.dece.ttml+xml": [
    "uvt",
    "uvvt"
  ],
  "application/vnd.dece.unspecified": [
    "uvx",
    "uvvx"
  ],
  "application/vnd.dece.zip": [
    "uvz",
    "uvvz"
  ],
  "application/vnd.denovo.fcselayout-link": [
    "fe_launch"
  ],
  "application/vnd.dna": [
    "dna"
  ],
  "application/vnd.dolby.mlp": [
    "mlp"
  ],
  "application/vnd.dpgraph": [
    "dpg"
  ],
  "application/vnd.dreamfactory": [
    "dfac"
  ],
  "application/vnd.ds-keypoint": [
    "kpxx"
  ],
  "application/vnd.dvb.ait": [
    "ait"
  ],
  "application/vnd.dvb.service": [
    "svc"
  ],
  "application/vnd.dynageo": [
    "geo"
  ],
  "application/vnd.ecowin.chart": [
    "mag"
  ],
  "application/vnd.enliven": [
    "nml"
  ],
  "application/vnd.epson.esf": [
    "esf"
  ],
  "application/vnd.epson.msf": [
    "msf"
  ],
  "application/vnd.epson.quickanime": [
    "qam"
  ],
  "application/vnd.epson.salt": [
    "slt"
  ],
  "application/vnd.epson.ssf": [
    "ssf"
  ],
  "application/vnd.eszigno3+xml": [
    "es3",
    "et3"
  ],
  "application/vnd.ezpix-album": [
    "ez2"
  ],
  "application/vnd.ezpix-package": [
    "ez3"
  ],
  "application/vnd.fdf": [
    "fdf"
  ],
  "application/vnd.fdsn.mseed": [
    "mseed"
  ],
  "application/vnd.fdsn.seed": [
    "seed",
    "dataless"
  ],
  "application/vnd.flographit": [
    "gph"
  ],
  "application/vnd.fluxtime.clip": [
    "ftc"
  ],
  "application/vnd.framemaker": [
    "fm",
    "frame",
    "maker",
    "book"
  ],
  "application/vnd.frogans.fnc": [
    "fnc"
  ],
  "application/vnd.frogans.ltf": [
    "ltf"
  ],
  "application/vnd.fsc.weblaunch": [
    "fsc"
  ],
  "application/vnd.fujitsu.oasys": [
    "oas"
  ],
  "application/vnd.fujitsu.oasys2": [
    "oa2"
  ],
  "application/vnd.fujitsu.oasys3": [
    "oa3"
  ],
  "application/vnd.fujitsu.oasysgp": [
    "fg5"
  ],
  "application/vnd.fujitsu.oasysprs": [
    "bh2"
  ],
  "application/vnd.fujixerox.ddd": [
    "ddd"
  ],
  "application/vnd.fujixerox.docuworks": [
    "xdw"
  ],
  "application/vnd.fujixerox.docuworks.binder": [
    "xbd"
  ],
  "application/vnd.fuzzysheet": [
    "fzs"
  ],
  "application/vnd.genomatix.tuxedo": [
    "txd"
  ],
  "application/vnd.geogebra.file": [
    "ggb"
  ],
  "application/vnd.geogebra.tool": [
    "ggt"
  ],
  "application/vnd.geometry-explorer": [
    "gex",
    "gre"
  ],
  "application/vnd.geonext": [
    "gxt"
  ],
  "application/vnd.geoplan": [
    "g2w"
  ],
  "application/vnd.geospace": [
    "g3w"
  ],
  "application/vnd.gmx": [
    "gmx"
  ],
  "application/vnd.google-apps.document": [
    "gdoc"
  ],
  "application/vnd.google-apps.presentation": [
    "gslides"
  ],
  "application/vnd.google-apps.spreadsheet": [
    "gsheet"
  ],
  "application/vnd.google-earth.kml+xml": [
    "kml"
  ],
  "application/vnd.google-earth.kmz": [
    "kmz"
  ],
  "application/vnd.grafeq": [
    "gqf",
    "gqs"
  ],
  "application/vnd.groove-account": [
    "gac"
  ],
  "application/vnd.groove-help": [
    "ghf"
  ],
  "application/vnd.groove-identity-message": [
    "gim"
  ],
  "application/vnd.groove-injector": [
    "grv"
  ],
  "application/vnd.groove-tool-message": [
    "gtm"
  ],
  "application/vnd.groove-tool-template": [
    "tpl"
  ],
  "application/vnd.groove-vcard": [
    "vcg"
  ],
  "application/vnd.hal+xml": [
    "hal"
  ],
  "application/vnd.handheld-entertainment+xml": [
    "zmm"
  ],
  "application/vnd.hbci": [
    "hbci"
  ],
  "application/vnd.hhe.lesson-player": [
    "les"
  ],
  "application/vnd.hp-hpgl": [
    "hpgl"
  ],
  "application/vnd.hp-hpid": [
    "hpid"
  ],
  "application/vnd.hp-hps": [
    "hps"
  ],
  "application/vnd.hp-jlyt": [
    "jlt"
  ],
  "application/vnd.hp-pcl": [
    "pcl"
  ],
  "application/vnd.hp-pclxl": [
    "pclxl"
  ],
  "application/vnd.hydrostatix.sof-data": [
    "sfd-hdstx"
  ],
  "application/vnd.ibm.minipay": [
    "mpy"
  ],
  "application/vnd.ibm.modcap": [
    "afp",
    "listafp",
    "list3820"
  ],
  "application/vnd.ibm.rights-management": [
    "irm"
  ],
  "application/vnd.ibm.secure-container": [
    "sc"
  ],
  "application/vnd.iccprofile": [
    "icc",
    "icm"
  ],
  "application/vnd.igloader": [
    "igl"
  ],
  "application/vnd.immervision-ivp": [
    "ivp"
  ],
  "application/vnd.immervision-ivu": [
    "ivu"
  ],
  "application/vnd.insors.igm": [
    "igm"
  ],
  "application/vnd.intercon.formnet": [
    "xpw",
    "xpx"
  ],
  "application/vnd.intergeo": [
    "i2g"
  ],
  "application/vnd.intu.qbo": [
    "qbo"
  ],
  "application/vnd.intu.qfx": [
    "qfx"
  ],
  "application/vnd.ipunplugged.rcprofile": [
    "rcprofile"
  ],
  "application/vnd.irepository.package+xml": [
    "irp"
  ],
  "application/vnd.is-xpr": [
    "xpr"
  ],
  "application/vnd.isac.fcs": [
    "fcs"
  ],
  "application/vnd.jam": [
    "jam"
  ],
  "application/vnd.jcp.javame.midlet-rms": [
    "rms"
  ],
  "application/vnd.jisp": [
    "jisp"
  ],
  "application/vnd.joost.joda-archive": [
    "joda"
  ],
  "application/vnd.kahootz": [
    "ktz",
    "ktr"
  ],
  "application/vnd.kde.karbon": [
    "karbon"
  ],
  "application/vnd.kde.kchart": [
    "chrt"
  ],
  "application/vnd.kde.kformula": [
    "kfo"
  ],
  "application/vnd.kde.kivio": [
    "flw"
  ],
  "application/vnd.kde.kontour": [
    "kon"
  ],
  "application/vnd.kde.kpresenter": [
    "kpr",
    "kpt"
  ],
  "application/vnd.kde.kspread": [
    "ksp"
  ],
  "application/vnd.kde.kword": [
    "kwd",
    "kwt"
  ],
  "application/vnd.kenameaapp": [
    "htke"
  ],
  "application/vnd.kidspiration": [
    "kia"
  ],
  "application/vnd.kinar": [
    "kne",
    "knp"
  ],
  "application/vnd.koan": [
    "skp",
    "skd",
    "skt",
    "skm"
  ],
  "application/vnd.kodak-descriptor": [
    "sse"
  ],
  "application/vnd.las.las+xml": [
    "lasxml"
  ],
  "application/vnd.llamagraphics.life-balance.desktop": [
    "lbd"
  ],
  "application/vnd.llamagraphics.life-balance.exchange+xml": [
    "lbe"
  ],
  "application/vnd.lotus-1-2-3": [
    "123"
  ],
  "application/vnd.lotus-approach": [
    "apr"
  ],
  "application/vnd.lotus-freelance": [
    "pre"
  ],
  "application/vnd.lotus-notes": [
    "nsf"
  ],
  "application/vnd.lotus-organizer": [
    "org"
  ],
  "application/vnd.lotus-screencam": [
    "scm"
  ],
  "application/vnd.lotus-wordpro": [
    "lwp"
  ],
  "application/vnd.macports.portpkg": [
    "portpkg"
  ],
  "application/vnd.mcd": [
    "mcd"
  ],
  "application/vnd.medcalcdata": [
    "mc1"
  ],
  "application/vnd.mediastation.cdkey": [
    "cdkey"
  ],
  "application/vnd.mfer": [
    "mwf"
  ],
  "application/vnd.mfmp": [
    "mfm"
  ],
  "application/vnd.micrografx.flo": [
    "flo"
  ],
  "application/vnd.micrografx.igx": [
    "igx"
  ],
  "application/vnd.mif": [
    "mif"
  ],
  "application/vnd.mobius.daf": [
    "daf"
  ],
  "application/vnd.mobius.dis": [
    "dis"
  ],
  "application/vnd.mobius.mbk": [
    "mbk"
  ],
  "application/vnd.mobius.mqy": [
    "mqy"
  ],
  "application/vnd.mobius.msl": [
    "msl"
  ],
  "application/vnd.mobius.plc": [
    "plc"
  ],
  "application/vnd.mobius.txf": [
    "txf"
  ],
  "application/vnd.mophun.application": [
    "mpn"
  ],
  "application/vnd.mophun.certificate": [
    "mpc"
  ],
  "application/vnd.mozilla.xul+xml": [
    "xul"
  ],
  "application/vnd.ms-artgalry": [
    "cil"
  ],
  "application/vnd.ms-cab-compressed": [
    "cab"
  ],
  "application/vnd.ms-excel": [
    "xls",
    "xlm",
    "xla",
    "xlc",
    "xlt",
    "xlw"
  ],
  "application/vnd.ms-excel.addin.macroenabled.12": [
    "xlam"
  ],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": [
    "xlsb"
  ],
  "application/vnd.ms-excel.sheet.macroenabled.12": [
    "xlsm"
  ],
  "application/vnd.ms-excel.template.macroenabled.12": [
    "xltm"
  ],
  "application/vnd.ms-fontobject": [
    "eot"
  ],
  "application/vnd.ms-htmlhelp": [
    "chm"
  ],
  "application/vnd.ms-ims": [
    "ims"
  ],
  "application/vnd.ms-lrm": [
    "lrm"
  ],
  "application/vnd.ms-officetheme": [
    "thmx"
  ],
  "application/vnd.ms-outlook": [
    "msg"
  ],
  "application/vnd.ms-pki.seccat": [
    "cat"
  ],
  "application/vnd.ms-pki.stl": [
    "stl"
  ],
  "application/vnd.ms-powerpoint": [
    "ppt",
    "pps",
    "pot"
  ],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": [
    "ppam"
  ],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": [
    "pptm"
  ],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": [
    "sldm"
  ],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
    "ppsm"
  ],
  "application/vnd.ms-powerpoint.template.macroenabled.12": [
    "potm"
  ],
  "application/vnd.ms-project": [
    "mpp",
    "mpt"
  ],
  "application/vnd.ms-word.document.macroenabled.12": [
    "docm"
  ],
  "application/vnd.ms-word.template.macroenabled.12": [
    "dotm"
  ],
  "application/vnd.ms-works": [
    "wps",
    "wks",
    "wcm",
    "wdb"
  ],
  "application/vnd.ms-wpl": [
    "wpl"
  ],
  "application/vnd.ms-xpsdocument": [
    "xps"
  ],
  "application/vnd.mseq": [
    "mseq"
  ],
  "application/vnd.musician": [
    "mus"
  ],
  "application/vnd.muvee.style": [
    "msty"
  ],
  "application/vnd.mynfc": [
    "taglet"
  ],
  "application/vnd.neurolanguage.nlu": [
    "nlu"
  ],
  "application/vnd.nitf": [
    "ntf",
    "nitf"
  ],
  "application/vnd.noblenet-directory": [
    "nnd"
  ],
  "application/vnd.noblenet-sealer": [
    "nns"
  ],
  "application/vnd.noblenet-web": [
    "nnw"
  ],
  "application/vnd.nokia.n-gage.data": [
    "ngdat"
  ],
  "application/vnd.nokia.n-gage.symbian.install": [
    "n-gage"
  ],
  "application/vnd.nokia.radio-preset": [
    "rpst"
  ],
  "application/vnd.nokia.radio-presets": [
    "rpss"
  ],
  "application/vnd.novadigm.edm": [
    "edm"
  ],
  "application/vnd.novadigm.edx": [
    "edx"
  ],
  "application/vnd.novadigm.ext": [
    "ext"
  ],
  "application/vnd.oasis.opendocument.chart": [
    "odc"
  ],
  "application/vnd.oasis.opendocument.chart-template": [
    "otc"
  ],
  "application/vnd.oasis.opendocument.database": [
    "odb"
  ],
  "application/vnd.oasis.opendocument.formula": [
    "odf"
  ],
  "application/vnd.oasis.opendocument.formula-template": [
    "odft"
  ],
  "application/vnd.oasis.opendocument.graphics": [
    "odg"
  ],
  "application/vnd.oasis.opendocument.graphics-template": [
    "otg"
  ],
  "application/vnd.oasis.opendocument.image": [
    "odi"
  ],
  "application/vnd.oasis.opendocument.image-template": [
    "oti"
  ],
  "application/vnd.oasis.opendocument.presentation": [
    "odp"
  ],
  "application/vnd.oasis.opendocument.presentation-template": [
    "otp"
  ],
  "application/vnd.oasis.opendocument.spreadsheet": [
    "ods"
  ],
  "application/vnd.oasis.opendocument.spreadsheet-template": [
    "ots"
  ],
  "application/vnd.oasis.opendocument.text": [
    "odt"
  ],
  "application/vnd.oasis.opendocument.text-master": [
    "odm"
  ],
  "application/vnd.oasis.opendocument.text-template": [
    "ott"
  ],
  "application/vnd.oasis.opendocument.text-web": [
    "oth"
  ],
  "application/vnd.olpc-sugar": [
    "xo"
  ],
  "application/vnd.oma.dd2+xml": [
    "dd2"
  ],
  "application/vnd.openofficeorg.extension": [
    "oxt"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": [
    "pptx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": [
    "sldx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
    "ppsx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.template": [
    "potx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
    "xlsx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
    "xltx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
    "docx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
    "dotx"
  ],
  "application/vnd.osgeo.mapguide.package": [
    "mgp"
  ],
  "application/vnd.osgi.dp": [
    "dp"
  ],
  "application/vnd.osgi.subsystem": [
    "esa"
  ],
  "application/vnd.palm": [
    "pdb",
    "pqa",
    "oprc"
  ],
  "application/vnd.pawaafile": [
    "paw"
  ],
  "application/vnd.pg.format": [
    "str"
  ],
  "application/vnd.pg.osasli": [
    "ei6"
  ],
  "application/vnd.picsel": [
    "efif"
  ],
  "application/vnd.pmi.widget": [
    "wg"
  ],
  "application/vnd.pocketlearn": [
    "plf"
  ],
  "application/vnd.powerbuilder6": [
    "pbd"
  ],
  "application/vnd.previewsystems.box": [
    "box"
  ],
  "application/vnd.proteus.magazine": [
    "mgz"
  ],
  "application/vnd.publishare-delta-tree": [
    "qps"
  ],
  "application/vnd.pvi.ptid1": [
    "ptid"
  ],
  "application/vnd.quark.quarkxpress": [
    "qxd",
    "qxt",
    "qwd",
    "qwt",
    "qxl",
    "qxb"
  ],
  "application/vnd.realvnc.bed": [
    "bed"
  ],
  "application/vnd.recordare.musicxml": [
    "mxl"
  ],
  "application/vnd.recordare.musicxml+xml": [
    "musicxml"
  ],
  "application/vnd.rig.cryptonote": [
    "cryptonote"
  ],
  "application/vnd.rim.cod": [
    "cod"
  ],
  "application/vnd.rn-realmedia": [
    "rm"
  ],
  "application/vnd.rn-realmedia-vbr": [
    "rmvb"
  ],
  "application/vnd.route66.link66+xml": [
    "link66"
  ],
  "application/vnd.sailingtracker.track": [
    "st"
  ],
  "application/vnd.seemail": [
    "see"
  ],
  "application/vnd.sema": [
    "sema"
  ],
  "application/vnd.semd": [
    "semd"
  ],
  "application/vnd.semf": [
    "semf"
  ],
  "application/vnd.shana.informed.formdata": [
    "ifm"
  ],
  "application/vnd.shana.informed.formtemplate": [
    "itp"
  ],
  "application/vnd.shana.informed.interchange": [
    "iif"
  ],
  "application/vnd.shana.informed.package": [
    "ipk"
  ],
  "application/vnd.simtech-mindmapper": [
    "twd",
    "twds"
  ],
  "application/vnd.smaf": [
    "mmf"
  ],
  "application/vnd.smart.teacher": [
    "teacher"
  ],
  "application/vnd.solent.sdkm+xml": [
    "sdkm",
    "sdkd"
  ],
  "application/vnd.spotfire.dxp": [
    "dxp"
  ],
  "application/vnd.spotfire.sfs": [
    "sfs"
  ],
  "application/vnd.stardivision.calc": [
    "sdc"
  ],
  "application/vnd.stardivision.draw": [
    "sda"
  ],
  "application/vnd.stardivision.impress": [
    "sdd"
  ],
  "application/vnd.stardivision.math": [
    "smf"
  ],
  "application/vnd.stardivision.writer": [
    "sdw",
    "vor"
  ],
  "application/vnd.stardivision.writer-global": [
    "sgl"
  ],
  "application/vnd.stepmania.package": [
    "smzip"
  ],
  "application/vnd.stepmania.stepchart": [
    "sm"
  ],
  "application/vnd.sun.wadl+xml": [
    "wadl"
  ],
  "application/vnd.sun.xml.calc": [
    "sxc"
  ],
  "application/vnd.sun.xml.calc.template": [
    "stc"
  ],
  "application/vnd.sun.xml.draw": [
    "sxd"
  ],
  "application/vnd.sun.xml.draw.template": [
    "std"
  ],
  "application/vnd.sun.xml.impress": [
    "sxi"
  ],
  "application/vnd.sun.xml.impress.template": [
    "sti"
  ],
  "application/vnd.sun.xml.math": [
    "sxm"
  ],
  "application/vnd.sun.xml.writer": [
    "sxw"
  ],
  "application/vnd.sun.xml.writer.global": [
    "sxg"
  ],
  "application/vnd.sun.xml.writer.template": [
    "stw"
  ],
  "application/vnd.sus-calendar": [
    "sus",
    "susp"
  ],
  "application/vnd.svd": [
    "svd"
  ],
  "application/vnd.symbian.install": [
    "sis",
    "sisx"
  ],
  "application/vnd.syncml+xml": [
    "xsm"
  ],
  "application/vnd.syncml.dm+wbxml": [
    "bdm"
  ],
  "application/vnd.syncml.dm+xml": [
    "xdm"
  ],
  "application/vnd.tao.intent-module-archive": [
    "tao"
  ],
  "application/vnd.tcpdump.pcap": [
    "pcap",
    "cap",
    "dmp"
  ],
  "application/vnd.tmobile-livetv": [
    "tmo"
  ],
  "application/vnd.trid.tpt": [
    "tpt"
  ],
  "application/vnd.triscape.mxs": [
    "mxs"
  ],
  "application/vnd.trueapp": [
    "tra"
  ],
  "application/vnd.ufdl": [
    "ufd",
    "ufdl"
  ],
  "application/vnd.uiq.theme": [
    "utz"
  ],
  "application/vnd.umajin": [
    "umj"
  ],
  "application/vnd.unity": [
    "unityweb"
  ],
  "application/vnd.uoml+xml": [
    "uoml"
  ],
  "application/vnd.vcx": [
    "vcx"
  ],
  "application/vnd.visio": [
    "vsd",
    "vst",
    "vss",
    "vsw"
  ],
  "application/vnd.visionary": [
    "vis"
  ],
  "application/vnd.vsf": [
    "vsf"
  ],
  "application/vnd.wap.wbxml": [
    "wbxml"
  ],
  "application/vnd.wap.wmlc": [
    "wmlc"
  ],
  "application/vnd.wap.wmlscriptc": [
    "wmlsc"
  ],
  "application/vnd.webturbo": [
    "wtb"
  ],
  "application/vnd.wolfram.player": [
    "nbp"
  ],
  "application/vnd.wordperfect": [
    "wpd"
  ],
  "application/vnd.wqd": [
    "wqd"
  ],
  "application/vnd.wt.stf": [
    "stf"
  ],
  "application/vnd.xara": [
    "xar"
  ],
  "application/vnd.xfdl": [
    "xfdl"
  ],
  "application/vnd.yamaha.hv-dic": [
    "hvd"
  ],
  "application/vnd.yamaha.hv-script": [
    "hvs"
  ],
  "application/vnd.yamaha.hv-voice": [
    "hvp"
  ],
  "application/vnd.yamaha.openscoreformat": [
    "osf"
  ],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": [
    "osfpvg"
  ],
  "application/vnd.yamaha.smaf-audio": [
    "saf"
  ],
  "application/vnd.yamaha.smaf-phrase": [
    "spf"
  ],
  "application/vnd.yellowriver-custom-menu": [
    "cmp"
  ],
  "application/vnd.zul": [
    "zir",
    "zirz"
  ],
  "application/vnd.zzazz.deck+xml": [
    "zaz"
  ],
  "application/voicexml+xml": [
    "vxml"
  ],
  "application/wasm": [
    "wasm"
  ],
  "application/widget": [
    "wgt"
  ],
  "application/winhlp": [
    "hlp"
  ],
  "application/wsdl+xml": [
    "wsdl"
  ],
  "application/wspolicy+xml": [
    "wspolicy"
  ],
  "application/x-7z-compressed": [
    "7z"
  ],
  "application/x-abiword": [
    "abw"
  ],
  "application/x-ace-compressed": [
    "ace"
  ],
  "application/x-apple-diskimage": [],
  "application/x-arj": [
    "arj"
  ],
  "application/x-authorware-bin": [
    "aab",
    "x32",
    "u32",
    "vox"
  ],
  "application/x-authorware-map": [
    "aam"
  ],
  "application/x-authorware-seg": [
    "aas"
  ],
  "application/x-bcpio": [
    "bcpio"
  ],
  "application/x-bdoc": [],
  "application/x-bittorrent": [
    "torrent"
  ],
  "application/x-blorb": [
    "blb",
    "blorb"
  ],
  "application/x-bzip": [
    "bz"
  ],
  "application/x-bzip2": [
    "bz2",
    "boz"
  ],
  "application/x-cbr": [
    "cbr",
    "cba",
    "cbt",
    "cbz",
    "cb7"
  ],
  "application/x-cdlink": [
    "vcd"
  ],
  "application/x-cfs-compressed": [
    "cfs"
  ],
  "application/x-chat": [
    "chat"
  ],
  "application/x-chess-pgn": [
    "pgn"
  ],
  "application/x-chrome-extension": [
    "crx"
  ],
  "application/x-cocoa": [
    "cco"
  ],
  "application/x-conference": [
    "nsc"
  ],
  "application/x-cpio": [
    "cpio"
  ],
  "application/x-csh": [
    "csh"
  ],
  "application/x-debian-package": [
    "udeb"
  ],
  "application/x-dgc-compressed": [
    "dgc"
  ],
  "application/x-director": [
    "dir",
    "dcr",
    "dxr",
    "cst",
    "cct",
    "cxt",
    "w3d",
    "fgd",
    "swa"
  ],
  "application/x-doom": [
    "wad"
  ],
  "application/x-dtbncx+xml": [
    "ncx"
  ],
  "application/x-dtbook+xml": [
    "dtb"
  ],
  "application/x-dtbresource+xml": [
    "res"
  ],
  "application/x-dvi": [
    "dvi"
  ],
  "application/x-envoy": [
    "evy"
  ],
  "application/x-eva": [
    "eva"
  ],
  "application/x-font-bdf": [
    "bdf"
  ],
  "application/x-font-ghostscript": [
    "gsf"
  ],
  "application/x-font-linux-psf": [
    "psf"
  ],
  "application/x-font-pcf": [
    "pcf"
  ],
  "application/x-font-snf": [
    "snf"
  ],
  "application/x-font-type1": [
    "pfa",
    "pfb",
    "pfm",
    "afm"
  ],
  "application/x-freearc": [
    "arc"
  ],
  "application/x-futuresplash": [
    "spl"
  ],
  "application/x-gca-compressed": [
    "gca"
  ],
  "application/x-glulx": [
    "ulx"
  ],
  "application/x-gnumeric": [
    "gnumeric"
  ],
  "application/x-gramps-xml": [
    "gramps"
  ],
  "application/x-gtar": [
    "gtar"
  ],
  "application/x-hdf": [
    "hdf"
  ],
  "application/x-httpd-php": [
    "php"
  ],
  "application/x-install-instructions": [
    "install"
  ],
  "application/x-iso9660-image": [],
  "application/x-java-archive-diff": [
    "jardiff"
  ],
  "application/x-java-jnlp-file": [
    "jnlp"
  ],
  "application/x-latex": [
    "latex"
  ],
  "application/x-lua-bytecode": [
    "luac"
  ],
  "application/x-lzh-compressed": [
    "lzh",
    "lha"
  ],
  "application/x-makeself": [
    "run"
  ],
  "application/x-mie": [
    "mie"
  ],
  "application/x-mobipocket-ebook": [
    "prc",
    "mobi"
  ],
  "application/x-ms-application": [
    "application"
  ],
  "application/x-ms-shortcut": [
    "lnk"
  ],
  "application/x-ms-wmd": [
    "wmd"
  ],
  "application/x-ms-wmz": [
    "wmz"
  ],
  "application/x-ms-xbap": [
    "xbap"
  ],
  "application/x-msaccess": [
    "mdb"
  ],
  "application/x-msbinder": [
    "obd"
  ],
  "application/x-mscardfile": [
    "crd"
  ],
  "application/x-msclip": [
    "clp"
  ],
  "application/x-msdos-program": [],
  "application/x-msdownload": [
    "com",
    "bat"
  ],
  "application/x-msmediaview": [
    "mvb",
    "m13",
    "m14"
  ],
  "application/x-msmetafile": [
    "wmf",
    "emf",
    "emz"
  ],
  "application/x-msmoney": [
    "mny"
  ],
  "application/x-mspublisher": [
    "pub"
  ],
  "application/x-msschedule": [
    "scd"
  ],
  "application/x-msterminal": [
    "trm"
  ],
  "application/x-mswrite": [
    "wri"
  ],
  "application/x-netcdf": [
    "nc",
    "cdf"
  ],
  "application/x-ns-proxy-autoconfig": [
    "pac"
  ],
  "application/x-nzb": [
    "nzb"
  ],
  "application/x-perl": [
    "pl",
    "pm"
  ],
  "application/x-pilot": [],
  "application/x-pkcs12": [
    "p12",
    "pfx"
  ],
  "application/x-pkcs7-certificates": [
    "p7b",
    "spc"
  ],
  "application/x-pkcs7-certreqresp": [
    "p7r"
  ],
  "application/x-rar-compressed": [
    "rar"
  ],
  "application/x-redhat-package-manager": [
    "rpm"
  ],
  "application/x-research-info-systems": [
    "ris"
  ],
  "application/x-sea": [
    "sea"
  ],
  "application/x-sh": [
    "sh"
  ],
  "application/x-shar": [
    "shar"
  ],
  "application/x-shockwave-flash": [
    "swf"
  ],
  "application/x-silverlight-app": [
    "xap"
  ],
  "application/x-sql": [
    "sql"
  ],
  "application/x-stuffit": [
    "sit"
  ],
  "application/x-stuffitx": [
    "sitx"
  ],
  "application/x-subrip": [
    "srt"
  ],
  "application/x-sv4cpio": [
    "sv4cpio"
  ],
  "application/x-sv4crc": [
    "sv4crc"
  ],
  "application/x-t3vm-image": [
    "t3"
  ],
  "application/x-tads": [
    "gam"
  ],
  "application/x-tar": [
    "tar"
  ],
  "application/x-tcl": [
    "tcl",
    "tk"
  ],
  "application/x-tex": [
    "tex"
  ],
  "application/x-tex-tfm": [
    "tfm"
  ],
  "application/x-texinfo": [
    "texinfo",
    "texi"
  ],
  "application/x-tgif": [
    "obj"
  ],
  "application/x-ustar": [
    "ustar"
  ],
  "application/x-virtualbox-hdd": [
    "hdd"
  ],
  "application/x-virtualbox-ova": [
    "ova"
  ],
  "application/x-virtualbox-ovf": [
    "ovf"
  ],
  "application/x-virtualbox-vbox": [
    "vbox"
  ],
  "application/x-virtualbox-vbox-extpack": [
    "vbox-extpack"
  ],
  "application/x-virtualbox-vdi": [
    "vdi"
  ],
  "application/x-virtualbox-vhd": [
    "vhd"
  ],
  "application/x-virtualbox-vmdk": [
    "vmdk"
  ],
  "application/x-wais-source": [
    "src"
  ],
  "application/x-web-app-manifest+json": [
    "webapp"
  ],
  "application/x-x509-ca-cert": [
    "der",
    "crt",
    "pem"
  ],
  "application/x-xfig": [
    "fig"
  ],
  "application/x-xliff+xml": [
    "xlf"
  ],
  "application/x-xpinstall": [
    "xpi"
  ],
  "application/x-xz": [
    "xz"
  ],
  "application/x-zmachine": [
    "z1",
    "z2",
    "z3",
    "z4",
    "z5",
    "z6",
    "z7",
    "z8"
  ],
  "application/xaml+xml": [
    "xaml"
  ],
  "application/xcap-diff+xml": [
    "xdf"
  ],
  "application/xenc+xml": [
    "xenc"
  ],
  "application/xhtml+xml": [
    "xhtml",
    "xht"
  ],
  "application/xml": [
    "xml",
    "xsl",
    "xsd",
    "rng"
  ],
  "application/xml-dtd": [
    "dtd"
  ],
  "application/xop+xml": [
    "xop"
  ],
  "application/xproc+xml": [
    "xpl"
  ],
  "application/xslt+xml": [
    "xslt"
  ],
  "application/xspf+xml": [
    "xspf"
  ],
  "application/xv+xml": [
    "mxml",
    "xhvml",
    "xvml",
    "xvm"
  ],
  "application/yang": [
    "yang"
  ],
  "application/yin+xml": [
    "yin"
  ],
  "application/zip": [
    "zip"
  ],
  "audio/3gpp": [],
  "audio/adpcm": [
    "adp"
  ],
  "audio/basic": [
    "au",
    "snd"
  ],
  "audio/midi": [
    "mid",
    "midi",
    "kar",
    "rmi"
  ],
  "audio/mp3": [],
  "audio/mp4": [
    "m4a",
    "mp4a"
  ],
  "audio/mpeg": [
    "mpga",
    "mp2",
    "mp2a",
    "mp3",
    "m2a",
    "m3a"
  ],
  "audio/ogg": [
    "oga",
    "ogg",
    "spx"
  ],
  "audio/s3m": [
    "s3m"
  ],
  "audio/silk": [
    "sil"
  ],
  "audio/vnd.dece.audio": [
    "uva",
    "uvva"
  ],
  "audio/vnd.digital-winds": [
    "eol"
  ],
  "audio/vnd.dra": [
    "dra"
  ],
  "audio/vnd.dts": [
    "dts"
  ],
  "audio/vnd.dts.hd": [
    "dtshd"
  ],
  "audio/vnd.lucent.voice": [
    "lvp"
  ],
  "audio/vnd.ms-playready.media.pya": [
    "pya"
  ],
  "audio/vnd.nuera.ecelp4800": [
    "ecelp4800"
  ],
  "audio/vnd.nuera.ecelp7470": [
    "ecelp7470"
  ],
  "audio/vnd.nuera.ecelp9600": [
    "ecelp9600"
  ],
  "audio/vnd.rip": [
    "rip"
  ],
  "audio/wav": [
    "wav"
  ],
  "audio/wave": [],
  "audio/webm": [
    "weba"
  ],
  "audio/x-aac": [
    "aac"
  ],
  "audio/x-aiff": [
    "aif",
    "aiff",
    "aifc"
  ],
  "audio/x-caf": [
    "caf"
  ],
  "audio/x-flac": [
    "flac"
  ],
  "audio/x-m4a": [],
  "audio/x-matroska": [
    "mka"
  ],
  "audio/x-mpegurl": [
    "m3u"
  ],
  "audio/x-ms-wax": [
    "wax"
  ],
  "audio/x-ms-wma": [
    "wma"
  ],
  "audio/x-pn-realaudio": [
    "ram",
    "ra"
  ],
  "audio/x-pn-realaudio-plugin": [
    "rmp"
  ],
  "audio/x-realaudio": [],
  "audio/x-wav": [],
  "audio/xm": [
    "xm"
  ],
  "chemical/x-cdx": [
    "cdx"
  ],
  "chemical/x-cif": [
    "cif"
  ],
  "chemical/x-cmdf": [
    "cmdf"
  ],
  "chemical/x-cml": [
    "cml"
  ],
  "chemical/x-csml": [
    "csml"
  ],
  "chemical/x-xyz": [
    "xyz"
  ],
  "font/collection": [
    "ttc"
  ],
  "font/otf": [
    "otf"
  ],
  "font/ttf": [
    "ttf"
  ],
  "font/woff": [
    "woff"
  ],
  "font/woff2": [
    "woff2"
  ],
  "image/apng": [
    "apng"
  ],
  "image/bmp": [
    "bmp"
  ],
  "image/cgm": [
    "cgm"
  ],
  "image/g3fax": [
    "g3"
  ],
  "image/gif": [
    "gif"
  ],
  "image/ief": [
    "ief"
  ],
  "image/jp2": [
    "jp2",
    "jpg2"
  ],
  "image/jpeg": [
    "jpeg",
    "jpg",
    "jpe"
  ],
  "image/jpm": [
    "jpm"
  ],
  "image/jpx": [
    "jpx",
    "jpf"
  ],
  "image/ktx": [
    "ktx"
  ],
  "image/png": [
    "png"
  ],
  "image/prs.btif": [
    "btif"
  ],
  "image/sgi": [
    "sgi"
  ],
  "image/svg+xml": [
    "svg",
    "svgz"
  ],
  "image/tiff": [
    "tiff",
    "tif"
  ],
  "image/vnd.adobe.photoshop": [
    "psd"
  ],
  "image/vnd.dece.graphic": [
    "uvi",
    "uvvi",
    "uvg",
    "uvvg"
  ],
  "image/vnd.djvu": [
    "djvu",
    "djv"
  ],
  "image/vnd.dvb.subtitle": [],
  "image/vnd.dwg": [
    "dwg"
  ],
  "image/vnd.dxf": [
    "dxf"
  ],
  "image/vnd.fastbidsheet": [
    "fbs"
  ],
  "image/vnd.fpx": [
    "fpx"
  ],
  "image/vnd.fst": [
    "fst"
  ],
  "image/vnd.fujixerox.edmics-mmr": [
    "mmr"
  ],
  "image/vnd.fujixerox.edmics-rlc": [
    "rlc"
  ],
  "image/vnd.ms-modi": [
    "mdi"
  ],
  "image/vnd.ms-photo": [
    "wdp"
  ],
  "image/vnd.net-fpx": [
    "npx"
  ],
  "image/vnd.wap.wbmp": [
    "wbmp"
  ],
  "image/vnd.xiff": [
    "xif"
  ],
  "image/webp": [
    "webp"
  ],
  "image/x-3ds": [
    "3ds"
  ],
  "image/x-cmu-raster": [
    "ras"
  ],
  "image/x-cmx": [
    "cmx"
  ],
  "image/x-freehand": [
    "fh",
    "fhc",
    "fh4",
    "fh5",
    "fh7"
  ],
  "image/x-icon": [
    "ico"
  ],
  "image/x-jng": [
    "jng"
  ],
  "image/x-mrsid-image": [
    "sid"
  ],
  "image/x-ms-bmp": [],
  "image/x-pcx": [
    "pcx"
  ],
  "image/x-pict": [
    "pic",
    "pct"
  ],
  "image/x-portable-anymap": [
    "pnm"
  ],
  "image/x-portable-bitmap": [
    "pbm"
  ],
  "image/x-portable-graymap": [
    "pgm"
  ],
  "image/x-portable-pixmap": [
    "ppm"
  ],
  "image/x-rgb": [
    "rgb"
  ],
  "image/x-tga": [
    "tga"
  ],
  "image/x-xbitmap": [
    "xbm"
  ],
  "image/x-xpixmap": [
    "xpm"
  ],
  "image/x-xwindowdump": [
    "xwd"
  ],
  "message/rfc822": [
    "eml",
    "mime"
  ],
  "model/gltf+json": [
    "gltf"
  ],
  "model/gltf-binary": [
    "glb"
  ],
  "model/iges": [
    "igs",
    "iges"
  ],
  "model/mesh": [
    "msh",
    "mesh",
    "silo"
  ],
  "model/vnd.collada+xml": [
    "dae"
  ],
  "model/vnd.dwf": [
    "dwf"
  ],
  "model/vnd.gdl": [
    "gdl"
  ],
  "model/vnd.gtw": [
    "gtw"
  ],
  "model/vnd.mts": [
    "mts"
  ],
  "model/vnd.vtu": [
    "vtu"
  ],
  "model/vrml": [
    "wrl",
    "vrml"
  ],
  "model/x3d+binary": [
    "x3db",
    "x3dbz"
  ],
  "model/x3d+vrml": [
    "x3dv",
    "x3dvz"
  ],
  "model/x3d+xml": [
    "x3d",
    "x3dz"
  ],
  "text/cache-manifest": [
    "appcache",
    "manifest"
  ],
  "text/calendar": [
    "ics",
    "ifb"
  ],
  "text/coffeescript": [
    "coffee",
    "litcoffee"
  ],
  "text/css": [
    "css"
  ],
  "text/csv": [
    "csv"
  ],
  "text/hjson": [
    "hjson"
  ],
  "text/html": [
    "html",
    "htm",
    "shtml"
  ],
  "text/jade": [
    "jade"
  ],
  "text/jsx": [
    "jsx"
  ],
  "text/less": [
    "less"
  ],
  "text/markdown": [
    "markdown",
    "md"
  ],
  "text/mathml": [
    "mml"
  ],
  "text/n3": [
    "n3"
  ],
  "text/plain": [
    "txt",
    "text",
    "conf",
    "def",
    "list",
    "log",
    "in",
    "ini"
  ],
  "text/prs.lines.tag": [
    "dsc"
  ],
  "text/richtext": [
    "rtx"
  ],
  "text/rtf": [],
  "text/sgml": [
    "sgml",
    "sgm"
  ],
  "text/slim": [
    "slim",
    "slm"
  ],
  "text/stylus": [
    "stylus",
    "styl"
  ],
  "text/tab-separated-values": [
    "tsv"
  ],
  "text/troff": [
    "t",
    "tr",
    "roff",
    "man",
    "me",
    "ms"
  ],
  "text/turtle": [
    "ttl"
  ],
  "text/uri-list": [
    "uri",
    "uris",
    "urls"
  ],
  "text/vcard": [
    "vcard"
  ],
  "text/vnd.curl": [
    "curl"
  ],
  "text/vnd.curl.dcurl": [
    "dcurl"
  ],
  "text/vnd.curl.mcurl": [
    "mcurl"
  ],
  "text/vnd.curl.scurl": [
    "scurl"
  ],
  "text/vnd.dvb.subtitle": [
    "sub"
  ],
  "text/vnd.fly": [
    "fly"
  ],
  "text/vnd.fmi.flexstor": [
    "flx"
  ],
  "text/vnd.graphviz": [
    "gv"
  ],
  "text/vnd.in3d.3dml": [
    "3dml"
  ],
  "text/vnd.in3d.spot": [
    "spot"
  ],
  "text/vnd.sun.j2me.app-descriptor": [
    "jad"
  ],
  "text/vnd.wap.wml": [
    "wml"
  ],
  "text/vnd.wap.wmlscript": [
    "wmls"
  ],
  "text/vtt": [
    "vtt"
  ],
  "text/x-asm": [
    "s",
    "asm"
  ],
  "text/x-c": [
    "c",
    "cc",
    "cxx",
    "cpp",
    "h",
    "hh",
    "dic"
  ],
  "text/x-component": [
    "htc"
  ],
  "text/x-fortran": [
    "f",
    "for",
    "f77",
    "f90"
  ],
  "text/x-handlebars-template": [
    "hbs"
  ],
  "text/x-java-source": [
    "java"
  ],
  "text/x-lua": [
    "lua"
  ],
  "text/x-markdown": [
    "mkd"
  ],
  "text/x-nfo": [
    "nfo"
  ],
  "text/x-opml": [
    "opml"
  ],
  "text/x-org": [],
  "text/x-pascal": [
    "p",
    "pas"
  ],
  "text/x-processing": [
    "pde"
  ],
  "text/x-sass": [
    "sass"
  ],
  "text/x-scss": [
    "scss"
  ],
  "text/x-setext": [
    "etx"
  ],
  "text/x-sfv": [
    "sfv"
  ],
  "text/x-suse-ymp": [
    "ymp"
  ],
  "text/x-uuencode": [
    "uu"
  ],
  "text/x-vcalendar": [
    "vcs"
  ],
  "text/x-vcard": [
    "vcf"
  ],
  "text/xml": [],
  "text/yaml": [
    "yaml",
    "yml"
  ],
  "video/3gpp": [
    "3gp",
    "3gpp"
  ],
  "video/3gpp2": [
    "3g2"
  ],
  "video/h261": [
    "h261"
  ],
  "video/h263": [
    "h263"
  ],
  "video/h264": [
    "h264"
  ],
  "video/jpeg": [
    "jpgv"
  ],
  "video/jpm": [
    "jpgm"
  ],
  "video/mj2": [
    "mj2",
    "mjp2"
  ],
  "video/mp2t": [
    "ts"
  ],
  "video/mp4": [
    "mp4",
    "mp4v",
    "mpg4"
  ],
  "video/mpeg": [
    "mpeg",
    "mpg",
    "mpe",
    "m1v",
    "m2v"
  ],
  "video/ogg": [
    "ogv"
  ],
  "video/quicktime": [
    "qt",
    "mov"
  ],
  "video/vnd.dece.hd": [
    "uvh",
    "uvvh"
  ],
  "video/vnd.dece.mobile": [
    "uvm",
    "uvvm"
  ],
  "video/vnd.dece.pd": [
    "uvp",
    "uvvp"
  ],
  "video/vnd.dece.sd": [
    "uvs",
    "uvvs"
  ],
  "video/vnd.dece.video": [
    "uvv",
    "uvvv"
  ],
  "video/vnd.dvb.file": [
    "dvb"
  ],
  "video/vnd.fvt": [
    "fvt"
  ],
  "video/vnd.mpegurl": [
    "mxu",
    "m4u"
  ],
  "video/vnd.ms-playready.media.pyv": [
    "pyv"
  ],
  "video/vnd.uvvu.mp4": [
    "uvu",
    "uvvu"
  ],
  "video/vnd.vivo": [
    "viv"
  ],
  "video/webm": [
    "webm"
  ],
  "video/x-f4v": [
    "f4v"
  ],
  "video/x-fli": [
    "fli"
  ],
  "video/x-flv": [
    "flv"
  ],
  "video/x-m4v": [
    "m4v"
  ],
  "video/x-matroska": [
    "mkv",
    "mk3d",
    "mks"
  ],
  "video/x-mng": [
    "mng"
  ],
  "video/x-ms-asf": [
    "asf",
    "asx"
  ],
  "video/x-ms-vob": [
    "vob"
  ],
  "video/x-ms-wm": [
    "wm"
  ],
  "video/x-ms-wmv": [
    "wmv"
  ],
  "video/x-ms-wmx": [
    "wmx"
  ],
  "video/x-ms-wvx": [
    "wvx"
  ],
  "video/x-msvideo": [
    "avi"
  ],
  "video/x-sgi-movie": [
    "movie"
  ],
  "video/x-smv": [
    "smv"
  ],
  "x-conference/x-cooltalk": [
    "ice"
  ]
};
var mime_1;
var hasRequiredMime;
function requireMime() {
  if (hasRequiredMime)
    return mime_1;
  hasRequiredMime = 1;
  var fs2 = require$$1$3;
  function Mime() {
    this.types = /* @__PURE__ */ Object.create(null);
    this.extensions = /* @__PURE__ */ Object.create(null);
  }
  Mime.prototype.define = function(map2) {
    for (var type2 in map2) {
      var exts = map2[type2];
      for (var i = 0; i < exts.length; i++) {
        if (process.env.DEBUG_MIME && this.types[exts[i]]) {
          console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type2);
        }
        this.types[exts[i]] = type2;
      }
      if (!this.extensions[type2]) {
        this.extensions[type2] = exts[0];
      }
    }
  };
  Mime.prototype.load = function(file2) {
    this._loading = file2;
    var map2 = {}, content = fs2.readFileSync(file2, "ascii"), lines = content.split(/[\r\n]+/);
    lines.forEach(function(line) {
      var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
      map2[fields.shift()] = fields;
    });
    this.define(map2);
    this._loading = null;
  };
  Mime.prototype.lookup = function(path2, fallback) {
    var ext = path2.replace(/^.*[\.\/\\]/, "").toLowerCase();
    return this.types[ext] || fallback || this.default_type;
  };
  Mime.prototype.extension = function(mimeType) {
    var type2 = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type2];
  };
  var mime2 = new Mime();
  mime2.define(require$$2);
  mime2.default_type = mime2.lookup("bin");
  mime2.Mime = Mime;
  mime2.charsets = {
    lookup: function(mimeType, fallback) {
      return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
    }
  };
  mime_1 = mime2;
  return mime_1;
}
var ms$3;
var hasRequiredMs$3;
function requireMs$3() {
  if (hasRequiredMs$3)
    return ms$3;
  hasRequiredMs$3 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$3 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$3;
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var rangeParser_1;
var hasRequiredRangeParser;
function requireRangeParser() {
  if (hasRequiredRangeParser)
    return rangeParser_1;
  hasRequiredRangeParser = 1;
  rangeParser_1 = rangeParser;
  function rangeParser(size, str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var index = str.indexOf("=");
    if (index === -1) {
      return -2;
    }
    var arr = str.slice(index + 1).split(",");
    var ranges = [];
    ranges.type = str.slice(0, index);
    for (var i = 0; i < arr.length; i++) {
      var range2 = arr[i].split("-");
      var start = parseInt(range2[0], 10);
      var end = parseInt(range2[1], 10);
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
      } else if (isNaN(end)) {
        end = size - 1;
      }
      if (end > size - 1) {
        end = size - 1;
      }
      if (isNaN(start) || isNaN(end) || start > end || start < 0) {
        continue;
      }
      ranges.push({
        start,
        end
      });
    }
    if (ranges.length < 1) {
      return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
  }
  function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for (var j = 0, i = 1; i < ordered.length; i++) {
      var range2 = ordered[i];
      var current = ordered[j];
      if (range2.start > current.end + 1) {
        ordered[++j] = range2;
      } else if (range2.end > current.end) {
        current.end = range2.end;
        current.index = Math.min(current.index, range2.index);
      }
    }
    ordered.length = j + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
  }
  function mapWithIndex(range2, index) {
    return {
      start: range2.start,
      end: range2.end,
      index
    };
  }
  function mapWithoutIndex(range2) {
    return {
      start: range2.start,
      end: range2.end
    };
  }
  function sortByRangeIndex(a, b) {
    return a.index - b.index;
  }
  function sortByRangeStart(a, b) {
    return a.start - b.start;
  }
  return rangeParser_1;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredSend;
function requireSend() {
  if (hasRequiredSend)
    return send.exports;
  hasRequiredSend = 1;
  var createError = requireHttpErrors();
  var debug2 = requireSrc()("send");
  var deprecate = requireDepd()("send");
  var destroy2 = requireDestroy$1();
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var etag = requireEtag();
  var fresh = requireFresh();
  var fs2 = require$$1$3;
  var mime2 = requireMime();
  var ms2 = requireMs$3();
  var onFinished2 = requireOnFinished();
  var parseRange = requireRangeParser();
  var path2 = require$$0$6;
  var statuses2 = requireStatuses();
  var Stream2 = require$$0$4;
  var util2 = require$$1$1;
  var extname = path2.extname;
  var join = path2.join;
  var normalize2 = path2.normalize;
  var resolve2 = path2.resolve;
  var sep = path2.sep;
  var BYTES_RANGE_REGEXP = /^ *bytes=/;
  var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
  var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
  send.exports = send$1;
  send.exports.mime = mime2;
  function send$1(req, path3, options) {
    return new SendStream(req, path3, options);
  }
  function SendStream(req, path3, options) {
    Stream2.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path3;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
    if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
      throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._hidden = Boolean(opts.hidden);
    if (opts.hidden !== void 0) {
      deprecate("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
    }
    if (opts.dotfiles === void 0) {
      this._dotfiles = void 0;
    }
    this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
    this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
    this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
    this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === "string" ? ms2(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve2(opts.root) : null;
    if (!this._root && opts.from) {
      this.from(opts.from);
    }
  }
  util2.inherits(SendStream, Stream2);
  SendStream.prototype.etag = deprecate.function(function etag2(val) {
    this._etag = Boolean(val);
    debug2("etag %s", this._etag);
    return this;
  }, "send.etag: pass etag as option");
  SendStream.prototype.hidden = deprecate.function(function hidden(val) {
    this._hidden = Boolean(val);
    this._dotfiles = void 0;
    debug2("hidden %s", this._hidden);
    return this;
  }, "send.hidden: use dotfiles option");
  SendStream.prototype.index = deprecate.function(function index(paths) {
    var index2 = !paths ? [] : normalizeList(paths, "paths argument");
    debug2("index %o", paths);
    this._index = index2;
    return this;
  }, "send.index: pass index as option");
  SendStream.prototype.root = function root(path3) {
    this._root = resolve2(String(path3));
    debug2("root %s", this._root);
    return this;
  };
  SendStream.prototype.from = deprecate.function(
    SendStream.prototype.root,
    "send.from: pass root as option"
  );
  SendStream.prototype.root = deprecate.function(
    SendStream.prototype.root,
    "send.root: pass root as option"
  );
  SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
    this._maxage = typeof maxAge === "string" ? ms2(maxAge) : Number(maxAge);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    debug2("max-age %d", this._maxage);
    return this;
  }, "send.maxage: pass maxAge as option");
  SendStream.prototype.error = function error2(status, err) {
    if (hasListeners(this, "error")) {
      return this.emit("error", createHttpError(status, err));
    }
    var res = this.res;
    var msg = statuses2.message[status] || String(status);
    var doc = createHtmlDocument("Error", escapeHtml(msg));
    clearHeaders(res);
    if (err && err.headers) {
      setHeaders(res, err.headers);
    }
    res.statusCode = status;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(doc);
  };
  SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === "/";
  };
  SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
  };
  SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;
    var match = req.headers["if-match"];
    if (match) {
      var etag2 = res.getHeader("ETag");
      return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
        return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
      });
    }
    var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
    if (!isNaN(unmodifiedSince)) {
      var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
      return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
  };
  SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    res.removeHeader("Content-Encoding");
    res.removeHeader("Content-Language");
    res.removeHeader("Content-Length");
    res.removeHeader("Content-Range");
    res.removeHeader("Content-Type");
  };
  SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug2("not modified");
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
  };
  SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error("Can't set headers after they are sent.");
    debug2("headers already sent");
    this.error(500, err);
  };
  SendStream.prototype.isCachable = function isCachable() {
    var statusCode = this.res.statusCode;
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
  };
  SendStream.prototype.onStatError = function onStatError(error2) {
    switch (error2.code) {
      case "ENAMETOOLONG":
      case "ENOENT":
      case "ENOTDIR":
        this.error(404, error2);
        break;
      default:
        this.error(500, error2);
        break;
    }
  };
  SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
      etag: this.res.getHeader("ETag"),
      "last-modified": this.res.getHeader("Last-Modified")
    });
  };
  SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers["if-range"];
    if (!ifRange) {
      return true;
    }
    if (ifRange.indexOf('"') !== -1) {
      var etag2 = this.res.getHeader("ETag");
      return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
    }
    var lastModified = this.res.getHeader("Last-Modified");
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
  };
  SendStream.prototype.redirect = function redirect(path3) {
    var res = this.res;
    if (hasListeners(this, "directory")) {
      this.emit("directory", res, path3);
      return;
    }
    if (this.hasTrailingSlash()) {
      this.error(403);
      return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
    var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
    res.statusCode = 301;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Location", loc);
    res.end(doc);
  };
  SendStream.prototype.pipe = function pipe2(res) {
    var root = this._root;
    this.res = res;
    var path3 = decode(this.path);
    if (path3 === -1) {
      this.error(400);
      return res;
    }
    if (~path3.indexOf("\0")) {
      this.error(400);
      return res;
    }
    var parts;
    if (root !== null) {
      if (path3) {
        path3 = normalize2("." + sep + path3);
      }
      if (UP_PATH_REGEXP.test(path3)) {
        debug2('malicious path "%s"', path3);
        this.error(403);
        return res;
      }
      parts = path3.split(sep);
      path3 = normalize2(join(root, path3));
    } else {
      if (UP_PATH_REGEXP.test(path3)) {
        debug2('malicious path "%s"', path3);
        this.error(403);
        return res;
      }
      parts = normalize2(path3).split(sep);
      path3 = resolve2(path3);
    }
    if (containsDotFile(parts)) {
      var access = this._dotfiles;
      if (access === void 0) {
        access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
      }
      debug2('%s dotfile "%s"', access, path3);
      switch (access) {
        case "allow":
          break;
        case "deny":
          this.error(403);
          return res;
        case "ignore":
        default:
          this.error(404);
          return res;
      }
    }
    if (this._index.length && this.hasTrailingSlash()) {
      this.sendIndex(path3);
      return res;
    }
    this.sendFile(path3);
    return res;
  };
  SendStream.prototype.send = function send2(path3, stat) {
    var len = stat.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (headersSent(res)) {
      this.headersAlreadySent();
      return;
    }
    debug2('pipe "%s"', path3);
    this.setHeader(path3, stat);
    this.type(path3);
    if (this.isConditionalGET()) {
      if (this.isPreconditionFailure()) {
        this.error(412);
        return;
      }
      if (this.isCachable() && this.isFresh()) {
        this.notModified();
        return;
      }
    }
    len = Math.max(0, len - offset);
    if (options.end !== void 0) {
      var bytes2 = options.end - offset + 1;
      if (len > bytes2)
        len = bytes2;
    }
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
      ranges = parseRange(len, ranges, {
        combine: true
      });
      if (!this.isRangeFresh()) {
        debug2("range stale");
        ranges = -2;
      }
      if (ranges === -1) {
        debug2("range unsatisfiable");
        res.setHeader("Content-Range", contentRange("bytes", len));
        return this.error(416, {
          headers: { "Content-Range": res.getHeader("Content-Range") }
        });
      }
      if (ranges !== -2 && ranges.length === 1) {
        debug2("range %j", ranges);
        res.statusCode = 206;
        res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
        offset += ranges[0].start;
        len = ranges[0].end - ranges[0].start + 1;
      }
    }
    for (var prop in options) {
      opts[prop] = options[prop];
    }
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);
    res.setHeader("Content-Length", len);
    if (req.method === "HEAD") {
      res.end();
      return;
    }
    this.stream(path3, opts);
  };
  SendStream.prototype.sendFile = function sendFile(path3) {
    var i = 0;
    var self2 = this;
    debug2('stat "%s"', path3);
    fs2.stat(path3, function onstat(err, stat) {
      if (err && err.code === "ENOENT" && !extname(path3) && path3[path3.length - 1] !== sep) {
        return next(err);
      }
      if (err)
        return self2.onStatError(err);
      if (stat.isDirectory())
        return self2.redirect(path3);
      self2.emit("file", path3, stat);
      self2.send(path3, stat);
    });
    function next(err) {
      if (self2._extensions.length <= i) {
        return err ? self2.onStatError(err) : self2.error(404);
      }
      var p = path3 + "." + self2._extensions[i++];
      debug2('stat "%s"', p);
      fs2.stat(p, function(err2, stat) {
        if (err2)
          return next(err2);
        if (stat.isDirectory())
          return next();
        self2.emit("file", p, stat);
        self2.send(p, stat);
      });
    }
  };
  SendStream.prototype.sendIndex = function sendIndex(path3) {
    var i = -1;
    var self2 = this;
    function next(err) {
      if (++i >= self2._index.length) {
        if (err)
          return self2.onStatError(err);
        return self2.error(404);
      }
      var p = join(path3, self2._index[i]);
      debug2('stat "%s"', p);
      fs2.stat(p, function(err2, stat) {
        if (err2)
          return next(err2);
        if (stat.isDirectory())
          return next();
        self2.emit("file", p, stat);
        self2.send(p, stat);
      });
    }
    next();
  };
  SendStream.prototype.stream = function stream2(path3, options) {
    var self2 = this;
    var res = this.res;
    var stream3 = fs2.createReadStream(path3, options);
    this.emit("stream", stream3);
    stream3.pipe(res);
    function cleanup() {
      destroy2(stream3, true);
    }
    onFinished2(res, cleanup);
    stream3.on("error", function onerror(err) {
      cleanup();
      self2.onStatError(err);
    });
    stream3.on("end", function onend() {
      self2.emit("end");
    });
  };
  SendStream.prototype.type = function type2(path3) {
    var res = this.res;
    if (res.getHeader("Content-Type"))
      return;
    var type3 = mime2.lookup(path3);
    if (!type3) {
      debug2("no content-type");
      return;
    }
    var charset2 = mime2.charsets.lookup(type3);
    debug2("content-type %s", type3);
    res.setHeader("Content-Type", type3 + (charset2 ? "; charset=" + charset2 : ""));
  };
  SendStream.prototype.setHeader = function setHeader(path3, stat) {
    var res = this.res;
    this.emit("headers", res, path3, stat);
    if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
      debug2("accept ranges");
      res.setHeader("Accept-Ranges", "bytes");
    }
    if (this._cacheControl && !res.getHeader("Cache-Control")) {
      var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
      if (this._immutable) {
        cacheControl += ", immutable";
      }
      debug2("cache-control %s", cacheControl);
      res.setHeader("Cache-Control", cacheControl);
    }
    if (this._lastModified && !res.getHeader("Last-Modified")) {
      var modified = stat.mtime.toUTCString();
      debug2("modified %s", modified);
      res.setHeader("Last-Modified", modified);
    }
    if (this._etag && !res.getHeader("ETag")) {
      var val = etag(stat);
      debug2("etag %s", val);
      res.setHeader("ETag", val);
    }
  };
  function clearHeaders(res) {
    var headers = getHeaderNames(res);
    for (var i = 0; i < headers.length; i++) {
      res.removeHeader(headers[i]);
    }
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str[i] !== "/") {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function containsDotFile(parts) {
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];
      if (part.length > 1 && part[0] === ".") {
        return true;
      }
    }
    return false;
  }
  function contentRange(type2, size, range2) {
    return type2 + " " + (range2 ? range2.start + "-" + range2.end : "*") + "/" + size;
  }
  function createHtmlDocument(title2, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title2 + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createHttpError(status, err) {
    if (!err) {
      return createError(status);
    }
    return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
  }
  function decode(path3) {
    try {
      return decodeURIComponent(path3);
    } catch (err) {
      return -1;
    }
  }
  function getHeaderNames(res) {
    return typeof res.getHeaderNames !== "function" ? Object.keys(res._headers || {}) : res.getHeaderNames();
  }
  function hasListeners(emitter, type2) {
    var count2 = typeof emitter.listenerCount !== "function" ? emitter.listeners(type2).length : emitter.listenerCount(type2);
    return count2 > 0;
  }
  function headersSent(res) {
    return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
  }
  function normalizeList(val, name) {
    var list = [].concat(val || []);
    for (var i = 0; i < list.length; i++) {
      if (typeof list[i] !== "string") {
        throw new TypeError(name + " must be array of strings or false");
      }
    }
    return list;
  }
  function parseHttpDate(date) {
    var timestamp2 = date && Date.parse(date);
    return typeof timestamp2 === "number" ? timestamp2 : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(str.substring(start, end));
          }
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    if (start !== end) {
      list.push(str.substring(start, end));
    }
    return list;
  }
  function setHeaders(res, headers) {
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      res.setHeader(key, headers[key]);
    }
  }
  return send.exports;
}
var proxyAddr = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var forwarded_1;
var hasRequiredForwarded;
function requireForwarded() {
  if (hasRequiredForwarded)
    return forwarded_1;
  hasRequiredForwarded = 1;
  forwarded_1 = forwarded;
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse2(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  }
  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }
  function parse2(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1; i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
  return forwarded_1;
}
var ipaddr = { exports: {} };
ipaddr.exports;
var hasRequiredIpaddr;
function requireIpaddr() {
  if (hasRequiredIpaddr)
    return ipaddr.exports;
  hasRequiredIpaddr = 1;
  (function(module2) {
    (function() {
      var expandIPv6, ipaddr2, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;
      ipaddr2 = {};
      root = this;
      if (module2 !== null && module2.exports) {
        module2.exports = ipaddr2;
      } else {
        root["ipaddr"] = ipaddr2;
      }
      matchCIDR = function(first2, second, partSize, cidrBits) {
        var part, shift;
        if (first2.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first2[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr2.IPv4 = function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref2;
          if (cidrRange === void 0) {
            ref2 = other, other = ref2[0], cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      }();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr2.IPv4.parser = function(string) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string2) {
          if (string2[0] === "0" && string2[1] !== "x") {
            return parseInt(string2, 8);
          } else {
            return parseInt(string2);
          }
        };
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            var k, len, ref2, results;
            ref2 = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else {
          return null;
        }
      };
      ipaddr2.IPv6 = function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref2;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref2 = this.parts;
          for (l = 0, len = ref2.length; l < len; l++) {
            part = ref2[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex, string;
          regex = /((^|:)(0(:|$)){2,})/g;
          string = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes2, k, len, part, ref2;
          bytes2 = [];
          ref2 = this.parts;
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref2, results;
            ref2 = this.parts;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(part.toString(16));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = function() {
            var k, len, ref2, results;
            ref2 = this.parts;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }.call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref2;
          if (cidrRange === void 0) {
            ref2 = other, other = ref2[0], cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref2;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      }();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          var k, len, ref2, results;
          ref2 = string.split(":");
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(parseInt(part, 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      };
      ipaddr2.IPv6.parser = function(string) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string)) {
          return expandIPv6(string, 8);
        } else if (match = string.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr2.IPv4.isValid = function(string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr2.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv6.isValid = function(string) {
        var addr;
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr2.IPv4.parse = function(string) {
        var parts;
        parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr2.IPv6.parse = function(string) {
        var addr;
        addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv4.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv6.parseCIDR = function(string) {
        var maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.isValid = function(string) {
        return ipaddr2.IPv6.isValid(string) || ipaddr2.IPv4.isValid(string);
      };
      ipaddr2.parse = function(string) {
        if (ipaddr2.IPv6.isValid(string)) {
          return ipaddr2.IPv6.parse(string);
        } else if (ipaddr2.IPv4.isValid(string)) {
          return ipaddr2.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string) {
        try {
          return ipaddr2.IPv6.parseCIDR(string);
        } catch (error1) {
          try {
            return ipaddr2.IPv4.parseCIDR(string);
          } catch (error12) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.fromByteArray = function(bytes2) {
        var length;
        length = bytes2.length;
        if (length === 4) {
          return new ipaddr2.IPv4(bytes2);
        } else if (length === 16) {
          return new ipaddr2.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.process = function(string) {
        var addr;
        addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(commonjsGlobal);
  })(ipaddr);
  return ipaddr.exports;
}
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredProxyAddr;
function requireProxyAddr() {
  if (hasRequiredProxyAddr)
    return proxyAddr.exports;
  hasRequiredProxyAddr = 1;
  proxyAddr.exports = proxyaddr;
  proxyAddr.exports.all = alladdrs;
  proxyAddr.exports.compile = compile2;
  var forwarded = requireForwarded();
  var ipaddr2 = requireIpaddr();
  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr2.isValid;
  var parseip = ipaddr2.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req, trust) {
    var addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile2(trust);
    }
    for (var i = 0; i < addrs.length - 1; i++) {
      if (trust(addrs[i], i))
        continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile2(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    var trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (var i = 0; i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    var pos = note.lastIndexOf("/");
    var str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    var ip = parseip(str);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    var max2 = ip.kind() === "ipv6" ? 128 : 32;
    var range2 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range2 === null) {
      range2 = max2;
    } else if (DIGIT_REGEXP.test(range2)) {
      range2 = parseInt(range2, 10);
    } else if (ip.kind() === "ipv4" && isip(range2)) {
      range2 = parseNetmask(range2);
    } else {
      range2 = null;
    }
    if (range2 <= 0 || range2 > max2) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range2];
  }
  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0; i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === "ipv4";
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr))
        return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
  return proxyAddr.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1)
    return utils$5;
  hasRequiredUtils$1 = 1;
  (function(exports2) {
    var Buffer2 = requireSafeBuffer$2().Buffer;
    var contentDisposition2 = requireContentDisposition();
    var contentType2 = requireContentType();
    var deprecate = requireDepd()("express");
    var flatten2 = requireArrayFlatten();
    var mime2 = requireSend().mime;
    var etag = requireEtag();
    var proxyaddr = requireProxyAddr();
    var qs = requireLib$2();
    var querystring = require$$8;
    exports2.etag = createETagGenerator({ weak: false });
    exports2.wetag = createETagGenerator({ weak: true });
    exports2.isAbsolute = function(path2) {
      if ("/" === path2[0])
        return true;
      if (":" === path2[1] && ("\\" === path2[2] || "/" === path2[2]))
        return true;
      if ("\\\\" === path2.substring(0, 2))
        return true;
    };
    exports2.flatten = deprecate.function(
      flatten2,
      "utils.flatten: use array-flatten npm module instead"
    );
    exports2.normalizeType = function(type2) {
      return ~type2.indexOf("/") ? acceptParams(type2) : { value: mime2.lookup(type2), params: {} };
    };
    exports2.normalizeTypes = function(types2) {
      var ret = [];
      for (var i = 0; i < types2.length; ++i) {
        ret.push(exports2.normalizeType(types2[i]));
      }
      return ret;
    };
    exports2.contentDisposition = deprecate.function(
      contentDisposition2,
      "utils.contentDisposition: use content-disposition npm module instead"
    );
    function acceptParams(str, index) {
      var parts = str.split(/ *; */);
      var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
      for (var i = 1; i < parts.length; ++i) {
        var pms = parts[i].split(/ *= */);
        if ("q" === pms[0]) {
          ret.quality = parseFloat(pms[1]);
        } else {
          ret.params[pms[0]] = pms[1];
        }
      }
      return ret;
    }
    exports2.compileETag = function(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "weak":
          fn = exports2.wetag;
          break;
        case false:
          break;
        case "strong":
          fn = exports2.etag;
          break;
        default:
          throw new TypeError("unknown value for etag function: " + val);
      }
      return fn;
    };
    exports2.compileQueryParser = function compileQueryParser(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "simple":
          fn = querystring.parse;
          break;
        case false:
          fn = newObject;
          break;
        case "extended":
          fn = parseExtendedQueryString;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + val);
      }
      return fn;
    };
    exports2.compileTrust = function(val) {
      if (typeof val === "function")
        return val;
      if (val === true) {
        return function() {
          return true;
        };
      }
      if (typeof val === "number") {
        return function(a, i) {
          return i < val;
        };
      }
      if (typeof val === "string") {
        val = val.split(",").map(function(v) {
          return v.trim();
        });
      }
      return proxyaddr.compile(val || []);
    };
    exports2.setCharset = function setCharset(type2, charset2) {
      if (!type2 || !charset2) {
        return type2;
      }
      var parsed = contentType2.parse(type2);
      parsed.parameters.charset = charset2;
      return contentType2.format(parsed);
    };
    function createETagGenerator(options) {
      return function generateETag(body, encoding2) {
        var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding2) : body;
        return etag(buf, options);
      };
    }
    function parseExtendedQueryString(str) {
      return qs.parse(str, {
        allowPrototypes: true
      });
    }
    function newObject() {
      return {};
    }
  })(utils$5);
  return utils$5;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredApplication;
function requireApplication() {
  if (hasRequiredApplication)
    return application.exports;
  hasRequiredApplication = 1;
  (function(module2, exports2) {
    var finalhandler = requireFinalhandler();
    var Router = requireRouter$1();
    var methods2 = requireMethods();
    var middleware2 = requireInit();
    var query2 = requireQuery();
    var debug2 = requireSrc()("express:application");
    var View = requireView();
    var http3 = require$$7$2;
    var compileETag = requireUtils$1().compileETag;
    var compileQueryParser = requireUtils$1().compileQueryParser;
    var compileTrust = requireUtils$1().compileTrust;
    var deprecate = requireDepd()("express");
    var flatten2 = requireArrayFlatten();
    var merge2 = requireUtilsMerge();
    var resolve2 = require$$0$6.resolve;
    var setPrototypeOf = requireSetprototypeof();
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var slice2 = Array.prototype.slice;
    var app2 = module2.exports = {};
    var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
    app2.init = function init2() {
      this.cache = {};
      this.engines = {};
      this.settings = {};
      this.defaultConfiguration();
    };
    app2.defaultConfiguration = function defaultConfiguration() {
      var env2 = process.env.NODE_ENV || "development";
      this.enable("x-powered-by");
      this.set("etag", "weak");
      this.set("env", env2);
      this.set("query parser", "extended");
      this.set("subdomain offset", 2);
      this.set("trust proxy", false);
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
      debug2("booting in %s mode", env2);
      this.on("mount", function onmount(parent) {
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
          delete this.settings["trust proxy"];
          delete this.settings["trust proxy fn"];
        }
        setPrototypeOf(this.request, parent.request);
        setPrototypeOf(this.response, parent.response);
        setPrototypeOf(this.engines, parent.engines);
        setPrototypeOf(this.settings, parent.settings);
      });
      this.locals = /* @__PURE__ */ Object.create(null);
      this.mountpath = "/";
      this.locals.settings = this.settings;
      this.set("view", View);
      this.set("views", resolve2("views"));
      this.set("jsonp callback name", "callback");
      if (env2 === "production") {
        this.enable("view cache");
      }
      Object.defineProperty(this, "router", {
        get: function() {
          throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
        }
      });
    };
    app2.lazyrouter = function lazyrouter() {
      if (!this._router) {
        this._router = new Router({
          caseSensitive: this.enabled("case sensitive routing"),
          strict: this.enabled("strict routing")
        });
        this._router.use(query2(this.get("query parser fn")));
        this._router.use(middleware2.init(this));
      }
    };
    app2.handle = function handle(req, res, callback) {
      var router2 = this._router;
      var done = callback || finalhandler(req, res, {
        env: this.get("env"),
        onerror: logerror.bind(this)
      });
      if (!router2) {
        debug2("no routes defined on app");
        done();
        return;
      }
      router2.handle(req, res, done);
    };
    app2.use = function use(fn) {
      var offset = 0;
      var path2 = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path2 = fn;
        }
      }
      var fns = flatten2(slice2.call(arguments, offset));
      if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
      }
      this.lazyrouter();
      var router2 = this._router;
      fns.forEach(function(fn2) {
        if (!fn2 || !fn2.handle || !fn2.set) {
          return router2.use(path2, fn2);
        }
        debug2(".use app under %s", path2);
        fn2.mountpath = path2;
        fn2.parent = this;
        router2.use(path2, function mounted_app(req, res, next) {
          var orig = req.app;
          fn2.handle(req, res, function(err) {
            setPrototypeOf(req, orig.request);
            setPrototypeOf(res, orig.response);
            next(err);
          });
        });
        fn2.emit("mount", this);
      }, this);
      return this;
    };
    app2.route = function route2(path2) {
      this.lazyrouter();
      return this._router.route(path2);
    };
    app2.engine = function engine(ext, fn) {
      if (typeof fn !== "function") {
        throw new Error("callback function required");
      }
      var extension = ext[0] !== "." ? "." + ext : ext;
      this.engines[extension] = fn;
      return this;
    };
    app2.param = function param(name, fn) {
      this.lazyrouter();
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          this.param(name[i], fn);
        }
        return this;
      }
      this._router.param(name, fn);
      return this;
    };
    app2.set = function set(setting, val) {
      if (arguments.length === 1) {
        var settings = this.settings;
        while (settings && settings !== Object.prototype) {
          if (hasOwnProperty2.call(settings, setting)) {
            return settings[setting];
          }
          settings = Object.getPrototypeOf(settings);
        }
        return void 0;
      }
      debug2('set "%s" to %o', setting, val);
      this.settings[setting] = val;
      switch (setting) {
        case "etag":
          this.set("etag fn", compileETag(val));
          break;
        case "query parser":
          this.set("query parser fn", compileQueryParser(val));
          break;
        case "trust proxy":
          this.set("trust proxy fn", compileTrust(val));
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
          break;
      }
      return this;
    };
    app2.path = function path2() {
      return this.parent ? this.parent.path() + this.mountpath : "";
    };
    app2.enabled = function enabled(setting) {
      return Boolean(this.set(setting));
    };
    app2.disabled = function disabled(setting) {
      return !this.set(setting);
    };
    app2.enable = function enable(setting) {
      return this.set(setting, true);
    };
    app2.disable = function disable(setting) {
      return this.set(setting, false);
    };
    methods2.forEach(function(method) {
      app2[method] = function(path2) {
        if (method === "get" && arguments.length === 1) {
          return this.set(path2);
        }
        this.lazyrouter();
        var route2 = this._router.route(path2);
        route2[method].apply(route2, slice2.call(arguments, 1));
        return this;
      };
    });
    app2.all = function all3(path2) {
      this.lazyrouter();
      var route2 = this._router.route(path2);
      var args2 = slice2.call(arguments, 1);
      for (var i = 0; i < methods2.length; i++) {
        route2[methods2[i]].apply(route2, args2);
      }
      return this;
    };
    app2.del = deprecate.function(app2.delete, "app.del: Use app.delete instead");
    app2.render = function render(name, options, callback) {
      var cache2 = this.cache;
      var done = callback;
      var engines = this.engines;
      var opts = options;
      var renderOptions = {};
      var view2;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      merge2(renderOptions, this.locals);
      if (opts._locals) {
        merge2(renderOptions, opts._locals);
      }
      merge2(renderOptions, opts);
      if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
      }
      if (renderOptions.cache) {
        view2 = cache2[name];
      }
      if (!view2) {
        var View2 = this.get("view");
        view2 = new View2(name, {
          defaultEngine: this.get("view engine"),
          root: this.get("views"),
          engines
        });
        if (!view2.path) {
          var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? 'directories "' + view2.root.slice(0, -1).join('", "') + '" or "' + view2.root[view2.root.length - 1] + '"' : 'directory "' + view2.root + '"';
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view2;
          return done(err);
        }
        if (renderOptions.cache) {
          cache2[name] = view2;
        }
      }
      tryRender(view2, renderOptions, done);
    };
    app2.listen = function listen() {
      var server = http3.createServer(this);
      return server.listen.apply(server, arguments);
    };
    function logerror(err) {
      if (this.get("env") !== "test")
        console.error(err.stack || err.toString());
    }
    function tryRender(view2, options, callback) {
      try {
        view2.render(options, callback);
      } catch (err) {
        callback(err);
      }
    }
  })(application);
  return application.exports;
}
var negotiator = { exports: {} };
var charset = { exports: {} };
var hasRequiredCharset;
function requireCharset() {
  if (hasRequiredCharset)
    return charset.exports;
  hasRequiredCharset = 1;
  charset.exports = preferredCharsets;
  charset.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts2 = accept.split(",");
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var charset2 = parseCharset(accepts2[i].trim(), i);
      if (charset2) {
        accepts2[j++] = charset2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match)
      return null;
    var charset2 = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset: charset2,
      q,
      i
    };
  }
  function getCharsetPriority(charset2, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset2, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset2, spec, index) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset2.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type2, index) {
      return getCharsetPriority(type2, accepts2, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return charset.exports;
}
var encoding = { exports: {} };
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding)
    return encoding.exports;
  hasRequiredEncoding = 1;
  encoding.exports = preferredEncodings;
  encoding.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts2 = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var encoding2 = parseEncoding(accepts2[i].trim(), i);
      if (encoding2) {
        accepts2[j++] = encoding2;
        hasIdentity = hasIdentity || specify("identity", encoding2);
        minQuality = Math.min(minQuality, encoding2.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts2[j++] = {
        encoding: "identity",
        q: minQuality,
        i
      };
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match)
      return null;
    var encoding2 = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding: encoding2,
      q,
      i
    };
  }
  function getEncodingPriority(encoding2, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding2, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding2, spec, index) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding2.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredEncodings(accept, provided) {
    var accepts2 = parseAcceptEncoding(accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type2, index) {
      return getEncodingPriority(type2, accepts2, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return encoding.exports;
}
var language = { exports: {} };
var hasRequiredLanguage;
function requireLanguage() {
  if (hasRequiredLanguage)
    return language.exports;
  hasRequiredLanguage = 1;
  language.exports = preferredLanguages;
  language.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts2 = accept.split(",");
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var language2 = parseLanguage(accepts2[i].trim(), i);
      if (language2) {
        accepts2[j++] = language2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match)
      return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix)
      full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].split("=");
        if (p[0] === "q")
          q = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q,
      i,
      full
    };
  }
  function getLanguagePriority(language2, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language2, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language2, spec, index) {
    var p = parseLanguage(language2);
    if (!p)
      return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type2, index) {
      return getLanguagePriority(type2, accepts2, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return language.exports;
}
var mediaType = { exports: {} };
var hasRequiredMediaType;
function requireMediaType() {
  if (hasRequiredMediaType)
    return mediaType.exports;
  hasRequiredMediaType = 1;
  mediaType.exports = preferredMediaTypes;
  mediaType.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts2 = splitMediaTypes(accept);
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var mediaType2 = parseMediaType(accepts2[i].trim(), i);
      if (mediaType2) {
        accepts2[j++] = mediaType2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match)
      return null;
    var params = /* @__PURE__ */ Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type2 = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0; j < kvps.length; j++) {
        var pair = kvps[j];
        var key = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
        if (key === "q") {
          q = parseFloat(value);
          break;
        }
        params[key] = value;
      }
    }
    return {
      type: type2,
      subtype,
      params,
      q,
      i
    };
  }
  function getMediaTypePriority(type2, accepted, index) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type2, accepted[i], index);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type2, spec, index) {
    var p = parseMediaType(type2);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type2, index) {
      return getMediaTypePriority(type2, accepts2, index);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string) {
    var count2 = 0;
    var index = 0;
    while ((index = string.indexOf('"', index)) !== -1) {
      count2++;
      index++;
    }
    return count2;
  }
  function splitKeyValuePair(str) {
    var index = str.indexOf("=");
    var key;
    var val;
    if (index === -1) {
      key = str;
    } else {
      key = str.substr(0, index);
      val = str.substr(index + 1);
    }
    return [key, val];
  }
  function splitMediaTypes(accept) {
    var accepts2 = accept.split(",");
    for (var i = 1, j = 0; i < accepts2.length; i++) {
      if (quoteCount(accepts2[j]) % 2 == 0) {
        accepts2[++j] = accepts2[i];
      } else {
        accepts2[j] += "," + accepts2[i];
      }
    }
    accepts2.length = j + 1;
    return accepts2;
  }
  function splitParameters(str) {
    var parameters = str.split(";");
    for (var i = 1, j = 0; i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ";" + parameters[i];
      }
    }
    parameters.length = j + 1;
    for (var i = 0; i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
  return mediaType.exports;
}
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredNegotiator;
function requireNegotiator() {
  if (hasRequiredNegotiator)
    return negotiator.exports;
  hasRequiredNegotiator = 1;
  var preferredCharsets = requireCharset();
  var preferredEncodings = requireEncoding();
  var preferredLanguages = requireLanguage();
  var preferredMediaTypes = requireMediaType();
  negotiator.exports = Negotiator;
  negotiator.exports.Negotiator = Negotiator;
  function Negotiator(request2) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request2);
    }
    this.request = request2;
  }
  Negotiator.prototype.charset = function charset2(available) {
    var set = this.charsets(available);
    return set && set[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding2(available) {
    var set = this.encodings(available);
    return set && set[0];
  };
  Negotiator.prototype.encodings = function encodings2(available) {
    return preferredEncodings(this.request.headers["accept-encoding"], available);
  };
  Negotiator.prototype.language = function language2(available) {
    var set = this.languages(available);
    return set && set[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType2(available) {
    var set = this.mediaTypes(available);
    return set && set[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  return negotiator.exports;
}
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts;
var hasRequiredAccepts;
function requireAccepts() {
  if (hasRequiredAccepts)
    return accepts;
  hasRequiredAccepts = 1;
  var Negotiator = requireNegotiator();
  var mime2 = mimeTypes;
  accepts = Accepts;
  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types2 = types_;
    if (types2 && !Array.isArray(types2)) {
      types2 = new Array(arguments.length);
      for (var i = 0; i < types2.length; i++) {
        types2[i] = arguments[i];
      }
    }
    if (!types2 || types2.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types2[0];
    }
    var mimes = types2.map(extToMime);
    var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first2 = accepts2[0];
    return first2 ? types2[mimes.indexOf(first2)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings2 = encodings_;
    if (encodings2 && !Array.isArray(encodings2)) {
      encodings2 = new Array(arguments.length);
      for (var i = 0; i < encodings2.length; i++) {
        encodings2[i] = arguments[i];
      }
    }
    if (!encodings2 || encodings2.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings2)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0; i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0; i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
  function extToMime(type2) {
    return type2.indexOf("/") === -1 ? mime2.lookup(type2) : type2;
  }
  function validMime(type2) {
    return typeof type2 === "string";
  }
  return accepts;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var request$1;
var hasRequiredRequest$1;
function requireRequest$1() {
  if (hasRequiredRequest$1)
    return request$1;
  hasRequiredRequest$1 = 1;
  var accepts2 = requireAccepts();
  var deprecate = requireDepd()("express");
  var isIP = require$$4$1.isIP;
  var typeis = requireTypeIs();
  var http3 = require$$7$2;
  var fresh = requireFresh();
  var parseRange = requireRangeParser();
  var parse2 = requireParseurl();
  var proxyaddr = requireProxyAddr();
  var req = Object.create(http3.IncomingMessage.prototype);
  request$1 = req;
  req.get = req.header = function header(name) {
    if (!name) {
      throw new TypeError("name argument is required to req.get");
    }
    if (typeof name !== "string") {
      throw new TypeError("name must be a string to req.get");
    }
    var lc = name.toLowerCase();
    switch (lc) {
      case "referer":
      case "referrer":
        return this.headers.referrer || this.headers.referer;
      default:
        return this.headers[lc];
    }
  };
  req.accepts = function() {
    var accept = accepts2(this);
    return accept.types.apply(accept, arguments);
  };
  req.acceptsEncodings = function() {
    var accept = accepts2(this);
    return accept.encodings.apply(accept, arguments);
  };
  req.acceptsEncoding = deprecate.function(
    req.acceptsEncodings,
    "req.acceptsEncoding: Use acceptsEncodings instead"
  );
  req.acceptsCharsets = function() {
    var accept = accepts2(this);
    return accept.charsets.apply(accept, arguments);
  };
  req.acceptsCharset = deprecate.function(
    req.acceptsCharsets,
    "req.acceptsCharset: Use acceptsCharsets instead"
  );
  req.acceptsLanguages = function() {
    var accept = accepts2(this);
    return accept.languages.apply(accept, arguments);
  };
  req.acceptsLanguage = deprecate.function(
    req.acceptsLanguages,
    "req.acceptsLanguage: Use acceptsLanguages instead"
  );
  req.range = function range2(size, options) {
    var range3 = this.get("Range");
    if (!range3)
      return;
    return parseRange(size, range3, options);
  };
  req.param = function param(name, defaultValue) {
    var params = this.params || {};
    var body = this.body || {};
    var query2 = this.query || {};
    var args2 = arguments.length === 1 ? "name" : "name, default";
    deprecate("req.param(" + args2 + "): Use req.params, req.body, or req.query instead");
    if (null != params[name] && params.hasOwnProperty(name))
      return params[name];
    if (null != body[name])
      return body[name];
    if (null != query2[name])
      return query2[name];
    return defaultValue;
  };
  req.is = function is(types2) {
    var arr = types2;
    if (!Array.isArray(types2)) {
      arr = new Array(arguments.length);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = arguments[i];
      }
    }
    return typeis(this, arr);
  };
  defineGetter(req, "protocol", function protocol() {
    var proto = this.connection.encrypted ? "https" : "http";
    var trust = this.app.get("trust proxy fn");
    if (!trust(this.connection.remoteAddress, 0)) {
      return proto;
    }
    var header = this.get("X-Forwarded-Proto") || proto;
    var index = header.indexOf(",");
    return index !== -1 ? header.substring(0, index).trim() : header.trim();
  });
  defineGetter(req, "secure", function secure() {
    return this.protocol === "https";
  });
  defineGetter(req, "ip", function ip() {
    var trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
  });
  defineGetter(req, "ips", function ips() {
    var trust = this.app.get("trust proxy fn");
    var addrs = proxyaddr.all(this, trust);
    addrs.reverse().pop();
    return addrs;
  });
  defineGetter(req, "subdomains", function subdomains() {
    var hostname = this.hostname;
    if (!hostname)
      return [];
    var offset = this.app.get("subdomain offset");
    var subdomains2 = !isIP(hostname) ? hostname.split(".").reverse() : [hostname];
    return subdomains2.slice(offset);
  });
  defineGetter(req, "path", function path2() {
    return parse2(this).pathname;
  });
  defineGetter(req, "hostname", function hostname() {
    var trust = this.app.get("trust proxy fn");
    var host = this.get("X-Forwarded-Host");
    if (!host || !trust(this.connection.remoteAddress, 0)) {
      host = this.get("Host");
    } else if (host.indexOf(",") !== -1) {
      host = host.substring(0, host.indexOf(",")).trimRight();
    }
    if (!host)
      return;
    var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
    var index = host.indexOf(":", offset);
    return index !== -1 ? host.substring(0, index) : host;
  });
  defineGetter(req, "host", deprecate.function(function host() {
    return this.hostname;
  }, "req.host: Use req.hostname instead"));
  defineGetter(req, "fresh", function() {
    var method = this.method;
    var res = this.res;
    var status = res.statusCode;
    if ("GET" !== method && "HEAD" !== method)
      return false;
    if (status >= 200 && status < 300 || 304 === status) {
      return fresh(this.headers, {
        "etag": res.get("ETag"),
        "last-modified": res.get("Last-Modified")
      });
    }
    return false;
  });
  defineGetter(req, "stale", function stale() {
    return !this.fresh;
  });
  defineGetter(req, "xhr", function xhr() {
    var val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
  });
  function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable: true,
      get: getter
    });
  }
  return request$1;
}
var cookieSignature = {};
var hasRequiredCookieSignature;
function requireCookieSignature() {
  if (hasRequiredCookieSignature)
    return cookieSignature;
  hasRequiredCookieSignature = 1;
  (function(exports2) {
    var crypto2 = require$$0$5;
    exports2.sign = function(val, secret) {
      if ("string" != typeof val)
        throw new TypeError("Cookie value must be provided as a string.");
      if ("string" != typeof secret)
        throw new TypeError("Secret string must be provided.");
      return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports2.unsign = function(val, secret) {
      if ("string" != typeof val)
        throw new TypeError("Signed cookie string must be provided.");
      if ("string" != typeof secret)
        throw new TypeError("Secret string must be provided.");
      var str = val.slice(0, val.lastIndexOf(".")), mac = exports2.sign(str, secret);
      return sha1(mac) == sha1(val) ? str : false;
    };
    function sha1(str) {
      return crypto2.createHash("sha1").update(str).digest("hex");
    }
  })(cookieSignature);
  return cookieSignature;
}
var cookie = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredCookie;
function requireCookie() {
  if (hasRequiredCookie)
    return cookie;
  hasRequiredCookie = 1;
  cookie.parse = parse2;
  cookie.serialize = serialize2;
  var __toString = Object.prototype.toString;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function parse2(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode;
    var index = 0;
    while (index < str.length) {
      var eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) {
        break;
      }
      var endIdx = str.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = str.length;
      } else if (endIdx < eqIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var key = str.slice(index, eqIdx).trim();
      if (void 0 === obj[key]) {
        var val = str.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        obj[key] = tryDecode(val, dec);
      }
      index = endIdx + 1;
    }
    return obj;
  }
  function serialize2(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode2;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (null != opt.maxAge) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate2(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function encode2(val) {
    return encodeURIComponent(val);
  }
  function isDate2(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
  }
  function tryDecode(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  }
  return cookie;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse)
    return response;
  hasRequiredResponse = 1;
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var contentDisposition2 = requireContentDisposition();
  var createError = requireHttpErrors();
  var deprecate = requireDepd()("express");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var http3 = require$$7$2;
  var isAbsolute = requireUtils$1().isAbsolute;
  var onFinished2 = requireOnFinished();
  var path2 = require$$0$6;
  var statuses2 = requireStatuses();
  var merge2 = requireUtilsMerge();
  var sign3 = requireCookieSignature().sign;
  var normalizeType = requireUtils$1().normalizeType;
  var normalizeTypes = requireUtils$1().normalizeTypes;
  var setCharset = requireUtils$1().setCharset;
  var cookie2 = requireCookie();
  var send2 = requireSend();
  var extname = path2.extname;
  var mime2 = send2.mime;
  var resolve2 = path2.resolve;
  var vary2 = requireVary();
  var res = Object.create(http3.ServerResponse.prototype);
  response = res;
  var charsetRegExp = /;\s*charset\s*=/;
  res.status = function status(code2) {
    if ((typeof code2 === "string" || Math.floor(code2) !== code2) && code2 > 99 && code2 < 1e3) {
      deprecate("res.status(" + JSON.stringify(code2) + "): use res.status(" + Math.floor(code2) + ") instead");
    }
    this.statusCode = code2;
    return this;
  };
  res.links = function(links) {
    var link = this.get("Link") || "";
    if (link)
      link += ", ";
    return this.set("Link", link + Object.keys(links).map(function(rel) {
      return "<" + links[rel] + '>; rel="' + rel + '"';
    }).join(", "));
  };
  res.send = function send3(body) {
    var chunk = body;
    var encoding2;
    var req = this.req;
    var type2;
    var app2 = this.app;
    if (arguments.length === 2) {
      if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
        deprecate("res.send(body, status): Use res.status(status).send(body) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.send(status, body): Use res.status(status).send(body) instead");
        this.statusCode = arguments[0];
        chunk = arguments[1];
      }
    }
    if (typeof chunk === "number" && arguments.length === 1) {
      if (!this.get("Content-Type")) {
        this.type("txt");
      }
      deprecate("res.send(status): Use res.sendStatus(status) instead");
      this.statusCode = chunk;
      chunk = statuses2.message[chunk];
    }
    switch (typeof chunk) {
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (Buffer2.isBuffer(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    if (typeof chunk === "string") {
      encoding2 = "utf8";
      type2 = this.get("Content-Type");
      if (typeof type2 === "string") {
        this.set("Content-Type", setCharset(type2, "utf-8"));
      }
    }
    var etagFn = app2.get("etag fn");
    var generateETag = !this.get("ETag") && typeof etagFn === "function";
    var len;
    if (chunk !== void 0) {
      if (Buffer2.isBuffer(chunk)) {
        len = chunk.length;
      } else if (!generateETag && chunk.length < 1e3) {
        len = Buffer2.byteLength(chunk, encoding2);
      } else {
        chunk = Buffer2.from(chunk, encoding2);
        encoding2 = void 0;
        len = chunk.length;
      }
      this.set("Content-Length", len);
    }
    var etag;
    if (generateETag && len !== void 0) {
      if (etag = etagFn(chunk, encoding2)) {
        this.set("ETag", etag);
      }
    }
    if (req.fresh)
      this.statusCode = 304;
    if (204 === this.statusCode || 304 === this.statusCode) {
      this.removeHeader("Content-Type");
      this.removeHeader("Content-Length");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (this.statusCode === 205) {
      this.set("Content-Length", "0");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (req.method === "HEAD") {
      this.end();
    } else {
      this.end(chunk, encoding2);
    }
    return this;
  };
  res.json = function json(obj) {
    var val = obj;
    if (arguments.length === 2) {
      if (typeof arguments[1] === "number") {
        deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
        this.statusCode = arguments[0];
        val = arguments[1];
      }
    }
    var app2 = this.app;
    var escape2 = app2.get("json escape");
    var replacer = app2.get("json replacer");
    var spaces = app2.get("json spaces");
    var body = stringify(val, replacer, spaces, escape2);
    if (!this.get("Content-Type")) {
      this.set("Content-Type", "application/json");
    }
    return this.send(body);
  };
  res.jsonp = function jsonp(obj) {
    var val = obj;
    if (arguments.length === 2) {
      if (typeof arguments[1] === "number") {
        deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
        this.statusCode = arguments[1];
      } else {
        deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
        this.statusCode = arguments[0];
        val = arguments[1];
      }
    }
    var app2 = this.app;
    var escape2 = app2.get("json escape");
    var replacer = app2.get("json replacer");
    var spaces = app2.get("json spaces");
    var body = stringify(val, replacer, spaces, escape2);
    var callback = this.req.query[app2.get("jsonp callback name")];
    if (!this.get("Content-Type")) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "application/json");
    }
    if (Array.isArray(callback)) {
      callback = callback[0];
    }
    if (typeof callback === "string" && callback.length !== 0) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "text/javascript");
      callback = callback.replace(/[^\[\]\w$.]/g, "");
      if (body === void 0) {
        body = "";
      } else if (typeof body === "string") {
        body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
    }
    return this.send(body);
  };
  res.sendStatus = function sendStatus(statusCode) {
    var body = statuses2.message[statusCode] || String(statusCode);
    this.statusCode = statusCode;
    this.type("txt");
    return this.send(body);
  };
  res.sendFile = function sendFile(path3, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (!path3) {
      throw new TypeError("path argument is required to res.sendFile");
    }
    if (typeof path3 !== "string") {
      throw new TypeError("path must be a string to res.sendFile");
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (!opts.root && !isAbsolute(path3)) {
      throw new TypeError("path must be absolute or specify root to res.sendFile");
    }
    var pathname = encodeURI(path3);
    var file2 = send2(req, pathname, opts);
    sendfile(res2, file2, opts, function(err) {
      if (done)
        return done(err);
      if (err && err.code === "EISDIR")
        return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.sendfile = function(path3, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    var file2 = send2(req, path3, opts);
    sendfile(res2, file2, opts, function(err) {
      if (done)
        return done(err);
      if (err && err.code === "EISDIR")
        return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.sendfile = deprecate.function(
    res.sendfile,
    "res.sendfile: Use res.sendFile instead"
  );
  res.download = function download(path3, filename, options, callback) {
    var done = callback;
    var name = filename;
    var opts = options || null;
    if (typeof filename === "function") {
      done = filename;
      name = null;
      opts = null;
    } else if (typeof options === "function") {
      done = options;
      opts = null;
    }
    if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
      name = null;
      opts = filename;
    }
    var headers = {
      "Content-Disposition": contentDisposition2(name || path3)
    };
    if (opts && opts.headers) {
      var keys = Object.keys(opts.headers);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.toLowerCase() !== "content-disposition") {
          headers[key] = opts.headers[key];
        }
      }
    }
    opts = Object.create(opts);
    opts.headers = headers;
    var fullPath = !opts.root ? resolve2(path3) : path3;
    return this.sendFile(fullPath, opts, done);
  };
  res.contentType = res.type = function contentType2(type2) {
    var ct = type2.indexOf("/") === -1 ? mime2.lookup(type2) : type2;
    return this.set("Content-Type", ct);
  };
  res.format = function(obj) {
    var req = this.req;
    var next = req.next;
    var keys = Object.keys(obj).filter(function(v) {
      return v !== "default";
    });
    var key = keys.length > 0 ? req.accepts(keys) : false;
    this.vary("Accept");
    if (key) {
      this.set("Content-Type", normalizeType(key).value);
      obj[key](req, this, next);
    } else if (obj.default) {
      obj.default(req, this, next);
    } else {
      next(createError(406, {
        types: normalizeTypes(keys).map(function(o) {
          return o.value;
        })
      }));
    }
    return this;
  };
  res.attachment = function attachment(filename) {
    if (filename) {
      this.type(extname(filename));
    }
    this.set("Content-Disposition", contentDisposition2(filename));
    return this;
  };
  res.append = function append2(field, val) {
    var prev = this.get(field);
    var value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(field, value);
  };
  res.set = res.header = function header(field, val) {
    if (arguments.length === 2) {
      var value = Array.isArray(val) ? val.map(String) : String(val);
      if (field.toLowerCase() === "content-type") {
        if (Array.isArray(value)) {
          throw new TypeError("Content-Type cannot be set to an Array");
        }
        if (!charsetRegExp.test(value)) {
          var charset2 = mime2.charsets.lookup(value.split(";")[0]);
          if (charset2)
            value += "; charset=" + charset2.toLowerCase();
        }
      }
      this.setHeader(field, value);
    } else {
      for (var key in field) {
        this.set(key, field[key]);
      }
    }
    return this;
  };
  res.get = function(field) {
    return this.getHeader(field);
  };
  res.clearCookie = function clearCookie(name, options) {
    var opts = merge2({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options);
    return this.cookie(name, "", opts);
  };
  res.cookie = function(name, value, options) {
    var opts = merge2({}, options);
    var secret = this.req.secret;
    var signed = opts.signed;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + sign3(val, secret);
    }
    if (opts.maxAge != null) {
      var maxAge = opts.maxAge - 0;
      if (!isNaN(maxAge)) {
        opts.expires = new Date(Date.now() + maxAge);
        opts.maxAge = Math.floor(maxAge / 1e3);
      }
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    this.append("Set-Cookie", cookie2.serialize(name, String(val), opts));
    return this;
  };
  res.location = function location(url2) {
    var loc = url2;
    if (url2 === "back") {
      loc = this.req.get("Referrer") || "/";
    }
    return this.set("Location", encodeUrl(loc));
  };
  res.redirect = function redirect(url2) {
    var address = url2;
    var body;
    var status = 302;
    if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        status = arguments[0];
        address = arguments[1];
      } else {
        deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
        status = arguments[1];
      }
    }
    address = this.location(address).get("Location");
    this.format({
      text: function() {
        body = statuses2.message[status] + ". Redirecting to " + address;
      },
      html: function() {
        var u = escapeHtml(address);
        body = "<p>" + statuses2.message[status] + '. Redirecting to <a href="' + u + '">' + u + "</a></p>";
      },
      default: function() {
        body = "";
      }
    });
    this.statusCode = status;
    this.set("Content-Length", Buffer2.byteLength(body));
    if (this.req.method === "HEAD") {
      this.end();
    } else {
      this.end(body);
    }
  };
  res.vary = function(field) {
    if (!field || Array.isArray(field) && !field.length) {
      deprecate("res.vary(): Provide a field name");
      return this;
    }
    vary2(this, field);
    return this;
  };
  res.render = function render(view2, options, callback) {
    var app2 = this.req.app;
    var done = callback;
    var opts = options || {};
    var req = this.req;
    var self2 = this;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    opts._locals = self2.locals;
    done = done || function(err, str) {
      if (err)
        return req.next(err);
      self2.send(str);
    };
    app2.render(view2, opts, done);
  };
  function sendfile(res2, file2, options, callback) {
    var done = false;
    var streaming;
    function onaborted() {
      if (done)
        return;
      done = true;
      var err = new Error("Request aborted");
      err.code = "ECONNABORTED";
      callback(err);
    }
    function ondirectory() {
      if (done)
        return;
      done = true;
      var err = new Error("EISDIR, read");
      err.code = "EISDIR";
      callback(err);
    }
    function onerror(err) {
      if (done)
        return;
      done = true;
      callback(err);
    }
    function onend() {
      if (done)
        return;
      done = true;
      callback();
    }
    function onfile() {
      streaming = false;
    }
    function onfinish(err) {
      if (err && err.code === "ECONNRESET")
        return onaborted();
      if (err)
        return onerror(err);
      if (done)
        return;
      setImmediate(function() {
        if (streaming !== false && !done) {
          onaborted();
          return;
        }
        if (done)
          return;
        done = true;
        callback();
      });
    }
    function onstream() {
      streaming = true;
    }
    file2.on("directory", ondirectory);
    file2.on("end", onend);
    file2.on("error", onerror);
    file2.on("file", onfile);
    file2.on("stream", onstream);
    onFinished2(res2, onfinish);
    if (options.headers) {
      file2.on("headers", function headers(res3) {
        var obj = options.headers;
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          res3.setHeader(k, obj[k]);
        }
      });
    }
    file2.pipe(res2);
  }
  function stringify(value, replacer, spaces, escape2) {
    var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
    if (escape2 && typeof json === "string") {
      json = json.replace(/[<>&]/g, function(c) {
        switch (c.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          default:
            return c;
        }
      });
    }
    return json;
  }
  return response;
}
var serveStatic = { exports: {} };
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredServeStatic;
function requireServeStatic() {
  if (hasRequiredServeStatic)
    return serveStatic.exports;
  hasRequiredServeStatic = 1;
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var parseUrl2 = requireParseurl();
  var resolve2 = require$$0$6.resolve;
  var send2 = requireSend();
  var url2 = require$$0$a;
  serveStatic.exports = serveStatic$1;
  serveStatic.exports.mime = send2.mime;
  function serveStatic$1(root, options) {
    if (!root) {
      throw new TypeError("root path required");
    }
    if (typeof root !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect = opts.redirect !== false;
    var setHeaders = opts.setHeaders;
    if (setHeaders && typeof setHeaders !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve2(root);
    var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req, res, next) {
      if (req.method !== "GET" && req.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res.statusCode = 405;
        res.setHeader("Allow", "GET, HEAD");
        res.setHeader("Content-Length", "0");
        res.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl2.original(req);
      var path2 = parseUrl2(req).pathname;
      if (path2 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path2 = "";
      }
      var stream2 = send2(req, path2, opts);
      stream2.on("directory", onDirectory);
      if (setHeaders) {
        stream2.on("headers", setHeaders);
      }
      if (fallthrough) {
        stream2.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream2.on("error", function error2(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream2.pipe(res);
    };
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function createHtmlDocument(title2, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title2 + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect(res) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl2.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
      var loc = encodeUrl(url2.format(originalUrl));
      var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>");
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
  }
  return serveStatic.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredExpress$1;
function requireExpress$1() {
  if (hasRequiredExpress$1)
    return express$1.exports;
  hasRequiredExpress$1 = 1;
  (function(module2, exports2) {
    var bodyParser2 = requireBodyParser();
    var EventEmitter = require$$0$8.EventEmitter;
    var mixin = requireMergeDescriptors();
    var proto = requireApplication();
    var Route = requireRoute();
    var Router = requireRouter$1();
    var req = requireRequest$1();
    var res = requireResponse();
    exports2 = module2.exports = createApplication;
    function createApplication() {
      var app2 = function(req2, res2, next) {
        app2.handle(req2, res2, next);
      };
      mixin(app2, EventEmitter.prototype, false);
      mixin(app2, proto, false);
      app2.request = Object.create(req, {
        app: { configurable: true, enumerable: true, writable: true, value: app2 }
      });
      app2.response = Object.create(res, {
        app: { configurable: true, enumerable: true, writable: true, value: app2 }
      });
      app2.init();
      return app2;
    }
    exports2.application = proto;
    exports2.request = req;
    exports2.response = res;
    exports2.Route = Route;
    exports2.Router = Router;
    exports2.json = bodyParser2.json;
    exports2.query = requireQuery();
    exports2.raw = bodyParser2.raw;
    exports2.static = requireServeStatic();
    exports2.text = bodyParser2.text;
    exports2.urlencoded = bodyParser2.urlencoded;
    var removedMiddlewares = [
      "bodyParser",
      "compress",
      "cookieSession",
      "session",
      "logger",
      "cookieParser",
      "favicon",
      "responseTime",
      "errorHandler",
      "timeout",
      "methodOverride",
      "vhost",
      "csrf",
      "directory",
      "limit",
      "multipart",
      "staticCache"
    ];
    removedMiddlewares.forEach(function(name) {
      Object.defineProperty(exports2, name, {
        get: function() {
          throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
        },
        configurable: true
      });
    });
  })(express$1, express$1.exports);
  return express$1.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var express;
var hasRequiredExpress;
function requireExpress() {
  if (hasRequiredExpress)
    return express;
  hasRequiredExpress = 1;
  express = requireExpress$1();
  return express;
}
var getBodyParserOptions_util = {};
var hasRequiredGetBodyParserOptions_util;
function requireGetBodyParserOptions_util() {
  if (hasRequiredGetBodyParserOptions_util)
    return getBodyParserOptions_util;
  hasRequiredGetBodyParserOptions_util = 1;
  Object.defineProperty(getBodyParserOptions_util, "__esModule", { value: true });
  getBodyParserOptions_util.getBodyParserOptions = void 0;
  const rawBodyParser = (req, _res, buffer2) => {
    if (Buffer.isBuffer(buffer2)) {
      req.rawBody = buffer2;
    }
    return true;
  };
  function getBodyParserOptions(rawBody2, options) {
    let parserOptions = options || {};
    if (rawBody2 === true) {
      parserOptions = Object.assign(Object.assign({}, parserOptions), { verify: rawBodyParser });
    }
    return parserOptions;
  }
  getBodyParserOptions_util.getBodyParserOptions = getBodyParserOptions;
  return getBodyParserOptions_util;
}
var hasRequiredExpressAdapter;
function requireExpressAdapter() {
  if (hasRequiredExpressAdapter)
    return expressAdapter;
  hasRequiredExpressAdapter = 1;
  Object.defineProperty(expressAdapter, "__esModule", { value: true });
  expressAdapter.ExpressAdapter = void 0;
  const common_1 = requireCommon$3();
  const shared_utils_1 = requireShared_utils();
  const http_adapter_1 = requireHttpAdapter();
  const router_method_factory_1 = requireRouterMethodFactory();
  const body_parser_1 = requireBodyParser$1();
  const bodyparser = requireBodyParser$1();
  const cors = requireLib$1();
  const express2 = requireExpress();
  const http3 = require$$7$2;
  const https2 = require$$8$1;
  const stream_12 = require$$0$4;
  const get_body_parser_options_util_1 = requireGetBodyParserOptions_util();
  class ExpressAdapter extends http_adapter_1.AbstractHttpAdapter {
    constructor(instance) {
      super(instance || express2());
      this.routerMethodFactory = new router_method_factory_1.RouterMethodFactory();
      this.logger = new common_1.Logger(ExpressAdapter.name);
      this.openConnections = /* @__PURE__ */ new Set();
    }
    reply(response2, body, statusCode) {
      if (statusCode) {
        response2.status(statusCode);
      }
      if ((0, shared_utils_1.isNil)(body)) {
        return response2.send();
      }
      if (body instanceof common_1.StreamableFile) {
        const streamHeaders = body.getHeaders();
        if (response2.getHeader("Content-Type") === void 0 && streamHeaders.type !== void 0) {
          response2.setHeader("Content-Type", streamHeaders.type);
        }
        if (response2.getHeader("Content-Disposition") === void 0 && streamHeaders.disposition !== void 0) {
          response2.setHeader("Content-Disposition", streamHeaders.disposition);
        }
        if (response2.getHeader("Content-Length") === void 0 && streamHeaders.length !== void 0) {
          response2.setHeader("Content-Length", streamHeaders.length);
        }
        return (0, stream_12.pipeline)(body.getStream().once("error", (err) => {
          body.errorHandler(err, response2);
        }), response2, (err) => {
          if (err) {
            this.logger.error(err.message, err.stack);
          }
        });
      }
      if (response2.getHeader("Content-Type") !== void 0 && response2.getHeader("Content-Type") !== "application/json" && (body === null || body === void 0 ? void 0 : body.statusCode) >= common_1.HttpStatus.BAD_REQUEST) {
        this.logger.warn("Content-Type doesn't match Reply body, you might need a custom ExceptionFilter for non-JSON responses");
        response2.setHeader("Content-Type", "application/json");
      }
      return (0, shared_utils_1.isObject)(body) ? response2.json(body) : response2.send(String(body));
    }
    status(response2, statusCode) {
      return response2.status(statusCode);
    }
    end(response2, message) {
      return response2.end(message);
    }
    render(response2, view2, options) {
      return response2.render(view2, options);
    }
    redirect(response2, statusCode, url2) {
      return response2.redirect(statusCode, url2);
    }
    setErrorHandler(handler, prefix) {
      return this.use(handler);
    }
    setNotFoundHandler(handler, prefix) {
      return this.use(handler);
    }
    isHeadersSent(response2) {
      return response2.headersSent;
    }
    setHeader(response2, name, value) {
      return response2.set(name, value);
    }
    listen(port, ...args2) {
      return this.httpServer.listen(port, ...args2);
    }
    close() {
      this.closeOpenConnections();
      if (!this.httpServer) {
        return void 0;
      }
      return new Promise((resolve2) => this.httpServer.close(resolve2));
    }
    set(...args2) {
      return this.instance.set(...args2);
    }
    enable(...args2) {
      return this.instance.enable(...args2);
    }
    disable(...args2) {
      return this.instance.disable(...args2);
    }
    engine(...args2) {
      return this.instance.engine(...args2);
    }
    useStaticAssets(path2, options) {
      if (options && options.prefix) {
        return this.use(options.prefix, express2.static(path2, options));
      }
      return this.use(express2.static(path2, options));
    }
    setBaseViewsDir(path2) {
      return this.set("views", path2);
    }
    setViewEngine(engine) {
      return this.set("view engine", engine);
    }
    getRequestHostname(request2) {
      return request2.hostname;
    }
    getRequestMethod(request2) {
      return request2.method;
    }
    getRequestUrl(request2) {
      return request2.originalUrl;
    }
    enableCors(options) {
      return this.use(cors(options));
    }
    createMiddlewareFactory(requestMethod) {
      return this.routerMethodFactory.get(this.instance, requestMethod).bind(this.instance);
    }
    initHttpServer(options) {
      const isHttpsEnabled = options && options.httpsOptions;
      if (isHttpsEnabled) {
        this.httpServer = https2.createServer(options.httpsOptions, this.getInstance());
      } else {
        this.httpServer = http3.createServer(this.getInstance());
      }
      if (options === null || options === void 0 ? void 0 : options.forceCloseConnections) {
        this.trackOpenConnections();
      }
    }
    registerParserMiddleware(prefix, rawBody2) {
      const bodyParserJsonOptions = (0, get_body_parser_options_util_1.getBodyParserOptions)(rawBody2);
      const bodyParserUrlencodedOptions = (0, get_body_parser_options_util_1.getBodyParserOptions)(rawBody2, {
        extended: true
      });
      const parserMiddleware = {
        jsonParser: (0, body_parser_1.json)(bodyParserJsonOptions),
        urlencodedParser: (0, body_parser_1.urlencoded)(bodyParserUrlencodedOptions)
      };
      Object.keys(parserMiddleware).filter((parser) => !this.isMiddlewareApplied(parser)).forEach((parserKey) => this.use(parserMiddleware[parserKey]));
    }
    useBodyParser(type2, rawBody2, options) {
      const parserOptions = (0, get_body_parser_options_util_1.getBodyParserOptions)(rawBody2, options);
      const parser = bodyparser[type2](parserOptions);
      this.use(parser);
      return this;
    }
    setLocal(key, value) {
      this.instance.locals[key] = value;
      return this;
    }
    getType() {
      return "express";
    }
    applyVersionFilter(handler, version, versioningOptions) {
      const callNextHandler = (req, res, next) => {
        if (!next) {
          throw new common_1.InternalServerErrorException("HTTP adapter does not support filtering on version");
        }
        return next();
      };
      if (version === common_1.VERSION_NEUTRAL || // URL Versioning is done via the path, so the filter continues forward
      versioningOptions.type === common_1.VersioningType.URI) {
        const handlerForNoVersioning = (req, res, next) => handler(req, res, next);
        return handlerForNoVersioning;
      }
      if (versioningOptions.type === common_1.VersioningType.CUSTOM) {
        const handlerForCustomVersioning = (req, res, next) => {
          const extractedVersion = versioningOptions.extractor(req);
          if (Array.isArray(version)) {
            if (Array.isArray(extractedVersion) && version.filter((v) => extractedVersion.includes(v)).length) {
              return handler(req, res, next);
            }
            if ((0, shared_utils_1.isString)(extractedVersion) && version.includes(extractedVersion)) {
              return handler(req, res, next);
            }
          } else if ((0, shared_utils_1.isString)(version)) {
            if (Array.isArray(extractedVersion) && extractedVersion.includes(version)) {
              return handler(req, res, next);
            }
            if ((0, shared_utils_1.isString)(extractedVersion) && version === extractedVersion) {
              return handler(req, res, next);
            }
          }
          return callNextHandler(req, res, next);
        };
        return handlerForCustomVersioning;
      }
      if (versioningOptions.type === common_1.VersioningType.MEDIA_TYPE) {
        const handlerForMediaTypeVersioning = (req, res, next) => {
          var _a, _b;
          const MEDIA_TYPE_HEADER = "Accept";
          const acceptHeaderValue = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a[MEDIA_TYPE_HEADER]) || ((_b = req.headers) === null || _b === void 0 ? void 0 : _b[MEDIA_TYPE_HEADER.toLowerCase()]);
          const acceptHeaderVersionParameter = acceptHeaderValue ? acceptHeaderValue.split(";")[1] : void 0;
          if ((0, shared_utils_1.isUndefined)(acceptHeaderVersionParameter)) {
            if (Array.isArray(version)) {
              if (version.includes(common_1.VERSION_NEUTRAL)) {
                return handler(req, res, next);
              }
            }
          } else {
            const headerVersion = acceptHeaderVersionParameter.split(versioningOptions.key)[1];
            if (Array.isArray(version)) {
              if (version.includes(headerVersion)) {
                return handler(req, res, next);
              }
            } else if ((0, shared_utils_1.isString)(version)) {
              if (version === headerVersion) {
                return handler(req, res, next);
              }
            }
          }
          return callNextHandler(req, res, next);
        };
        return handlerForMediaTypeVersioning;
      }
      if (versioningOptions.type === common_1.VersioningType.HEADER) {
        const handlerForHeaderVersioning = (req, res, next) => {
          var _a, _b;
          const customHeaderVersionParameter = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a[versioningOptions.header]) || ((_b = req.headers) === null || _b === void 0 ? void 0 : _b[versioningOptions.header.toLowerCase()]);
          if ((0, shared_utils_1.isUndefined)(customHeaderVersionParameter)) {
            if (Array.isArray(version)) {
              if (version.includes(common_1.VERSION_NEUTRAL)) {
                return handler(req, res, next);
              }
            }
          } else {
            if (Array.isArray(version)) {
              if (version.includes(customHeaderVersionParameter)) {
                return handler(req, res, next);
              }
            } else if ((0, shared_utils_1.isString)(version)) {
              if (version === customHeaderVersionParameter) {
                return handler(req, res, next);
              }
            }
          }
          return callNextHandler(req, res, next);
        };
        return handlerForHeaderVersioning;
      }
    }
    trackOpenConnections() {
      this.httpServer.on("connection", (socket) => {
        this.openConnections.add(socket);
        socket.on("close", () => this.openConnections.delete(socket));
      });
    }
    closeOpenConnections() {
      for (const socket of this.openConnections) {
        socket.destroy();
        this.openConnections.delete(socket);
      }
    }
    isMiddlewareApplied(name) {
      const app2 = this.getInstance();
      return !!app2._router && !!app2._router.stack && (0, shared_utils_1.isFunction)(app2._router.stack.filter) && app2._router.stack.some((layer2) => layer2 && layer2.handle && layer2.handle.name === name);
    }
  }
  expressAdapter.ExpressAdapter = ExpressAdapter;
  return expressAdapter;
}
var hasRequiredAdapters;
function requireAdapters() {
  if (hasRequiredAdapters)
    return adapters$1;
  hasRequiredAdapters = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireExpressAdapter(), exports2);
  })(adapters$1);
  return adapters$1;
}
var interfaces$2 = {};
var nestExpressApplication_interface = {};
var hasRequiredNestExpressApplication_interface;
function requireNestExpressApplication_interface() {
  if (hasRequiredNestExpressApplication_interface)
    return nestExpressApplication_interface;
  hasRequiredNestExpressApplication_interface = 1;
  Object.defineProperty(nestExpressApplication_interface, "__esModule", { value: true });
  return nestExpressApplication_interface;
}
var nestExpressBodyParser_interface = {};
var hasRequiredNestExpressBodyParser_interface;
function requireNestExpressBodyParser_interface() {
  if (hasRequiredNestExpressBodyParser_interface)
    return nestExpressBodyParser_interface;
  hasRequiredNestExpressBodyParser_interface = 1;
  Object.defineProperty(nestExpressBodyParser_interface, "__esModule", { value: true });
  return nestExpressBodyParser_interface;
}
var hasRequiredInterfaces$2;
function requireInterfaces$2() {
  if (hasRequiredInterfaces$2)
    return interfaces$2;
  hasRequiredInterfaces$2 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireNestExpressApplication_interface(), exports2);
    tslib_1.__exportStar(requireNestExpressBodyParser_interface(), exports2);
  })(interfaces$2);
  return interfaces$2;
}
var multer$1 = {};
var interceptors = {};
var anyFiles_interceptor = {};
var multer = { exports: {} };
var utils$4;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$4;
  hasRequiredUtils = 1;
  function parseContentType(str) {
    if (str.length === 0)
      return;
    const params = /* @__PURE__ */ Object.create(null);
    let i = 0;
    for (; i < str.length; ++i) {
      const code2 = str.charCodeAt(i);
      if (TOKEN[code2] !== 1) {
        if (code2 !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type2 = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (; i < str.length; ++i) {
      const code2 = str.charCodeAt(i);
      if (TOKEN[code2] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === void 0)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type: type2, subtype, params };
  }
  function parseContentTypeParams(str, i, params) {
    while (i < str.length) {
      for (; i < str.length; ++i) {
        const code2 = str.charCodeAt(i);
        if (code2 !== 32 && code2 !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (; i < str.length; ++i) {
        const code2 = str.charCodeAt(i);
        if (code2 !== 32 && code2 !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (; i < str.length; ++i) {
        const code2 = str.charCodeAt(i);
        if (TOKEN[code2] !== 1) {
          if (code2 !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (; i < str.length; ++i) {
          const code2 = str.charCodeAt(i);
          if (code2 === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code2 === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code2] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (; i < str.length; ++i) {
          const code2 = str.charCodeAt(i);
          if (TOKEN[code2] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === void 0)
        params[name] = value;
    }
    return params;
  }
  function parseDisposition(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = /* @__PURE__ */ Object.create(null);
    let i = 0;
    for (; i < str.length; ++i) {
      const code2 = str.charCodeAt(i);
      if (TOKEN[code2] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === void 0)
          return;
        break;
      }
    }
    const type2 = str.slice(0, i).toLowerCase();
    return { type: type2, params };
  }
  function parseDispositionParams(str, i, params, defDecoder) {
    while (i < str.length) {
      for (; i < str.length; ++i) {
        const code2 = str.charCodeAt(i);
        if (code2 !== 32 && code2 !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (; i < str.length; ++i) {
        const code2 = str.charCodeAt(i);
        if (code2 !== 32 && code2 !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (; i < str.length; ++i) {
        const code2 = str.charCodeAt(i);
        if (TOKEN[code2] !== 1) {
          if (code2 === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      let charset2;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42) {
        const charsetStart = ++i;
        for (; i < str.length; ++i) {
          const code2 = str.charCodeAt(i);
          if (CHARSET[code2] !== 1) {
            if (code2 !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset2 = str.slice(charsetStart, i);
        ++i;
        for (; i < str.length; ++i) {
          const code2 = str.charCodeAt(i);
          if (code2 === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode2 = 0;
        for (; i < str.length; ++i) {
          const code2 = str.charCodeAt(i);
          if (EXTENDED_VALUE[code2] !== 1) {
            if (code2 === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode2 = 2;
                else if (encode2 === 0)
                  encode2 = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset2, encode2);
        if (value === void 0)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (; i < str.length; ++i) {
            const code2 = str.charCodeAt(i);
            if (code2 === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code2 === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code2] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (; i < str.length; ++i) {
            const code2 = str.charCodeAt(i);
            if (TOKEN[code2] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === void 0)
          return;
      }
      name = name.toLowerCase();
      if (params[name] === void 0)
        params[name] = value;
    }
    return params;
  }
  function getDecoder(charset2) {
    let lc;
    while (true) {
      switch (charset2) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === void 0) {
            lc = true;
            charset2 = charset2.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset2);
      }
    }
  }
  const decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder2 = new TextDecoder(this);
        return decoder2.decode(data);
      } catch {
      }
    }
  };
  function convertToUTF8(data, charset2, hint) {
    const decode = getDecoder(charset2);
    if (decode)
      return decode(data, hint);
  }
  function basename(path2) {
    if (typeof path2 !== "string")
      return "";
    for (let i = path2.length - 1; i >= 0; --i) {
      switch (path2.charCodeAt(i)) {
        case 47:
        case 92:
          path2 = path2.slice(i + 1);
          return path2 === ".." || path2 === "." ? "" : path2;
      }
    }
    return path2 === ".." || path2 === "." ? "" : path2;
  }
  const TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  const QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  const CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  const EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  const HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  utils$4 = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
  return utils$4;
}
var sbmh;
var hasRequiredSbmh;
function requireSbmh() {
  if (hasRequiredSbmh)
    return sbmh;
  hasRequiredSbmh = 1;
  function memcmp(buf1, pos1, buf2, pos2, num) {
    for (let i = 0; i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  }
  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0; i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  function feed(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos < 0) {
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
          else
            self2._cb(true, void 0, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
        ++pos;
      if (pos < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos > 0)
          self2._cb(true, data, self2._bufPos, pos, true);
        else
          self2._cb(true, void 0, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self2._lookbehindSize = len - pos;
      break;
    }
    if (pos > 0)
      self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
    self2._bufPos = len;
    return len;
  }
  function matchNeedle(self2, data, pos, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0; i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i])
        return false;
    }
    return true;
  }
  sbmh = SBMH;
  return sbmh;
}
var multipart;
var hasRequiredMultipart;
function requireMultipart() {
  if (hasRequiredMultipart)
    return multipart;
  hasRequiredMultipart = 1;
  const { Readable, Writable: Writable2 } = require$$0$4;
  const StreamSearch = requireSbmh();
  const {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = requireUtils();
  const BUF_CRLF = Buffer.from("\r\n");
  const BUF_CR = Buffer.from("\r");
  const BUF_DASH = Buffer.from("-");
  function noop2() {
  }
  const MAX_HEADER_PAIRS = 2e3;
  const MAX_HEADER_SIZE = 16 * 1024;
  const HPARSER_NAME = 0;
  const HPARSER_PRE_OWS = 1;
  const HPARSER_VALUE = 2;
  class HeaderParser {
    constructor(cb) {
      this.header = /* @__PURE__ */ Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = /* @__PURE__ */ Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (; pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code2 = chunk[pos];
              if (TOKEN[code2] !== 1) {
                if (code2 !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos);
                if (this.name.length === 0)
                  return -1;
                ++pos;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (; pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code2 = chunk[pos];
              if (code2 !== 32 && code2 !== 9) {
                start = pos;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (; pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code2 = chunk[pos];
                  if (FIELD_VCHAR[code2] !== 1) {
                    if (code2 !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code2 = chunk[pos];
                if (code2 === 32 || code2 === 9) {
                  start = pos;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === void 0)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code2 === 13) {
                    ++this.crlf;
                    ++pos;
                  } else {
                    start = pos;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos;
              }
            }
            break;
        }
      }
      return pos;
    }
  }
  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  const ignoreData = {
    push: (chunk, pos) => {
    },
    destroy: () => {
    }
  };
  function callAndUnsetCb(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (err)
      self2.destroy(err);
    else if (cb)
      cb();
  }
  function nullDecoder(val, hint) {
    return val;
  }
  class Multipart extends Writable2 {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : void 0
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = void 0;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = void 0;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(
          header["content-disposition"][0],
          paramDecoder
        );
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== void 0 && !preservePath)
            filename = basename(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== void 0) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit(
            "file",
            partName,
            this._fileStream,
            {
              filename,
              encoding: partEncoding,
              mimeType: partType
            }
          );
        } else {
          if (fields === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop2;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== void 0) {
                let chunk;
                const actualLen = Math.min(
                  end - start,
                  fieldSizeLimit - fieldSize
                );
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== void 0) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(
                  Buffer.concat(field, fieldSize),
                  partCharset,
                  0
                );
            }
            field = void 0;
            fieldSize = 0;
            this.emit(
              "field",
              partName,
              data2,
              {
                nameTruncated: false,
                valueTruncated: partTruncated,
                encoding: partEncoding,
                mimeType: partType
              }
            );
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r
--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream2 = this._fileStream;
      if (fileStream2) {
        this._fileStream = null;
        fileStream2.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  function finalcb(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  }
  function checkEndState(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream2 = self2._fileStream;
    if (fileStream2) {
      self2._fileStream = null;
      fileStream2.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  }
  const TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  const FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  multipart = Multipart;
  return multipart;
}
var urlencoded;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded)
    return urlencoded;
  hasRequiredUrlencoded = 1;
  const { Writable: Writable2 } = require$$0$4;
  const { getDecoder } = requireUtils();
  class URLEncoded extends Writable2 {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
      };
      super(streamOpts);
      let charset2 = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset2 = cfg.conType.params.charset;
      this.charset = charset2;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset2);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit(
                      "field",
                      this._key,
                      "",
                      {
                        nameTruncated: this._keyTrunc,
                        valueTruncated: false,
                        encoding: this.charset,
                        mimeType: "text/plain"
                      }
                    );
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit(
                      "field",
                      this._key,
                      this._val,
                      {
                        nameTruncated: this._keyTrunc,
                        valueTruncated: this._valTrunc,
                        encoding: this.charset,
                        mimeType: "text/plain"
                      }
                    );
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit(
          "field",
          this._key,
          this._val,
          {
            nameTruncated: this._keyTrunc,
            valueTruncated: this._valTrunc,
            encoding: this.charset,
            mimeType: "text/plain"
          }
        );
      }
      cb();
    }
  }
  function readPctEnc(self2, chunk, pos, len) {
    if (pos >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos < len) {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    }
    return pos;
  }
  function skipKeyBytes(self2, chunk, pos, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos)
          self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._keyTrunc = true;
      for (; pos < len; ++pos) {
        const code2 = chunk[pos];
        if (code2 === 61 || code2 === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos;
    }
    return pos;
  }
  function skipValBytes(self2, chunk, pos, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos)
          self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._valTrunc = true;
      for (; pos < len; ++pos) {
        if (chunk[pos] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos;
    }
    return pos;
  }
  const HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  urlencoded = URLEncoded;
  return urlencoded;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib;
  hasRequiredLib = 1;
  const { parseContentType } = requireUtils();
  function getInstance(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type2 of TYPES) {
      const matched = type2.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: void 0,
        fileHwm: void 0,
        defCharset: void 0,
        defParamCharset: void 0,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type2(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  }
  const TYPES = [
    requireMultipart(),
    requireUrlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  lib = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
  return lib;
}
var immutable;
var hasRequiredImmutable;
function requireImmutable() {
  if (hasRequiredImmutable)
    return immutable;
  hasRequiredImmutable = 1;
  immutable = extend2;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function extend2() {
    var target = {};
    for (var i = 0; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key in source2) {
        if (hasOwnProperty2.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  }
  return immutable;
}
var parsePath_1;
var hasRequiredParsePath;
function requireParsePath() {
  if (hasRequiredParsePath)
    return parsePath_1;
  hasRequiredParsePath = 1;
  var reFirstKey = /^[^\[]*/;
  var reDigitPath = /^\[(\d+)\]/;
  var reNormalPath = /^\[([^\]]+)\]/;
  function parsePath(key) {
    function failure() {
      return [{ type: "object", key, last: true }];
    }
    var firstKey = reFirstKey.exec(key)[0];
    if (!firstKey)
      return failure();
    var len = key.length;
    var pos = firstKey.length;
    var tail = { type: "object", key: firstKey };
    var steps = [tail];
    while (pos < len) {
      var m;
      if (key[pos] === "[" && key[pos + 1] === "]") {
        pos += 2;
        tail.append = true;
        if (pos !== len)
          return failure();
        continue;
      }
      m = reDigitPath.exec(key.substring(pos));
      if (m !== null) {
        pos += m[0].length;
        tail.nextType = "array";
        tail = { type: "array", key: parseInt(m[1], 10) };
        steps.push(tail);
        continue;
      }
      m = reNormalPath.exec(key.substring(pos));
      if (m !== null) {
        pos += m[0].length;
        tail.nextType = "object";
        tail = { type: "object", key: m[1] };
        steps.push(tail);
        continue;
      }
      return failure();
    }
    tail.last = true;
    return steps;
  }
  parsePath_1 = parsePath;
  return parsePath_1;
}
var setValue_1;
var hasRequiredSetValue;
function requireSetValue() {
  if (hasRequiredSetValue)
    return setValue_1;
  hasRequiredSetValue = 1;
  function valueType(value) {
    if (value === void 0)
      return "undefined";
    if (Array.isArray(value))
      return "array";
    if (typeof value === "object")
      return "object";
    return "scalar";
  }
  function setLastValue(context, step, currentValue, entryValue) {
    switch (valueType(currentValue)) {
      case "undefined":
        if (step.append) {
          context[step.key] = [entryValue];
        } else {
          context[step.key] = entryValue;
        }
        break;
      case "array":
        context[step.key].push(entryValue);
        break;
      case "object":
        return setLastValue(currentValue, { type: "object", key: "", last: true }, currentValue[""], entryValue);
      case "scalar":
        context[step.key] = [context[step.key], entryValue];
        break;
    }
    return context;
  }
  function setValue(context, step, currentValue, entryValue) {
    if (step.last)
      return setLastValue(context, step, currentValue, entryValue);
    var obj;
    switch (valueType(currentValue)) {
      case "undefined":
        if (step.nextType === "array") {
          context[step.key] = [];
        } else {
          context[step.key] = /* @__PURE__ */ Object.create(null);
        }
        return context[step.key];
      case "object":
        return context[step.key];
      case "array":
        if (step.nextType === "array") {
          return currentValue;
        }
        obj = /* @__PURE__ */ Object.create(null);
        context[step.key] = obj;
        currentValue.forEach(function(item, i) {
          if (item !== void 0)
            obj["" + i] = item;
        });
        return obj;
      case "scalar":
        obj = /* @__PURE__ */ Object.create(null);
        obj[""] = currentValue;
        context[step.key] = obj;
        return obj;
    }
  }
  setValue_1 = setValue;
  return setValue_1;
}
var appendField_1;
var hasRequiredAppendField;
function requireAppendField() {
  if (hasRequiredAppendField)
    return appendField_1;
  hasRequiredAppendField = 1;
  var parsePath = requireParsePath();
  var setValue = requireSetValue();
  function appendField(store, key, value) {
    var steps = parsePath(key);
    steps.reduce(function(context, step) {
      return setValue(context, step, context[step.key], value);
    }, store);
  }
  appendField_1 = appendField;
  return appendField_1;
}
var counter;
var hasRequiredCounter;
function requireCounter() {
  if (hasRequiredCounter)
    return counter;
  hasRequiredCounter = 1;
  var EventEmitter = require$$0$8.EventEmitter;
  function Counter() {
    EventEmitter.call(this);
    this.value = 0;
  }
  Counter.prototype = Object.create(EventEmitter.prototype);
  Counter.prototype.increment = function increment() {
    this.value++;
  };
  Counter.prototype.decrement = function decrement() {
    if (--this.value === 0)
      this.emit("zero");
  };
  Counter.prototype.isZero = function isZero() {
    return this.value === 0;
  };
  Counter.prototype.onceZero = function onceZero(fn) {
    if (this.isZero())
      return fn();
    this.once("zero", fn);
  };
  counter = Counter;
  return counter;
}
var multerError;
var hasRequiredMulterError;
function requireMulterError() {
  if (hasRequiredMulterError)
    return multerError;
  hasRequiredMulterError = 1;
  var util2 = require$$1$1;
  var errorMessages = {
    LIMIT_PART_COUNT: "Too many parts",
    LIMIT_FILE_SIZE: "File too large",
    LIMIT_FILE_COUNT: "Too many files",
    LIMIT_FIELD_KEY: "Field name too long",
    LIMIT_FIELD_VALUE: "Field value too long",
    LIMIT_FIELD_COUNT: "Too many fields",
    LIMIT_UNEXPECTED_FILE: "Unexpected field",
    MISSING_FIELD_NAME: "Field name missing"
  };
  function MulterError(code2, field) {
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.message = errorMessages[code2];
    this.code = code2;
    if (field)
      this.field = field;
  }
  util2.inherits(MulterError, Error);
  multerError = MulterError;
  return multerError;
}
var fileAppender;
var hasRequiredFileAppender;
function requireFileAppender() {
  if (hasRequiredFileAppender)
    return fileAppender;
  hasRequiredFileAppender = 1;
  var objectAssign2 = requireObjectAssign();
  function arrayRemove(arr, item) {
    var idx = arr.indexOf(item);
    if (~idx)
      arr.splice(idx, 1);
  }
  function FileAppender(strategy, req) {
    this.strategy = strategy;
    this.req = req;
    switch (strategy) {
      case "NONE":
        break;
      case "VALUE":
        break;
      case "ARRAY":
        req.files = [];
        break;
      case "OBJECT":
        req.files = /* @__PURE__ */ Object.create(null);
        break;
      default:
        throw new Error("Unknown file strategy: " + strategy);
    }
  }
  FileAppender.prototype.insertPlaceholder = function(file2) {
    var placeholder = {
      fieldname: file2.fieldname
    };
    switch (this.strategy) {
      case "NONE":
        break;
      case "VALUE":
        break;
      case "ARRAY":
        this.req.files.push(placeholder);
        break;
      case "OBJECT":
        if (this.req.files[file2.fieldname]) {
          this.req.files[file2.fieldname].push(placeholder);
        } else {
          this.req.files[file2.fieldname] = [placeholder];
        }
        break;
    }
    return placeholder;
  };
  FileAppender.prototype.removePlaceholder = function(placeholder) {
    switch (this.strategy) {
      case "NONE":
        break;
      case "VALUE":
        break;
      case "ARRAY":
        arrayRemove(this.req.files, placeholder);
        break;
      case "OBJECT":
        if (this.req.files[placeholder.fieldname].length === 1) {
          delete this.req.files[placeholder.fieldname];
        } else {
          arrayRemove(this.req.files[placeholder.fieldname], placeholder);
        }
        break;
    }
  };
  FileAppender.prototype.replacePlaceholder = function(placeholder, file2) {
    if (this.strategy === "VALUE") {
      this.req.file = file2;
      return;
    }
    delete placeholder.fieldname;
    objectAssign2(placeholder, file2);
  };
  fileAppender = FileAppender;
  return fileAppender;
}
var removeUploadedFiles_1;
var hasRequiredRemoveUploadedFiles;
function requireRemoveUploadedFiles() {
  if (hasRequiredRemoveUploadedFiles)
    return removeUploadedFiles_1;
  hasRequiredRemoveUploadedFiles = 1;
  function removeUploadedFiles(uploadedFiles, remove, cb) {
    var length = uploadedFiles.length;
    var errors2 = [];
    if (length === 0)
      return cb(null, errors2);
    function handleFile(idx) {
      var file2 = uploadedFiles[idx];
      remove(file2, function(err) {
        if (err) {
          err.file = file2;
          err.field = file2.fieldname;
          errors2.push(err);
        }
        if (idx < length - 1) {
          handleFile(idx + 1);
        } else {
          cb(null, errors2);
        }
      });
    }
    handleFile(0);
  }
  removeUploadedFiles_1 = removeUploadedFiles;
  return removeUploadedFiles_1;
}
var makeMiddleware_1;
var hasRequiredMakeMiddleware;
function requireMakeMiddleware() {
  if (hasRequiredMakeMiddleware)
    return makeMiddleware_1;
  hasRequiredMakeMiddleware = 1;
  var is = requireTypeIs();
  var Busboy = requireLib();
  var extend2 = requireImmutable();
  var appendField = requireAppendField();
  var Counter = requireCounter();
  var MulterError = requireMulterError();
  var FileAppender = requireFileAppender();
  var removeUploadedFiles = requireRemoveUploadedFiles();
  function makeMiddleware(setup) {
    return function multerMiddleware(req, res, next) {
      if (!is(req, ["multipart"]))
        return next();
      var options = setup();
      var limits = options.limits;
      var storage = options.storage;
      var fileFilter = options.fileFilter;
      var fileStrategy = options.fileStrategy;
      var preservePath = options.preservePath;
      req.body = /* @__PURE__ */ Object.create(null);
      var busboy;
      try {
        busboy = Busboy({ headers: req.headers, limits, preservePath });
      } catch (err) {
        return next(err);
      }
      var appender = new FileAppender(fileStrategy, req);
      var isDone = false;
      var readFinished = false;
      var errorOccured = false;
      var pendingWrites = new Counter();
      var uploadedFiles = [];
      function done(err) {
        if (isDone)
          return;
        isDone = true;
        req.unpipe(busboy);
        busboy.removeAllListeners();
        next(err);
      }
      function indicateDone() {
        if (readFinished && pendingWrites.isZero() && !errorOccured)
          done();
      }
      function abortWithError(uploadError) {
        if (errorOccured)
          return;
        errorOccured = true;
        pendingWrites.onceZero(function() {
          function remove(file2, cb) {
            storage._removeFile(req, file2, cb);
          }
          removeUploadedFiles(uploadedFiles, remove, function(err, storageErrors) {
            if (err)
              return done(err);
            uploadError.storageErrors = storageErrors;
            done(uploadError);
          });
        });
      }
      function abortWithCode(code2, optionalField) {
        abortWithError(new MulterError(code2, optionalField));
      }
      busboy.on("field", function(fieldname, value, { nameTruncated, valueTruncated }) {
        if (fieldname == null)
          return abortWithCode("MISSING_FIELD_NAME");
        if (nameTruncated)
          return abortWithCode("LIMIT_FIELD_KEY");
        if (valueTruncated)
          return abortWithCode("LIMIT_FIELD_VALUE", fieldname);
        if (limits && Object.prototype.hasOwnProperty.call(limits, "fieldNameSize")) {
          if (fieldname.length > limits.fieldNameSize)
            return abortWithCode("LIMIT_FIELD_KEY");
        }
        appendField(req.body, fieldname, value);
      });
      busboy.on("file", function(fieldname, fileStream2, { filename, encoding: encoding2, mimeType }) {
        if (!filename)
          return fileStream2.resume();
        if (limits && Object.prototype.hasOwnProperty.call(limits, "fieldNameSize")) {
          if (fieldname.length > limits.fieldNameSize)
            return abortWithCode("LIMIT_FIELD_KEY");
        }
        var file2 = {
          fieldname,
          originalname: filename,
          encoding: encoding2,
          mimetype: mimeType
        };
        var placeholder = appender.insertPlaceholder(file2);
        fileFilter(req, file2, function(err, includeFile) {
          if (err) {
            appender.removePlaceholder(placeholder);
            return abortWithError(err);
          }
          if (!includeFile) {
            appender.removePlaceholder(placeholder);
            return fileStream2.resume();
          }
          var aborting = false;
          pendingWrites.increment();
          Object.defineProperty(file2, "stream", {
            configurable: true,
            enumerable: false,
            value: fileStream2
          });
          fileStream2.on("error", function(err2) {
            pendingWrites.decrement();
            abortWithError(err2);
          });
          fileStream2.on("limit", function() {
            aborting = true;
            abortWithCode("LIMIT_FILE_SIZE", fieldname);
          });
          storage._handleFile(req, file2, function(err2, info) {
            if (aborting) {
              appender.removePlaceholder(placeholder);
              uploadedFiles.push(extend2(file2, info));
              return pendingWrites.decrement();
            }
            if (err2) {
              appender.removePlaceholder(placeholder);
              pendingWrites.decrement();
              return abortWithError(err2);
            }
            var fileInfo = extend2(file2, info);
            appender.replacePlaceholder(placeholder, fileInfo);
            uploadedFiles.push(fileInfo);
            pendingWrites.decrement();
            indicateDone();
          });
        });
      });
      busboy.on("error", function(err) {
        abortWithError(err);
      });
      busboy.on("partsLimit", function() {
        abortWithCode("LIMIT_PART_COUNT");
      });
      busboy.on("filesLimit", function() {
        abortWithCode("LIMIT_FILE_COUNT");
      });
      busboy.on("fieldsLimit", function() {
        abortWithCode("LIMIT_FIELD_COUNT");
      });
      busboy.on("close", function() {
        readFinished = true;
        indicateDone();
      });
      req.pipe(busboy);
    };
  }
  makeMiddleware_1 = makeMiddleware;
  return makeMiddleware_1;
}
var mkdirp;
var hasRequiredMkdirp;
function requireMkdirp() {
  if (hasRequiredMkdirp)
    return mkdirp;
  hasRequiredMkdirp = 1;
  var path2 = require$$0$6;
  var fs2 = require$$1$3;
  var _0777 = parseInt("0777", 8);
  mkdirp = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs2;
    if (mode === void 0) {
      mode = _0777;
    }
    if (!made)
      made = null;
    var cb = f || /* istanbul ignore next */
    function() {
    };
    p = path2.resolve(p);
    xfs.mkdir(p, mode, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path2.dirname(p) === p)
            return cb(er);
          mkdirP(path2.dirname(p), opts, function(er2, made2) {
            if (er2)
              cb(er2, made2);
            else
              mkdirP(p, opts, cb, made2);
          });
          break;
        default:
          xfs.stat(p, function(er2, stat) {
            if (er2 || !stat.isDirectory())
              cb(er, made);
            else
              cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs2;
    if (mode === void 0) {
      mode = _0777;
    }
    if (!made)
      made = null;
    p = path2.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync(path2.dirname(p), opts, made);
          sync(p, opts, made);
          break;
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
          break;
      }
    }
    return made;
  };
  return mkdirp;
}
var disk;
var hasRequiredDisk;
function requireDisk() {
  if (hasRequiredDisk)
    return disk;
  hasRequiredDisk = 1;
  var fs2 = require$$1$3;
  var os2 = require$$1$2;
  var path2 = require$$0$6;
  var crypto2 = require$$0$5;
  var mkdirp2 = requireMkdirp();
  function getFilename(req, file2, cb) {
    crypto2.randomBytes(16, function(err, raw) {
      cb(err, err ? void 0 : raw.toString("hex"));
    });
  }
  function getDestination(req, file2, cb) {
    cb(null, os2.tmpdir());
  }
  function DiskStorage(opts) {
    this.getFilename = opts.filename || getFilename;
    if (typeof opts.destination === "string") {
      mkdirp2.sync(opts.destination);
      this.getDestination = function($0, $1, cb) {
        cb(null, opts.destination);
      };
    } else {
      this.getDestination = opts.destination || getDestination;
    }
  }
  DiskStorage.prototype._handleFile = function _handleFile(req, file2, cb) {
    var that = this;
    that.getDestination(req, file2, function(err, destination) {
      if (err)
        return cb(err);
      that.getFilename(req, file2, function(err2, filename) {
        if (err2)
          return cb(err2);
        var finalPath = path2.join(destination, filename);
        var outStream = fs2.createWriteStream(finalPath);
        file2.stream.pipe(outStream);
        outStream.on("error", cb);
        outStream.on("finish", function() {
          cb(null, {
            destination,
            filename,
            path: finalPath,
            size: outStream.bytesWritten
          });
        });
      });
    });
  };
  DiskStorage.prototype._removeFile = function _removeFile(req, file2, cb) {
    var path3 = file2.path;
    delete file2.destination;
    delete file2.filename;
    delete file2.path;
    fs2.unlink(path3, cb);
  };
  disk = function(opts) {
    return new DiskStorage(opts);
  };
  return disk;
}
var readable = { exports: {} };
var processNextickArgs = { exports: {} };
var hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs)
    return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1;
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    processNextickArgs.exports = { nextTick };
  } else {
    processNextickArgs.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args2, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args2 = new Array(len - 1);
        i = 0;
        while (i < args2.length) {
          args2[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args2);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray)
    return isarray;
  hasRequiredIsarray = 1;
  var toString3 = {}.toString;
  isarray = Array.isArray || function(arr) {
    return toString3.call(arr) == "[object Array]";
  };
  return isarray;
}
var stream;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream)
    return stream;
  hasRequiredStream = 1;
  stream = require$$0$4;
  return stream;
}
var safeBuffer$1 = { exports: {} };
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  if (hasRequiredSafeBuffer$1)
    return safeBuffer$1.exports;
  hasRequiredSafeBuffer$1 = 1;
  (function(module2, exports2) {
    var buffer2 = require$$0$9;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer$1, safeBuffer$1.exports);
  return safeBuffer$1.exports;
}
var util$5 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$5;
  hasRequiredUtil = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$5.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util$5.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  util$5.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$5.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  util$5.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util$5.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$5.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$5.isUndefined = isUndefined2;
  function isRegExp2(re2) {
    return objectToString(re2) === "[object RegExp]";
  }
  util$5.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$5.isObject = isObject2;
  function isDate2(d) {
    return objectToString(d) === "[object Date]";
  }
  util$5.isDate = isDate2;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util$5.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$5.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$5.isPrimitive = isPrimitive;
  util$5.isBuffer = require$$0$9.Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util$5;
}
var BufferList = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList)
    return BufferList.exports;
  hasRequiredBufferList = 1;
  (function(module2) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$1().Buffer;
    var util2 = require$$1$1;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module2.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList);
  return BufferList.exports;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1;
  hasRequiredDestroy = 1;
  var pna = requireProcessNextickArgs();
  function destroy2(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1 = {
    destroy: destroy2,
    undestroy
  };
  return destroy_1;
}
var node$3;
var hasRequiredNode$3;
function requireNode$3() {
  if (hasRequiredNode$3)
    return node$3;
  hasRequiredNode$3 = 1;
  node$3 = require$$1$1.deprecate;
  return node$3;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode$3()
  };
  var Stream2 = requireStream();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable2)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable2(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex)) {
      return new Writable2(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid2 = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid2 = false;
    }
    return valid2;
  }
  Writable2.prototype.write = function(chunk, encoding2, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding2 === "function") {
      cb = encoding2;
      encoding2 = null;
    }
    if (isBuf)
      encoding2 = "buffer";
    else if (!encoding2)
      encoding2 = state2.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state2.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding2, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
        clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
    if (typeof encoding2 === "string")
      encoding2 = encoding2.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding2);
    this._writableState.defaultEncoding = encoding2;
    return this;
  };
  function decodeChunk(state2, chunk, encoding2) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding2);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding2, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding2);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding2 = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret)
      state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last2 = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding: encoding2,
        isBuf,
        callback: cb,
        next: null
      };
      if (last2) {
        last2.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding2, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding2, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev)
      stream2._writev(chunk, state2.onwrite);
    else
      stream2._write(chunk, encoding2, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er)
      onwriteError(stream2, state2, sync, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished)
      onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count2 = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count2] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count2 += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding2 = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding2, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null)
        state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding2, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding2, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding2 = null;
    } else if (typeof encoding2 === "function") {
      cb = encoding2;
      encoding2 = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding2);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending)
      endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream2.emit("error", err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished)
        pna.nextTick(cb);
      else
        stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex = Duplex;
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var Readable = require_stream_readable();
  var Writable2 = require_stream_writable();
  util2.inherits(Duplex, Readable);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable2.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable2.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex;
}
var string_decoder = {};
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer)
    return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module2, exports2) {
    var buffer2 = require$$0$9;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding2) {
    encoding2 = "" + encoding2;
    switch (encoding2 && encoding2.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding2) {
    this.encoding = normalizeEncoding(encoding2);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable = Readable;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable.ReadableState = ReadableState;
  require$$0$8.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream2 = requireStream();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var debugUtil = require$$1$1;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
    };
  }
  var BufferList2 = requireBufferList();
  var destroyImpl = requireDestroy();
  var StringDecoder;
  util2.inherits(Readable, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray2(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding2) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding2 = encoding2 || state2.defaultEncoding;
        if (encoding2 !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding2);
          encoding2 = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding2, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted)
            stream2.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding2) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0)
              addChunk(stream2, state2, chunk, false);
            else
              maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront)
        state2.buffer.unshift(chunk);
      else
        state2.buffer.push(chunk);
      if (state2.needReadable)
        emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = requireString_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended)
      return 0;
    if (state2.objectMode)
      return 1;
    if (n !== n) {
      if (state2.flowing && state2.length)
        return state2.buffer.head.data.length;
      else
        return state2.length;
    }
    if (n > state2.highWaterMark)
      state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length)
      return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0)
        state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading)
        n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state2);
    else
      ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended)
        state2.needReadable = true;
      if (nOrig !== n && state2.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended)
      return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync)
        pna.nextTick(emitReadable_, stream2);
      else
        emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug2("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else
        len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted)
      pna.nextTick(endFn);
    else
      src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain)
        state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0)
      return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes)
        return this;
      if (!dest)
        dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    if (index === -1)
      return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1)
      state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug2("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading)
      stream2.read(0);
  }
  Readable.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder)
        chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state2.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream2[method].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0)
      return null;
    var ret;
    if (state2.objectMode)
      ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder)
        ret = state2.buffer.join("");
      else if (state2.buffer.length === 1)
        ret = state2.buffer.head.data;
      else
        ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var Duplex = require_stream_duplex();
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding2) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding2);
  };
  Transform.prototype._transform = function(chunk, encoding2, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding2, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding2;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data) {
    if (er)
      return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform = require_stream_transform();
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding2, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable)
    return readable.exports;
  hasRequiredReadable = 1;
  (function(module2, exports2) {
    var Stream2 = require$$0$4;
    if (process.env.READABLE_STREAM === "disable" && Stream2) {
      module2.exports = Stream2;
      exports2 = module2.exports = Stream2.Readable;
      exports2.Readable = Stream2.Readable;
      exports2.Writable = Stream2.Writable;
      exports2.Duplex = Stream2.Duplex;
      exports2.Transform = Stream2.Transform;
      exports2.PassThrough = Stream2.PassThrough;
      exports2.Stream = Stream2;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream2 || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  })(readable, readable.exports);
  return readable.exports;
}
var bufferFrom_1;
var hasRequiredBufferFrom;
function requireBufferFrom() {
  if (hasRequiredBufferFrom)
    return bufferFrom_1;
  hasRequiredBufferFrom = 1;
  var toString3 = Object.prototype.toString;
  var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
  function isArrayBuffer2(input) {
    return toString3.call(input).slice(8, -1) === "ArrayBuffer";
  }
  function fromArrayBuffer(obj, byteOffset, length) {
    byteOffset >>>= 0;
    var maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (length === void 0) {
      length = maxLength;
    } else {
      length >>>= 0;
      if (length > maxLength) {
        throw new RangeError("'length' is out of bounds");
      }
    }
    return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
  }
  function fromString(string, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer.isEncoding(encoding2)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    return isModern ? Buffer.from(string, encoding2) : new Buffer(string, encoding2);
  }
  function bufferFrom(value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (isArrayBuffer2(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    return isModern ? Buffer.from(value) : new Buffer(value);
  }
  bufferFrom_1 = bufferFrom;
  return bufferFrom_1;
}
var typedarray = {};
var hasRequiredTypedarray;
function requireTypedarray() {
  if (hasRequiredTypedarray)
    return typedarray;
  hasRequiredTypedarray = 1;
  (function(exports2) {
    var undefined$12 = void 0;
    var MAX_ARRAY_LENGTH = 1e5;
    var ECMAScript = function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o === "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    }();
    var LN2 = Math.LN2, abs2 = Math.abs, floor2 = Math.floor, log = Math.log, min2 = Math.min, pow2 = Math.pow, round2 = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    var defineProp;
    if (Object.defineProperty && function() {
      try {
        Object.defineProperty({}, "x", {});
        return true;
      } catch (e) {
        return false;
      }
    }()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o))
          throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
          Object.prototype.__defineGetter__.call(o, p, desc.get);
        }
        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
          Object.prototype.__defineSetter__.call(o, p, desc.set);
        }
        if (ECMAScript.HasProperty(desc, "value")) {
          o[p] = desc.value;
        }
        return o;
      };
    }
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o))
        throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp) {
        return;
      }
      if (obj.length > MAX_ARRAY_LENGTH)
        throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          "get": function() {
            return obj._getter(index);
          },
          "set": function(v) {
            obj._setter(index, v);
          },
          enumerable: true,
          configurable: false
        });
      }
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    function as_signed(value, bits) {
      var s = 32 - bits;
      return value << s >> s;
    }
    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return value << s >>> s;
    }
    function packI8(n) {
      return [n & 255];
    }
    function unpackI8(bytes2) {
      return as_signed(bytes2[0], 8);
    }
    function packU8(n) {
      return [n & 255];
    }
    function unpackU8(bytes2) {
      return as_unsigned(bytes2[0], 8);
    }
    function packU8Clamped(n) {
      n = round2(Number(n));
      return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackI16(bytes2) {
      return as_signed(bytes2[0] << 8 | bytes2[1], 16);
    }
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackU16(bytes2) {
      return as_unsigned(bytes2[0] << 8 | bytes2[1], 16);
    }
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackI32(bytes2) {
      return as_signed(bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], 32);
    }
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackU32(bytes2) {
      return as_unsigned(bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s, e, f, i, bits, str, bytes2;
      function roundToEven(n) {
        var w = floor2(n), f2 = n - w;
        if (f2 < 0.5)
          return w;
        if (f2 > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
      if (v !== v) {
        e = (1 << ebits) - 1;
        f = pow2(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = v < 0 ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
      } else {
        s = v < 0;
        v = abs2(v);
        if (v >= pow2(2, 1 - bias)) {
          e = min2(floor2(log(v) / LN2), 1023);
          f = roundToEven(v / pow2(2, e) * pow2(2, fbits));
          if (f / pow2(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            e = e + bias;
            f = f - pow2(2, fbits);
          }
        } else {
          e = 0;
          f = roundToEven(v / pow2(2, 1 - bias - fbits));
        }
      }
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor2(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor2(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join("");
      bytes2 = [];
      while (str.length) {
        bytes2.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes2;
    }
    function unpackIEEE754(bytes2, ebits, fbits) {
      var bits = [], i, j, b, str, bias, s, e, f;
      for (i = bytes2.length; i; i -= 1) {
        b = bytes2[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join("");
      bias = (1 << ebits - 1) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        return s * pow2(2, e - bias) * (1 + f / pow2(2, fbits));
      } else if (f !== 0) {
        return s * pow2(2, -(bias - 1)) * (f / pow2(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    (function() {
      var ArrayBuffer2 = function ArrayBuffer3(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0)
          throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
        configureProperties(this);
      };
      exports2.ArrayBuffer = exports2.ArrayBuffer || ArrayBuffer2;
      var ArrayBufferView = function ArrayBufferView2() {
      };
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        ctor = function(buffer2, byteOffset, length) {
          var array, sequence, i, s;
          if (!arguments.length || typeof arguments[0] === "number") {
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0)
              throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
            array = arguments[0];
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            sequence = arguments[0];
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            this.buffer = buffer2;
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
          this.constructor = ctor;
          configureProperties(this);
          makeArrayAccessors(this);
        };
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined$12;
          }
          var bytes2 = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            bytes2.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes2);
        };
        ctor.prototype.get = ctor.prototype._getter;
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined$12;
          }
          var bytes2 = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            this.buffer._bytes[o] = bytes2[i];
          }
        };
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
          if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min3, max2) {
            return v < min3 ? min3 : v > max2 ? max2 : v;
          }
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end = this.length;
          }
          if (start < 0) {
            start = this.length + start;
          }
          if (end < 0) {
            end = this.length + end;
          }
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
          return new this.constructor(
            this.buffer,
            this.byteOffset + start * this.BYTES_PER_ELEMENT,
            len
          );
        };
        return ctor;
      }
      var Int8Array2 = makeConstructor(1, packI8, unpackI8);
      var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray2 = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array2 = makeConstructor(2, packI16, unpackI16);
      var Uint16Array2 = makeConstructor(2, packU16, unpackU16);
      var Int32Array2 = makeConstructor(4, packI32, unpackI32);
      var Uint32Array2 = makeConstructor(4, packU32, unpackU32);
      var Float32Array2 = makeConstructor(4, packF32, unpackF32);
      var Float64Array2 = makeConstructor(8, packF64, unpackF64);
      exports2.Int8Array = exports2.Int8Array || Int8Array2;
      exports2.Uint8Array = exports2.Uint8Array || Uint8Array2;
      exports2.Uint8ClampedArray = exports2.Uint8ClampedArray || Uint8ClampedArray2;
      exports2.Int16Array = exports2.Int16Array || Int16Array2;
      exports2.Uint16Array = exports2.Uint16Array || Uint16Array2;
      exports2.Int32Array = exports2.Int32Array || Int32Array2;
      exports2.Uint32Array = exports2.Uint32Array || Uint32Array2;
      exports2.Float32Array = exports2.Float32Array || Float32Array2;
      exports2.Float64Array = exports2.Float64Array || Float64Array2;
    })();
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
      var IS_BIG_ENDIAN = function() {
        var u16array = new exports2.Uint16Array([4660]), u8array = new exports2.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      }();
      var DataView2 = function DataView3(buffer2, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer2 = new exports2.ArrayBuffer(0);
        } else if (!(buffer2 instanceof exports2.ArrayBuffer || ECMAScript.Class(buffer2) === "ArrayBuffer")) {
          throw new TypeError("TypeError");
        }
        this.buffer = buffer2 || new exports2.ArrayBuffer(0);
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
        configureProperties(this);
      };
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
          var uint8Array = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes2 = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes2.push(r(uint8Array, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes2.reverse();
          }
          return r(new arrayType(new exports2.Uint8Array(bytes2).buffer), 0);
        };
      }
      DataView2.prototype.getUint8 = makeGetter(exports2.Uint8Array);
      DataView2.prototype.getInt8 = makeGetter(exports2.Int8Array);
      DataView2.prototype.getUint16 = makeGetter(exports2.Uint16Array);
      DataView2.prototype.getInt16 = makeGetter(exports2.Int16Array);
      DataView2.prototype.getUint32 = makeGetter(exports2.Uint32Array);
      DataView2.prototype.getInt32 = makeGetter(exports2.Int32Array);
      DataView2.prototype.getFloat32 = makeGetter(exports2.Float32Array);
      DataView2.prototype.getFloat64 = makeGetter(exports2.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          var typeArray = new arrayType([value]), byteArray = new exports2.Uint8Array(typeArray.buffer), bytes2 = [], i, byteView;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes2.push(r(byteArray, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes2.reverse();
          }
          byteView = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes2);
        };
      }
      DataView2.prototype.setUint8 = makeSetter(exports2.Uint8Array);
      DataView2.prototype.setInt8 = makeSetter(exports2.Int8Array);
      DataView2.prototype.setUint16 = makeSetter(exports2.Uint16Array);
      DataView2.prototype.setInt16 = makeSetter(exports2.Int16Array);
      DataView2.prototype.setUint32 = makeSetter(exports2.Uint32Array);
      DataView2.prototype.setInt32 = makeSetter(exports2.Int32Array);
      DataView2.prototype.setFloat32 = makeSetter(exports2.Float32Array);
      DataView2.prototype.setFloat64 = makeSetter(exports2.Float64Array);
      exports2.DataView = exports2.DataView || DataView2;
    })();
  })(typedarray);
  return typedarray;
}
var concatStream;
var hasRequiredConcatStream;
function requireConcatStream() {
  if (hasRequiredConcatStream)
    return concatStream;
  hasRequiredConcatStream = 1;
  var Writable2 = requireReadable().Writable;
  var inherits2 = requireInherits();
  var bufferFrom = requireBufferFrom();
  if (typeof Uint8Array === "undefined") {
    var U8 = requireTypedarray().Uint8Array;
  } else {
    var U8 = Uint8Array;
  }
  function ConcatStream(opts, cb) {
    if (!(this instanceof ConcatStream))
      return new ConcatStream(opts, cb);
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    if (!opts)
      opts = {};
    var encoding2 = opts.encoding;
    var shouldInferEncoding = false;
    if (!encoding2) {
      shouldInferEncoding = true;
    } else {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "u8" || encoding2 === "uint8") {
        encoding2 = "uint8array";
      }
    }
    Writable2.call(this, { objectMode: true });
    this.encoding = encoding2;
    this.shouldInferEncoding = shouldInferEncoding;
    if (cb)
      this.on("finish", function() {
        cb(this.getBody());
      });
    this.body = [];
  }
  concatStream = ConcatStream;
  inherits2(ConcatStream, Writable2);
  ConcatStream.prototype._write = function(chunk, enc, next) {
    this.body.push(chunk);
    next();
  };
  ConcatStream.prototype.inferEncoding = function(buff) {
    var firstBuffer = buff === void 0 ? this.body[0] : buff;
    if (Buffer.isBuffer(firstBuffer))
      return "buffer";
    if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array)
      return "uint8array";
    if (Array.isArray(firstBuffer))
      return "array";
    if (typeof firstBuffer === "string")
      return "string";
    if (Object.prototype.toString.call(firstBuffer) === "[object Object]")
      return "object";
    return "buffer";
  };
  ConcatStream.prototype.getBody = function() {
    if (!this.encoding && this.body.length === 0)
      return [];
    if (this.shouldInferEncoding)
      this.encoding = this.inferEncoding();
    if (this.encoding === "array")
      return arrayConcat(this.body);
    if (this.encoding === "string")
      return stringConcat(this.body);
    if (this.encoding === "buffer")
      return bufferConcat(this.body);
    if (this.encoding === "uint8array")
      return u8Concat(this.body);
    return this.body;
  };
  function isArrayish(arr) {
    return /Array\]$/.test(Object.prototype.toString.call(arr));
  }
  function isBufferish(p) {
    return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
  }
  function stringConcat(parts) {
    var strings = [];
    for (var i = 0; i < parts.length; i++) {
      var p = parts[i];
      if (typeof p === "string") {
        strings.push(p);
      } else if (Buffer.isBuffer(p)) {
        strings.push(p);
      } else if (isBufferish(p)) {
        strings.push(bufferFrom(p));
      } else {
        strings.push(bufferFrom(String(p)));
      }
    }
    if (Buffer.isBuffer(parts[0])) {
      strings = Buffer.concat(strings);
      strings = strings.toString("utf8");
    } else {
      strings = strings.join("");
    }
    return strings;
  }
  function bufferConcat(parts) {
    var bufs = [];
    for (var i = 0; i < parts.length; i++) {
      var p = parts[i];
      if (Buffer.isBuffer(p)) {
        bufs.push(p);
      } else if (isBufferish(p)) {
        bufs.push(bufferFrom(p));
      } else {
        bufs.push(bufferFrom(String(p)));
      }
    }
    return Buffer.concat(bufs);
  }
  function arrayConcat(parts) {
    var res = [];
    for (var i = 0; i < parts.length; i++) {
      res.push.apply(res, parts[i]);
    }
    return res;
  }
  function u8Concat(parts) {
    var len = 0;
    for (var i = 0; i < parts.length; i++) {
      if (typeof parts[i] === "string") {
        parts[i] = bufferFrom(parts[i]);
      }
      len += parts[i].length;
    }
    var u8 = new U8(len);
    for (var i = 0, offset = 0; i < parts.length; i++) {
      var part = parts[i];
      for (var j = 0; j < part.length; j++) {
        u8[offset++] = part[j];
      }
    }
    return u8;
  }
  return concatStream;
}
var memory;
var hasRequiredMemory;
function requireMemory() {
  if (hasRequiredMemory)
    return memory;
  hasRequiredMemory = 1;
  var concat2 = requireConcatStream();
  function MemoryStorage(opts) {
  }
  MemoryStorage.prototype._handleFile = function _handleFile(req, file2, cb) {
    file2.stream.pipe(concat2({ encoding: "buffer" }, function(data) {
      cb(null, {
        buffer: data,
        size: data.length
      });
    }));
  };
  MemoryStorage.prototype._removeFile = function _removeFile(req, file2, cb) {
    delete file2.buffer;
    cb(null);
  };
  memory = function(opts) {
    return new MemoryStorage();
  };
  return memory;
}
var hasRequiredMulter$1;
function requireMulter$1() {
  if (hasRequiredMulter$1)
    return multer.exports;
  hasRequiredMulter$1 = 1;
  var makeMiddleware = requireMakeMiddleware();
  var diskStorage = requireDisk();
  var memoryStorage = requireMemory();
  var MulterError = requireMulterError();
  function allowAll(req, file2, cb) {
    cb(null, true);
  }
  function Multer(options) {
    if (options.storage) {
      this.storage = options.storage;
    } else if (options.dest) {
      this.storage = diskStorage({ destination: options.dest });
    } else {
      this.storage = memoryStorage();
    }
    this.limits = options.limits;
    this.preservePath = options.preservePath;
    this.fileFilter = options.fileFilter || allowAll;
  }
  Multer.prototype._makeMiddleware = function(fields, fileStrategy) {
    function setup() {
      var fileFilter = this.fileFilter;
      var filesLeft = /* @__PURE__ */ Object.create(null);
      fields.forEach(function(field) {
        if (typeof field.maxCount === "number") {
          filesLeft[field.name] = field.maxCount;
        } else {
          filesLeft[field.name] = Infinity;
        }
      });
      function wrappedFileFilter(req, file2, cb) {
        if ((filesLeft[file2.fieldname] || 0) <= 0) {
          return cb(new MulterError("LIMIT_UNEXPECTED_FILE", file2.fieldname));
        }
        filesLeft[file2.fieldname] -= 1;
        fileFilter(req, file2, cb);
      }
      return {
        limits: this.limits,
        preservePath: this.preservePath,
        storage: this.storage,
        fileFilter: wrappedFileFilter,
        fileStrategy
      };
    }
    return makeMiddleware(setup.bind(this));
  };
  Multer.prototype.single = function(name) {
    return this._makeMiddleware([{ name, maxCount: 1 }], "VALUE");
  };
  Multer.prototype.array = function(name, maxCount) {
    return this._makeMiddleware([{ name, maxCount }], "ARRAY");
  };
  Multer.prototype.fields = function(fields) {
    return this._makeMiddleware(fields, "OBJECT");
  };
  Multer.prototype.none = function() {
    return this._makeMiddleware([], "NONE");
  };
  Multer.prototype.any = function() {
    function setup() {
      return {
        limits: this.limits,
        preservePath: this.preservePath,
        storage: this.storage,
        fileFilter: this.fileFilter,
        fileStrategy: "ARRAY"
      };
    }
    return makeMiddleware(setup.bind(this));
  };
  function multer$12(options) {
    if (options === void 0) {
      return new Multer({});
    }
    if (typeof options === "object" && options !== null) {
      return new Multer(options);
    }
    throw new TypeError("Expected object for argument options");
  }
  multer.exports = multer$12;
  multer.exports.diskStorage = diskStorage;
  multer.exports.memoryStorage = memoryStorage;
  multer.exports.MulterError = MulterError;
  return multer.exports;
}
var files_constants = {};
var hasRequiredFiles_constants;
function requireFiles_constants() {
  if (hasRequiredFiles_constants)
    return files_constants;
  hasRequiredFiles_constants = 1;
  Object.defineProperty(files_constants, "__esModule", { value: true });
  files_constants.MULTER_MODULE_OPTIONS = void 0;
  files_constants.MULTER_MODULE_OPTIONS = "MULTER_MODULE_OPTIONS";
  return files_constants;
}
var multer_utils = {};
var multer_constants$1 = {};
var hasRequiredMulter_constants$1;
function requireMulter_constants$1() {
  if (hasRequiredMulter_constants$1)
    return multer_constants$1;
  hasRequiredMulter_constants$1 = 1;
  Object.defineProperty(multer_constants$1, "__esModule", { value: true });
  multer_constants$1.busboyExceptions = multer_constants$1.multerExceptions = void 0;
  multer_constants$1.multerExceptions = {
    // from https://github.com/expressjs/multer/blob/master/lib/multer-error.js
    LIMIT_PART_COUNT: "Too many parts",
    LIMIT_FILE_SIZE: "File too large",
    LIMIT_FILE_COUNT: "Too many files",
    LIMIT_FIELD_KEY: "Field name too long",
    LIMIT_FIELD_VALUE: "Field value too long",
    LIMIT_FIELD_COUNT: "Too many fields",
    LIMIT_UNEXPECTED_FILE: "Unexpected field",
    MISSING_FIELD_NAME: "Field name missing"
  };
  multer_constants$1.busboyExceptions = {
    // from https://github.com/mscdex/busboy/blob/master/lib/types/multipart.js
    MULTIPART_BOUNDARY_NOT_FOUND: "Multipart: Boundary not found",
    MULTIPART_MALFORMED_PART_HEADER: "Malformed part header",
    MULTIPART_UNEXPECTED_END_OF_FORM: "Unexpected end of form",
    MULTIPART_UNEXPECTED_END_OF_FILE: "Unexpected end of file"
  };
  return multer_constants$1;
}
var hasRequiredMulter_utils;
function requireMulter_utils() {
  if (hasRequiredMulter_utils)
    return multer_utils;
  hasRequiredMulter_utils = 1;
  Object.defineProperty(multer_utils, "__esModule", { value: true });
  multer_utils.transformException = void 0;
  const common_1 = requireCommon$3();
  const multer_constants_1 = requireMulter_constants$1();
  function transformException(error2) {
    if (!error2 || error2 instanceof common_1.HttpException) {
      return error2;
    }
    switch (error2.message) {
      case multer_constants_1.multerExceptions.LIMIT_FILE_SIZE:
        return new common_1.PayloadTooLargeException(error2.message);
      case multer_constants_1.multerExceptions.LIMIT_FILE_COUNT:
      case multer_constants_1.multerExceptions.LIMIT_FIELD_KEY:
      case multer_constants_1.multerExceptions.LIMIT_FIELD_VALUE:
      case multer_constants_1.multerExceptions.LIMIT_FIELD_COUNT:
      case multer_constants_1.multerExceptions.LIMIT_UNEXPECTED_FILE:
      case multer_constants_1.multerExceptions.LIMIT_PART_COUNT:
      case multer_constants_1.multerExceptions.MISSING_FIELD_NAME:
        return new common_1.BadRequestException(error2.message);
      case multer_constants_1.busboyExceptions.MULTIPART_BOUNDARY_NOT_FOUND:
        return new common_1.BadRequestException(error2.message);
      case multer_constants_1.busboyExceptions.MULTIPART_MALFORMED_PART_HEADER:
      case multer_constants_1.busboyExceptions.MULTIPART_UNEXPECTED_END_OF_FORM:
      case multer_constants_1.busboyExceptions.MULTIPART_UNEXPECTED_END_OF_FILE:
        return new common_1.BadRequestException(`Multipart: ${error2.message}`);
    }
    return error2;
  }
  multer_utils.transformException = transformException;
  return multer_utils;
}
var hasRequiredAnyFiles_interceptor;
function requireAnyFiles_interceptor() {
  if (hasRequiredAnyFiles_interceptor)
    return anyFiles_interceptor;
  hasRequiredAnyFiles_interceptor = 1;
  Object.defineProperty(anyFiles_interceptor, "__esModule", { value: true });
  anyFiles_interceptor.AnyFilesInterceptor = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const multer2 = requireMulter$1();
  const files_constants_1 = requireFiles_constants();
  const multer_utils_1 = requireMulter_utils();
  function AnyFilesInterceptor(localOptions) {
    let MixinInterceptor = class MixinInterceptor {
      constructor(options = {}) {
        this.multer = multer2(Object.assign(Object.assign({}, options), localOptions));
      }
      async intercept(context, next) {
        const ctx = context.switchToHttp();
        await new Promise((resolve2, reject) => this.multer.any()(ctx.getRequest(), ctx.getResponse(), (err) => {
          if (err) {
            const error2 = (0, multer_utils_1.transformException)(err);
            return reject(error2);
          }
          resolve2();
        }));
        return next.handle();
      }
    };
    MixinInterceptor = tslib_1.__decorate([
      tslib_1.__param(0, (0, common_1.Optional)()),
      tslib_1.__param(0, (0, common_1.Inject)(files_constants_1.MULTER_MODULE_OPTIONS)),
      tslib_1.__metadata("design:paramtypes", [Object])
    ], MixinInterceptor);
    const Interceptor = (0, common_1.mixin)(MixinInterceptor);
    return Interceptor;
  }
  anyFiles_interceptor.AnyFilesInterceptor = AnyFilesInterceptor;
  return anyFiles_interceptor;
}
var fileFields_interceptor = {};
var hasRequiredFileFields_interceptor;
function requireFileFields_interceptor() {
  if (hasRequiredFileFields_interceptor)
    return fileFields_interceptor;
  hasRequiredFileFields_interceptor = 1;
  Object.defineProperty(fileFields_interceptor, "__esModule", { value: true });
  fileFields_interceptor.FileFieldsInterceptor = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const multer2 = requireMulter$1();
  const files_constants_1 = requireFiles_constants();
  const multer_utils_1 = requireMulter_utils();
  function FileFieldsInterceptor(uploadFields, localOptions) {
    let MixinInterceptor = class MixinInterceptor {
      constructor(options = {}) {
        this.multer = multer2(Object.assign(Object.assign({}, options), localOptions));
      }
      async intercept(context, next) {
        const ctx = context.switchToHttp();
        await new Promise((resolve2, reject) => this.multer.fields(uploadFields)(ctx.getRequest(), ctx.getResponse(), (err) => {
          if (err) {
            const error2 = (0, multer_utils_1.transformException)(err);
            return reject(error2);
          }
          resolve2();
        }));
        return next.handle();
      }
    };
    MixinInterceptor = tslib_1.__decorate([
      tslib_1.__param(0, (0, common_1.Optional)()),
      tslib_1.__param(0, (0, common_1.Inject)(files_constants_1.MULTER_MODULE_OPTIONS)),
      tslib_1.__metadata("design:paramtypes", [Object])
    ], MixinInterceptor);
    const Interceptor = (0, common_1.mixin)(MixinInterceptor);
    return Interceptor;
  }
  fileFields_interceptor.FileFieldsInterceptor = FileFieldsInterceptor;
  return fileFields_interceptor;
}
var file_interceptor = {};
var hasRequiredFile_interceptor;
function requireFile_interceptor() {
  if (hasRequiredFile_interceptor)
    return file_interceptor;
  hasRequiredFile_interceptor = 1;
  Object.defineProperty(file_interceptor, "__esModule", { value: true });
  file_interceptor.FileInterceptor = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const multer2 = requireMulter$1();
  const files_constants_1 = requireFiles_constants();
  const multer_utils_1 = requireMulter_utils();
  function FileInterceptor(fieldName, localOptions) {
    let MixinInterceptor = class MixinInterceptor {
      constructor(options = {}) {
        this.multer = multer2(Object.assign(Object.assign({}, options), localOptions));
      }
      async intercept(context, next) {
        const ctx = context.switchToHttp();
        await new Promise((resolve2, reject) => this.multer.single(fieldName)(ctx.getRequest(), ctx.getResponse(), (err) => {
          if (err) {
            const error2 = (0, multer_utils_1.transformException)(err);
            return reject(error2);
          }
          resolve2();
        }));
        return next.handle();
      }
    };
    MixinInterceptor = tslib_1.__decorate([
      tslib_1.__param(0, (0, common_1.Optional)()),
      tslib_1.__param(0, (0, common_1.Inject)(files_constants_1.MULTER_MODULE_OPTIONS)),
      tslib_1.__metadata("design:paramtypes", [Object])
    ], MixinInterceptor);
    const Interceptor = (0, common_1.mixin)(MixinInterceptor);
    return Interceptor;
  }
  file_interceptor.FileInterceptor = FileInterceptor;
  return file_interceptor;
}
var files_interceptor = {};
var hasRequiredFiles_interceptor;
function requireFiles_interceptor() {
  if (hasRequiredFiles_interceptor)
    return files_interceptor;
  hasRequiredFiles_interceptor = 1;
  Object.defineProperty(files_interceptor, "__esModule", { value: true });
  files_interceptor.FilesInterceptor = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const multer2 = requireMulter$1();
  const files_constants_1 = requireFiles_constants();
  const multer_utils_1 = requireMulter_utils();
  function FilesInterceptor(fieldName, maxCount, localOptions) {
    let MixinInterceptor = class MixinInterceptor {
      constructor(options = {}) {
        this.multer = multer2(Object.assign(Object.assign({}, options), localOptions));
      }
      async intercept(context, next) {
        const ctx = context.switchToHttp();
        await new Promise((resolve2, reject) => this.multer.array(fieldName, maxCount)(ctx.getRequest(), ctx.getResponse(), (err) => {
          if (err) {
            const error2 = (0, multer_utils_1.transformException)(err);
            return reject(error2);
          }
          resolve2();
        }));
        return next.handle();
      }
    };
    MixinInterceptor = tslib_1.__decorate([
      tslib_1.__param(0, (0, common_1.Optional)()),
      tslib_1.__param(0, (0, common_1.Inject)(files_constants_1.MULTER_MODULE_OPTIONS)),
      tslib_1.__metadata("design:paramtypes", [Object])
    ], MixinInterceptor);
    const Interceptor = (0, common_1.mixin)(MixinInterceptor);
    return Interceptor;
  }
  files_interceptor.FilesInterceptor = FilesInterceptor;
  return files_interceptor;
}
var hasRequiredInterceptors;
function requireInterceptors() {
  if (hasRequiredInterceptors)
    return interceptors;
  hasRequiredInterceptors = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireAnyFiles_interceptor(), exports2);
    tslib_1.__exportStar(requireFileFields_interceptor(), exports2);
    tslib_1.__exportStar(requireFile_interceptor(), exports2);
    tslib_1.__exportStar(requireFiles_interceptor(), exports2);
  })(interceptors);
  return interceptors;
}
var interfaces$1 = {};
var filesUploadModule_interface = {};
var hasRequiredFilesUploadModule_interface;
function requireFilesUploadModule_interface() {
  if (hasRequiredFilesUploadModule_interface)
    return filesUploadModule_interface;
  hasRequiredFilesUploadModule_interface = 1;
  Object.defineProperty(filesUploadModule_interface, "__esModule", { value: true });
  return filesUploadModule_interface;
}
var hasRequiredInterfaces$1;
function requireInterfaces$1() {
  if (hasRequiredInterfaces$1)
    return interfaces$1;
  hasRequiredInterfaces$1 = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireFilesUploadModule_interface(), exports2);
  })(interfaces$1);
  return interfaces$1;
}
var multer_module = {};
var multer_constants = {};
var hasRequiredMulter_constants;
function requireMulter_constants() {
  if (hasRequiredMulter_constants)
    return multer_constants;
  hasRequiredMulter_constants = 1;
  Object.defineProperty(multer_constants, "__esModule", { value: true });
  multer_constants.MULTER_MODULE_ID = void 0;
  multer_constants.MULTER_MODULE_ID = "MULTER_MODULE_ID";
  return multer_constants;
}
var hasRequiredMulter_module;
function requireMulter_module() {
  if (hasRequiredMulter_module)
    return multer_module;
  hasRequiredMulter_module = 1;
  var MulterModule_1;
  Object.defineProperty(multer_module, "__esModule", { value: true });
  multer_module.MulterModule = void 0;
  const tslib_1 = require$$0$3;
  const common_1 = requireCommon$3();
  const random_string_generator_util_1 = requireRandomStringGenerator_util();
  const files_constants_1 = requireFiles_constants();
  const multer_constants_1 = requireMulter_constants();
  let MulterModule = MulterModule_1 = class MulterModule {
    static register(options = {}) {
      return {
        module: MulterModule_1,
        providers: [
          { provide: files_constants_1.MULTER_MODULE_OPTIONS, useValue: options },
          {
            provide: multer_constants_1.MULTER_MODULE_ID,
            useValue: (0, random_string_generator_util_1.randomStringGenerator)()
          }
        ],
        exports: [files_constants_1.MULTER_MODULE_OPTIONS]
      };
    }
    static registerAsync(options) {
      return {
        module: MulterModule_1,
        imports: options.imports,
        providers: [
          ...this.createAsyncProviders(options),
          {
            provide: multer_constants_1.MULTER_MODULE_ID,
            useValue: (0, random_string_generator_util_1.randomStringGenerator)()
          }
        ],
        exports: [files_constants_1.MULTER_MODULE_OPTIONS]
      };
    }
    static createAsyncProviders(options) {
      if (options.useExisting || options.useFactory) {
        return [this.createAsyncOptionsProvider(options)];
      }
      return [
        this.createAsyncOptionsProvider(options),
        {
          provide: options.useClass,
          useClass: options.useClass
        }
      ];
    }
    static createAsyncOptionsProvider(options) {
      if (options.useFactory) {
        return {
          provide: files_constants_1.MULTER_MODULE_OPTIONS,
          useFactory: options.useFactory,
          inject: options.inject || []
        };
      }
      return {
        provide: files_constants_1.MULTER_MODULE_OPTIONS,
        useFactory: async (optionsFactory) => optionsFactory.createMulterOptions(),
        inject: [options.useExisting || options.useClass]
      };
    }
  };
  MulterModule = MulterModule_1 = tslib_1.__decorate([
    (0, common_1.Module)({})
  ], MulterModule);
  multer_module.MulterModule = MulterModule;
  return multer_module;
}
var hasRequiredMulter;
function requireMulter() {
  if (hasRequiredMulter)
    return multer$1;
  hasRequiredMulter = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireInterceptors(), exports2);
    tslib_1.__exportStar(requireInterfaces$1(), exports2);
    tslib_1.__exportStar(requireMulter_module(), exports2);
  })(multer$1);
  return multer$1;
}
var hasRequiredPlatformExpress;
function requirePlatformExpress() {
  if (hasRequiredPlatformExpress)
    return platformExpress;
  hasRequiredPlatformExpress = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireAdapters(), exports2);
    tslib_1.__exportStar(requireInterfaces$2(), exports2);
    tslib_1.__exportStar(requireMulter(), exports2);
  })(platformExpress);
  return platformExpress;
}
var hasRequiredNestFactory;
function requireNestFactory() {
  if (hasRequiredNestFactory)
    return nestFactory;
  hasRequiredNestFactory = 1;
  Object.defineProperty(nestFactory, "__esModule", { value: true });
  nestFactory.NestFactory = nestFactory.NestFactoryStatic = void 0;
  const logger_service_1 = requireLogger_service();
  const load_package_util_1 = requireLoadPackage_util();
  const shared_utils_1 = requireShared_utils();
  const application_config_1 = requireApplicationConfig();
  const constants_1 = requireConstants$5();
  const exceptions_zone_1 = requireExceptionsZone();
  const load_adapter_1 = requireLoadAdapter();
  const rethrow_1 = requireRethrow();
  const container_1 = requireContainer$1();
  const injector_1 = requireInjector$1();
  const instance_loader_1 = requireInstanceLoader();
  const graph_inspector_1 = requireGraphInspector();
  const noop_graph_inspector_1 = requireNoopGraphInspector();
  const uuid_factory_1 = requireUuidFactory();
  const metadata_scanner_1 = requireMetadataScanner();
  const nest_application_1 = requireNestApplication();
  const nest_application_context_1 = requireNestApplicationContext();
  const scanner_1 = requireScanner();
  class NestFactoryStatic {
    constructor() {
      this.logger = new logger_service_1.Logger("NestFactory", {
        timestamp: true
      });
      this.abortOnError = true;
      this.autoFlushLogs = false;
    }
    async create(moduleCls, serverOrOptions, options) {
      const [httpServer, appOptions] = this.isHttpServer(serverOrOptions) ? [serverOrOptions, options] : [this.createHttpAdapter(), serverOrOptions];
      const applicationConfig2 = new application_config_1.ApplicationConfig();
      const container2 = new container_1.NestContainer(applicationConfig2);
      const graphInspector2 = this.createGraphInspector(appOptions, container2);
      this.setAbortOnError(serverOrOptions, options);
      this.registerLoggerConfiguration(appOptions);
      await this.initialize(moduleCls, container2, graphInspector2, applicationConfig2, appOptions, httpServer);
      const instance = new nest_application_1.NestApplication(container2, httpServer, applicationConfig2, graphInspector2, appOptions);
      const target = this.createNestInstance(instance);
      return this.createAdapterProxy(target, httpServer);
    }
    /**
     * Creates an instance of NestMicroservice.
     *
     * @param moduleCls Entry (root) application module class
     * @param options Optional microservice configuration
     *
     * @returns A promise that, when resolved,
     * contains a reference to the NestMicroservice instance.
     */
    async createMicroservice(moduleCls, options) {
      const { NestMicroservice } = (0, load_package_util_1.loadPackage)("@nestjs/microservices", "NestFactory", () => require$$18);
      const applicationConfig2 = new application_config_1.ApplicationConfig();
      const container2 = new container_1.NestContainer(applicationConfig2);
      const graphInspector2 = this.createGraphInspector(options, container2);
      this.setAbortOnError(options);
      this.registerLoggerConfiguration(options);
      await this.initialize(moduleCls, container2, graphInspector2, applicationConfig2, options);
      return this.createNestInstance(new NestMicroservice(container2, options, graphInspector2, applicationConfig2));
    }
    /**
     * Creates an instance of NestApplicationContext.
     *
     * @param moduleCls Entry (root) application module class
     * @param options Optional Nest application configuration
     *
     * @returns A promise that, when resolved,
     * contains a reference to the NestApplicationContext instance.
     */
    async createApplicationContext(moduleCls, options) {
      const container2 = new container_1.NestContainer();
      const graphInspector2 = this.createGraphInspector(options, container2);
      this.setAbortOnError(options);
      this.registerLoggerConfiguration(options);
      const applicationConfig2 = void 0;
      await this.initialize(moduleCls, container2, graphInspector2, applicationConfig2, options);
      const modules2 = container2.getModules().values();
      const root = modules2.next().value;
      const context = this.createNestInstance(new nest_application_context_1.NestApplicationContext(container2, options, root));
      if (this.autoFlushLogs) {
        context.flushLogsOnOverride();
      }
      return context.init();
    }
    createNestInstance(instance) {
      return this.createProxy(instance);
    }
    async initialize(module2, container2, graphInspector2, config2 = new application_config_1.ApplicationConfig(), options = {}, httpServer = null) {
      uuid_factory_1.UuidFactory.mode = options.snapshot ? uuid_factory_1.UuidFactoryMode.Deterministic : uuid_factory_1.UuidFactoryMode.Random;
      const injector2 = new injector_1.Injector({ preview: options.preview });
      const instanceLoader2 = new instance_loader_1.InstanceLoader(container2, injector2, graphInspector2);
      const metadataScanner2 = new metadata_scanner_1.MetadataScanner();
      const dependenciesScanner = new scanner_1.DependenciesScanner(container2, metadataScanner2, graphInspector2, config2);
      container2.setHttpAdapter(httpServer);
      const teardown = this.abortOnError === false ? rethrow_1.rethrow : void 0;
      await (httpServer === null || httpServer === void 0 ? void 0 : httpServer.init());
      try {
        this.logger.log(constants_1.MESSAGES.APPLICATION_START);
        await exceptions_zone_1.ExceptionsZone.asyncRun(async () => {
          await dependenciesScanner.scan(module2);
          await instanceLoader2.createInstancesOfDependencies();
          dependenciesScanner.applyApplicationProviders();
        }, teardown, this.autoFlushLogs);
      } catch (e) {
        this.handleInitializationError(e);
      }
    }
    handleInitializationError(err) {
      if (this.abortOnError) {
        process.abort();
      }
      (0, rethrow_1.rethrow)(err);
    }
    createProxy(target) {
      const proxy = this.createExceptionProxy();
      return new Proxy(target, {
        get: proxy,
        set: proxy
      });
    }
    createExceptionProxy() {
      return (receiver, prop) => {
        if (!(prop in receiver)) {
          return;
        }
        if ((0, shared_utils_1.isFunction)(receiver[prop])) {
          return this.createExceptionZone(receiver, prop);
        }
        return receiver[prop];
      };
    }
    createExceptionZone(receiver, prop) {
      const teardown = this.abortOnError === false ? rethrow_1.rethrow : void 0;
      return (...args2) => {
        let result;
        exceptions_zone_1.ExceptionsZone.run(() => {
          result = receiver[prop](...args2);
        }, teardown);
        return result;
      };
    }
    registerLoggerConfiguration(options) {
      if (!options) {
        return;
      }
      const { logger, bufferLogs, autoFlushLogs } = options;
      if (logger !== true && !(0, shared_utils_1.isNil)(logger)) {
        logger_service_1.Logger.overrideLogger(logger);
      }
      if (bufferLogs) {
        logger_service_1.Logger.attachBuffer();
      }
      this.autoFlushLogs = autoFlushLogs !== null && autoFlushLogs !== void 0 ? autoFlushLogs : true;
    }
    createHttpAdapter(httpServer) {
      const { ExpressAdapter } = (0, load_adapter_1.loadAdapter)("@nestjs/platform-express", "HTTP", () => requirePlatformExpress());
      return new ExpressAdapter(httpServer);
    }
    isHttpServer(serverOrOptions) {
      return !!(serverOrOptions && serverOrOptions.patch);
    }
    setAbortOnError(serverOrOptions, options) {
      this.abortOnError = this.isHttpServer(serverOrOptions) ? !(options && options.abortOnError === false) : !(serverOrOptions && serverOrOptions.abortOnError === false);
    }
    createAdapterProxy(app2, adapter) {
      const proxy = new Proxy(app2, {
        get: (receiver, prop) => {
          const mapToProxy = (result) => {
            return result instanceof Promise ? result.then(mapToProxy) : result instanceof nest_application_1.NestApplication ? proxy : result;
          };
          if (!(prop in receiver) && prop in adapter) {
            return (...args2) => {
              const result = this.createExceptionZone(adapter, prop)(...args2);
              return mapToProxy(result);
            };
          }
          if ((0, shared_utils_1.isFunction)(receiver[prop])) {
            return (...args2) => {
              const result = receiver[prop](...args2);
              return mapToProxy(result);
            };
          }
          return receiver[prop];
        }
      });
      return proxy;
    }
    createGraphInspector(appOptions, container2) {
      return (appOptions === null || appOptions === void 0 ? void 0 : appOptions.snapshot) ? new graph_inspector_1.GraphInspector(container2) : noop_graph_inspector_1.NoopGraphInspector;
    }
  }
  nestFactory.NestFactoryStatic = NestFactoryStatic;
  nestFactory.NestFactory = new NestFactoryStatic();
  return nestFactory;
}
var repl$1 = {};
var repl = {};
var assignToObject_util = {};
var hasRequiredAssignToObject_util;
function requireAssignToObject_util() {
  if (hasRequiredAssignToObject_util)
    return assignToObject_util;
  hasRequiredAssignToObject_util = 1;
  Object.defineProperty(assignToObject_util, "__esModule", { value: true });
  assignToObject_util.assignToObject = void 0;
  function assignToObject(target, source2) {
    Object.defineProperties(target, Object.keys(source2).reduce((descriptors2, key) => {
      descriptors2[key] = Object.getOwnPropertyDescriptor(source2, key);
      return descriptors2;
    }, /* @__PURE__ */ Object.create(null)));
    return target;
  }
  assignToObject_util.assignToObject = assignToObject;
  return assignToObject_util;
}
var constants$2 = {};
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants$2;
  hasRequiredConstants = 1;
  Object.defineProperty(constants$2, "__esModule", { value: true });
  constants$2.REPL_INITIALIZED_MESSAGE = void 0;
  constants$2.REPL_INITIALIZED_MESSAGE = "REPL initialized";
  return constants$2;
}
var replContext = {};
var nativeFunctions = {};
var helpReplFn = {};
var replFunction = {};
var hasRequiredReplFunction;
function requireReplFunction() {
  if (hasRequiredReplFunction)
    return replFunction;
  hasRequiredReplFunction = 1;
  Object.defineProperty(replFunction, "__esModule", { value: true });
  replFunction.ReplFunction = void 0;
  const cli_colors_util_1 = requireCliColors_util();
  class ReplFunction {
    constructor(ctx) {
      this.ctx = ctx;
      this.logger = ctx.logger;
    }
    /**
     * @returns A message displayed by calling `<fnName>.help`
     */
    makeHelpMessage() {
      const { description: description2, name, signature } = this.fnDefinition;
      const fnSignatureWithName = `${name}${signature}`;
      return `${cli_colors_util_1.clc.yellow(description2)}
${cli_colors_util_1.clc.magentaBright("Interface:")} ${cli_colors_util_1.clc.bold(fnSignatureWithName)}
`;
    }
  }
  replFunction.ReplFunction = ReplFunction;
  return replFunction;
}
var hasRequiredHelpReplFn;
function requireHelpReplFn() {
  if (hasRequiredHelpReplFn)
    return helpReplFn;
  hasRequiredHelpReplFn = 1;
  Object.defineProperty(helpReplFn, "__esModule", { value: true });
  helpReplFn.HelpReplFn = void 0;
  const iterare_1 = requireLib$4();
  const cli_colors_util_1 = requireCliColors_util();
  const repl_function_1 = requireReplFunction();
  class HelpReplFn extends repl_function_1.ReplFunction {
    constructor() {
      super(...arguments);
      this.fnDefinition = {
        name: "help",
        signature: "() => void",
        description: "Display all available REPL native functions."
      };
    }
    action() {
      const sortedNativeFunctions = (0, iterare_1.iterate)(this.ctx.nativeFunctions).map(([, nativeFunction]) => nativeFunction.fnDefinition).toArray().sort((a, b) => a.name < b.name ? -1 : 1);
      this.ctx.writeToStdout(`You can call ${cli_colors_util_1.clc.bold(".help")} on any function listed below (e.g.: ${cli_colors_util_1.clc.bold("help.help")}):

` + sortedNativeFunctions.map(HelpReplFn.buildHelpMessage).join("\n") + // Without the following LF the last item won't be displayed
      "\n");
    }
  }
  HelpReplFn.buildHelpMessage = ({ name, description: description2 }) => cli_colors_util_1.clc.cyanBright(name) + (description2 ? ` ${cli_colors_util_1.clc.bold("-")} ${description2}` : "");
  helpReplFn.HelpReplFn = HelpReplFn;
  return helpReplFn;
}
var getRelpFn = {};
var hasRequiredGetRelpFn;
function requireGetRelpFn() {
  if (hasRequiredGetRelpFn)
    return getRelpFn;
  hasRequiredGetRelpFn = 1;
  Object.defineProperty(getRelpFn, "__esModule", { value: true });
  getRelpFn.GetReplFn = void 0;
  const repl_function_1 = requireReplFunction();
  class GetReplFn extends repl_function_1.ReplFunction {
    constructor() {
      super(...arguments);
      this.fnDefinition = {
        name: "get",
        signature: "(token: InjectionToken) => any",
        description: "Retrieves an instance of either injectable or controller, otherwise, throws exception.",
        aliases: ["$"]
      };
    }
    action(token) {
      return this.ctx.app.get(token);
    }
  }
  getRelpFn.GetReplFn = GetReplFn;
  return getRelpFn;
}
var resolveReplFn = {};
var hasRequiredResolveReplFn;
function requireResolveReplFn() {
  if (hasRequiredResolveReplFn)
    return resolveReplFn;
  hasRequiredResolveReplFn = 1;
  Object.defineProperty(resolveReplFn, "__esModule", { value: true });
  resolveReplFn.ResolveReplFn = void 0;
  const repl_function_1 = requireReplFunction();
  class ResolveReplFn extends repl_function_1.ReplFunction {
    constructor() {
      super(...arguments);
      this.fnDefinition = {
        name: "resolve",
        description: "Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.",
        signature: "(token: InjectionToken, contextId: any) => Promise<any>"
      };
    }
    action(token, contextId) {
      return this.ctx.app.resolve(token, contextId);
    }
  }
  resolveReplFn.ResolveReplFn = ResolveReplFn;
  return resolveReplFn;
}
var selectRelpFn = {};
var hasRequiredSelectRelpFn;
function requireSelectRelpFn() {
  if (hasRequiredSelectRelpFn)
    return selectRelpFn;
  hasRequiredSelectRelpFn = 1;
  Object.defineProperty(selectRelpFn, "__esModule", { value: true });
  selectRelpFn.SelectReplFn = void 0;
  const repl_function_1 = requireReplFunction();
  class SelectReplFn extends repl_function_1.ReplFunction {
    constructor() {
      super(...arguments);
      this.fnDefinition = {
        name: "select",
        description: "Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module.",
        signature: "(token: DynamicModule | ClassRef) => INestApplicationContext"
      };
    }
    action(token) {
      return this.ctx.app.select(token);
    }
  }
  selectRelpFn.SelectReplFn = SelectReplFn;
  return selectRelpFn;
}
var debugReplFn = {};
var hasRequiredDebugReplFn;
function requireDebugReplFn() {
  if (hasRequiredDebugReplFn)
    return debugReplFn;
  hasRequiredDebugReplFn = 1;
  Object.defineProperty(debugReplFn, "__esModule", { value: true });
  debugReplFn.DebugReplFn = void 0;
  const cli_colors_util_1 = requireCliColors_util();
  const repl_function_1 = requireReplFunction();
  class DebugReplFn extends repl_function_1.ReplFunction {
    constructor() {
      super(...arguments);
      this.fnDefinition = {
        name: "debug",
        description: 'Print all registered modules as a list together with their controllers and providers.\nIf the argument is passed in, for example, "debug(MyModule)" then it will only print components of this specific module.',
        signature: "(moduleCls?: ClassRef | string) => void"
      };
    }
    action(moduleCls) {
      this.ctx.writeToStdout("\n");
      if (moduleCls) {
        const token = typeof moduleCls === "function" ? moduleCls.name : moduleCls;
        const moduleEntry = this.ctx.debugRegistry[token];
        if (!moduleEntry) {
          return this.logger.error(`"${token}" has not been found in the modules registry`);
        }
        this.printCtrlsAndProviders(token, moduleEntry);
      } else {
        Object.keys(this.ctx.debugRegistry).forEach((moduleKey) => {
          this.printCtrlsAndProviders(moduleKey, this.ctx.debugRegistry[moduleKey]);
        });
      }
      this.ctx.writeToStdout("\n");
    }
    printCtrlsAndProviders(moduleName, moduleDebugEntry) {
      this.ctx.writeToStdout(`${cli_colors_util_1.clc.green(moduleName)}:
`);
      this.printCollection("controllers", moduleDebugEntry["controllers"]);
      this.printCollection("providers", moduleDebugEntry["providers"]);
    }
    printCollection(title2, collectionValue) {
      const collectionEntries = Object.keys(collectionValue);
      if (collectionEntries.length <= 0) {
        return;
      }
      this.ctx.writeToStdout(` ${cli_colors_util_1.clc.yellow(`- ${title2}`)}:
`);
      collectionEntries.forEach((provider) => this.ctx.writeToStdout(`  ${cli_colors_util_1.clc.green("")} ${provider}
`));
    }
  }
  debugReplFn.DebugReplFn = DebugReplFn;
  return debugReplFn;
}
var methodsReplFn = {};
var hasRequiredMethodsReplFn;
function requireMethodsReplFn() {
  if (hasRequiredMethodsReplFn)
    return methodsReplFn;
  hasRequiredMethodsReplFn = 1;
  Object.defineProperty(methodsReplFn, "__esModule", { value: true });
  methodsReplFn.MethodsReplFn = void 0;
  const cli_colors_util_1 = requireCliColors_util();
  const metadata_scanner_1 = requireMetadataScanner();
  const repl_function_1 = requireReplFunction();
  class MethodsReplFn extends repl_function_1.ReplFunction {
    constructor() {
      super(...arguments);
      this.fnDefinition = {
        name: "methods",
        description: "Display all public methods available on a given provider or controller.",
        signature: "(token: ClassRef | string) => void"
      };
      this.metadataScanner = new metadata_scanner_1.MetadataScanner();
    }
    action(token) {
      const proto = typeof token !== "function" ? Object.getPrototypeOf(this.ctx.app.get(token)) : token === null || token === void 0 ? void 0 : token.prototype;
      const methods2 = this.metadataScanner.getAllMethodNames(proto);
      this.ctx.writeToStdout("\n");
      this.ctx.writeToStdout(`${cli_colors_util_1.clc.green("Methods")}:
`);
      methods2.forEach((methodName) => this.ctx.writeToStdout(` ${cli_colors_util_1.clc.yellow("")} ${methodName}
`));
      this.ctx.writeToStdout("\n");
    }
  }
  methodsReplFn.MethodsReplFn = MethodsReplFn;
  return methodsReplFn;
}
var hasRequiredNativeFunctions;
function requireNativeFunctions() {
  if (hasRequiredNativeFunctions)
    return nativeFunctions;
  hasRequiredNativeFunctions = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireHelpReplFn(), exports2);
    tslib_1.__exportStar(requireGetRelpFn(), exports2);
    tslib_1.__exportStar(requireResolveReplFn(), exports2);
    tslib_1.__exportStar(requireSelectRelpFn(), exports2);
    tslib_1.__exportStar(requireDebugReplFn(), exports2);
    tslib_1.__exportStar(requireMethodsReplFn(), exports2);
  })(nativeFunctions);
  return nativeFunctions;
}
var hasRequiredReplContext;
function requireReplContext() {
  if (hasRequiredReplContext)
    return replContext;
  hasRequiredReplContext = 1;
  Object.defineProperty(replContext, "__esModule", { value: true });
  replContext.ReplContext = void 0;
  const common_1 = requireCommon$3();
  const application_config_1 = requireApplicationConfig();
  const injector_1 = requireInjector();
  const internal_core_module_1 = requireInternalCoreModule();
  const native_functions_1 = requireNativeFunctions();
  class ReplContext {
    constructor(app2, nativeFunctionsClassRefs) {
      this.app = app2;
      this.logger = new common_1.Logger(ReplContext.name);
      this.debugRegistry = {};
      this.globalScope = /* @__PURE__ */ Object.create(null);
      this.nativeFunctions = /* @__PURE__ */ new Map();
      this.container = app2.container;
      this.initializeContext();
      this.initializeNativeFunctions(nativeFunctionsClassRefs || []);
    }
    writeToStdout(text) {
      process.stdout.write(text);
    }
    initializeContext() {
      const modules2 = this.container.getModules();
      modules2.forEach((moduleRef2) => {
        let moduleName = moduleRef2.metatype.name;
        if (moduleName === internal_core_module_1.InternalCoreModule.name) {
          return;
        }
        if (this.globalScope[moduleName]) {
          moduleName += ` (${moduleRef2.token})`;
        }
        this.introspectCollection(moduleRef2, moduleName, "providers");
        this.introspectCollection(moduleRef2, moduleName, "controllers");
        Object.defineProperty(this.globalScope, moduleName, {
          value: moduleRef2.metatype,
          configurable: false,
          enumerable: true
        });
      });
    }
    introspectCollection(moduleRef2, moduleKey, collection) {
      var _a;
      const moduleDebugEntry = {};
      moduleRef2[collection].forEach(({ token }) => {
        const stringifiedToken = this.stringifyToken(token);
        if (stringifiedToken === application_config_1.ApplicationConfig.name || stringifiedToken === moduleRef2.metatype.name) {
          return;
        }
        if (!this.globalScope[stringifiedToken]) {
          Object.defineProperty(this.globalScope, stringifiedToken, {
            value: token,
            configurable: false,
            enumerable: true
          });
        }
        if (stringifiedToken === injector_1.ModuleRef.name) {
          return;
        }
        moduleDebugEntry[stringifiedToken] = token;
      });
      this.debugRegistry[moduleKey] = Object.assign(Object.assign({}, (_a = this.debugRegistry) === null || _a === void 0 ? void 0 : _a[moduleKey]), { [collection]: moduleDebugEntry });
    }
    stringifyToken(token) {
      return typeof token !== "string" ? typeof token === "function" ? token.name : token === null || token === void 0 ? void 0 : token.toString() : `"${token}"`;
    }
    addNativeFunction(NativeFunctionRef) {
      var _a;
      const nativeFunction = new NativeFunctionRef(this);
      const nativeFunctions2 = [nativeFunction];
      this.nativeFunctions.set(nativeFunction.fnDefinition.name, nativeFunction);
      (_a = nativeFunction.fnDefinition.aliases) === null || _a === void 0 ? void 0 : _a.forEach((aliasName) => {
        const aliasNativeFunction = Object.create(nativeFunction);
        aliasNativeFunction.fnDefinition = {
          name: aliasName,
          description: aliasNativeFunction.fnDefinition.description,
          signature: aliasNativeFunction.fnDefinition.signature
        };
        this.nativeFunctions.set(aliasName, aliasNativeFunction);
        nativeFunctions2.push(aliasNativeFunction);
      });
      return nativeFunctions2;
    }
    registerFunctionIntoGlobalScope(nativeFunction) {
      this.globalScope[nativeFunction.fnDefinition.name] = nativeFunction.action.bind(nativeFunction);
      const functionBoundRef = this.globalScope[nativeFunction.fnDefinition.name];
      Object.defineProperty(functionBoundRef, "help", {
        enumerable: false,
        configurable: false,
        get: () => (
          // Dynamically builds the help message as will unlikely to be called
          // several times.
          this.writeToStdout(nativeFunction.makeHelpMessage())
        )
      });
    }
    initializeNativeFunctions(nativeFunctionsClassRefs) {
      const builtInFunctionsClassRefs = [
        native_functions_1.HelpReplFn,
        native_functions_1.GetReplFn,
        native_functions_1.ResolveReplFn,
        native_functions_1.SelectReplFn,
        native_functions_1.DebugReplFn,
        native_functions_1.MethodsReplFn
      ];
      builtInFunctionsClassRefs.concat(nativeFunctionsClassRefs).forEach((NativeFunction) => {
        const nativeFunctions2 = this.addNativeFunction(NativeFunction);
        nativeFunctions2.forEach((nativeFunction) => {
          this.registerFunctionIntoGlobalScope(nativeFunction);
        });
      });
    }
  }
  replContext.ReplContext = ReplContext;
  return replContext;
}
var replLogger = {};
var hasRequiredReplLogger;
function requireReplLogger() {
  if (hasRequiredReplLogger)
    return replLogger;
  hasRequiredReplLogger = 1;
  Object.defineProperty(replLogger, "__esModule", { value: true });
  replLogger.ReplLogger = void 0;
  const common_1 = requireCommon$3();
  const nest_application_1 = requireNestApplication();
  const router_explorer_1 = requireRouterExplorer();
  const routes_resolver_1 = requireRoutesResolver();
  class ReplLogger extends common_1.ConsoleLogger {
    log(_message, context) {
      if (ReplLogger.ignoredContexts.includes(context)) {
        return;
      }
      return super.log.apply(this, Array.from(arguments));
    }
  }
  ReplLogger.ignoredContexts = [
    routes_resolver_1.RoutesResolver.name,
    router_explorer_1.RouterExplorer.name,
    nest_application_1.NestApplication.name
  ];
  replLogger.ReplLogger = ReplLogger;
  return replLogger;
}
var replNativeCommands = {};
var hasRequiredReplNativeCommands;
function requireReplNativeCommands() {
  if (hasRequiredReplNativeCommands)
    return replNativeCommands;
  hasRequiredReplNativeCommands = 1;
  Object.defineProperty(replNativeCommands, "__esModule", { value: true });
  replNativeCommands.defineDefaultCommandsOnRepl = void 0;
  function listAllCommands(replServer) {
    Object.keys(replServer.commands).sort().forEach((name) => {
      const cmd = replServer.commands[name];
      if (cmd) {
        replServer.output.write(`${name}	${cmd.help || ""}
`);
      }
    });
  }
  function defineDefaultCommandsOnRepl(replServer) {
    replServer.defineCommand("help", {
      help: "Show REPL options",
      action(name) {
        this.clearBufferedCommand();
        if (name) {
          const nativeCommandOrFunction = this.commands[name] || this.context[name];
          const helpMessage = nativeCommandOrFunction === null || nativeCommandOrFunction === void 0 ? void 0 : nativeCommandOrFunction.help;
          if (helpMessage) {
            this.output.write(`${helpMessage}
`);
          }
        } else {
          listAllCommands(this);
          this.output.write("\n\n");
          this.context.help();
          this.output.write("\nPress Ctrl+C to abort current expression, Ctrl+D to exit the REPL\n");
        }
        this.displayPrompt();
      }
    });
  }
  replNativeCommands.defineDefaultCommandsOnRepl = defineDefaultCommandsOnRepl;
  return replNativeCommands;
}
var hasRequiredRepl$1;
function requireRepl$1() {
  if (hasRequiredRepl$1)
    return repl;
  hasRequiredRepl$1 = 1;
  Object.defineProperty(repl, "__esModule", { value: true });
  repl.repl = void 0;
  const common_1 = requireCommon$3();
  const cli_colors_util_1 = requireCliColors_util();
  const nest_factory_1 = requireNestFactory();
  const assign_to_object_util_1 = requireAssignToObject_util();
  const constants_1 = requireConstants();
  const repl_context_1 = requireReplContext();
  const repl_logger_1 = requireReplLogger();
  const repl_native_commands_1 = requireReplNativeCommands();
  async function repl$12(module2) {
    const app2 = await nest_factory_1.NestFactory.createApplicationContext(module2, {
      abortOnError: false,
      logger: new repl_logger_1.ReplLogger()
    });
    await app2.init();
    const replContext2 = new repl_context_1.ReplContext(app2);
    common_1.Logger.log(constants_1.REPL_INITIALIZED_MESSAGE);
    const _repl = await Promise.resolve().then(() => require$$8$2);
    const replServer = _repl.start({
      prompt: cli_colors_util_1.clc.green("> "),
      ignoreUndefined: true
    });
    (0, assign_to_object_util_1.assignToObject)(replServer.context, replContext2.globalScope);
    (0, repl_native_commands_1.defineDefaultCommandsOnRepl)(replServer);
    return replServer;
  }
  repl.repl = repl$12;
  return repl;
}
var hasRequiredRepl;
function requireRepl() {
  if (hasRequiredRepl)
    return repl$1;
  hasRequiredRepl = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireRepl$1(), exports2);
  })(repl$1);
  return repl$1;
}
var router = {};
var interfaces = {};
var routes_interface = {};
var hasRequiredRoutes_interface;
function requireRoutes_interface() {
  if (hasRequiredRoutes_interface)
    return routes_interface;
  hasRequiredRoutes_interface = 1;
  Object.defineProperty(routes_interface, "__esModule", { value: true });
  return routes_interface;
}
var hasRequiredInterfaces;
function requireInterfaces() {
  if (hasRequiredInterfaces)
    return interfaces;
  hasRequiredInterfaces = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireRoutes_interface(), exports2);
  })(interfaces);
  return interfaces;
}
var request = {};
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest)
    return request;
  hasRequiredRequest = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.REQUEST = void 0;
    var request_constants_1 = requireRequestConstants();
    Object.defineProperty(exports2, "REQUEST", { enumerable: true, get: function() {
      return request_constants_1.REQUEST;
    } });
  })(request);
  return request;
}
var hasRequiredRouter;
function requireRouter() {
  if (hasRequiredRouter)
    return router;
  hasRequiredRouter = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RouterModule = void 0;
    const tslib_1 = require$$0$3;
    tslib_1.__exportStar(requireInterfaces(), exports2);
    tslib_1.__exportStar(requireRequest(), exports2);
    var router_module_1 = requireRouterModule();
    Object.defineProperty(exports2, "RouterModule", { enumerable: true, get: function() {
      return router_module_1.RouterModule;
    } });
  })(router);
  return router;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.NestFactory = exports2.APP_PIPE = exports2.APP_INTERCEPTOR = exports2.APP_GUARD = exports2.APP_FILTER = void 0;
  const tslib_1 = require$$0$3;
  tslib_1.__exportStar(requireAdapters$1(), exports2);
  tslib_1.__exportStar(requireApplicationConfig(), exports2);
  var constants_1 = requireConstants$5();
  Object.defineProperty(exports2, "APP_FILTER", { enumerable: true, get: function() {
    return constants_1.APP_FILTER;
  } });
  Object.defineProperty(exports2, "APP_GUARD", { enumerable: true, get: function() {
    return constants_1.APP_GUARD;
  } });
  Object.defineProperty(exports2, "APP_INTERCEPTOR", { enumerable: true, get: function() {
    return constants_1.APP_INTERCEPTOR;
  } });
  Object.defineProperty(exports2, "APP_PIPE", { enumerable: true, get: function() {
    return constants_1.APP_PIPE;
  } });
  tslib_1.__exportStar(requireDiscovery(), exports2);
  tslib_1.__exportStar(requireExceptions$1(), exports2);
  tslib_1.__exportStar(requireHelpers(), exports2);
  tslib_1.__exportStar(requireInjector(), exports2);
  tslib_1.__exportStar(requireInspector(), exports2);
  tslib_1.__exportStar(requireMetadataScanner(), exports2);
  tslib_1.__exportStar(requireMiddleware(), exports2);
  tslib_1.__exportStar(requireNestApplication(), exports2);
  tslib_1.__exportStar(requireNestApplicationContext(), exports2);
  var nest_factory_1 = requireNestFactory();
  Object.defineProperty(exports2, "NestFactory", { enumerable: true, get: function() {
    return nest_factory_1.NestFactory;
  } });
  tslib_1.__exportStar(requireRepl(), exports2);
  tslib_1.__exportStar(requireRouter(), exports2);
  tslib_1.__exportStar(requireServices(), exports2);
})(core$d);
var commonExports = requireCommon$3();
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i = 0; i < pathArray.length; i++) {
    let p = pathArray[i];
    while (p[p.length - 1] === "\\" && pathArray[i + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i = 0; i < pathArray.length; i++) {
      object = object[pathArray[i]];
      if (object === void 0 || object === null) {
        if (i !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root = object;
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i = 0; i < pathArray.length; i++) {
      const p = pathArray[i];
      if (i === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i = 0; i < pathArray.length; i++) {
      if (isObj(object)) {
        if (!(pathArray[i] in object)) {
          return false;
        }
        object = object[pathArray[i]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$3 = require$$1$3;
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$3.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$3.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pathExistsExports = pathExists$1.exports;
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
var pTryExports = pTry$2.exports;
const pTry = pTryExports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue2 = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue2.length > 0) {
      queue2.shift()();
    }
  };
  const run = (fn, resolve2, ...args2) => {
    activeCount++;
    const result = pTry(fn, ...args2);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue = (fn, resolve2, ...args2) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args2);
    } else {
      queue2.push(run.bind(null, fn, resolve2, ...args2));
    }
  };
  const generator = (fn, ...args2) => new Promise((resolve2) => enqueue(fn, resolve2, ...args2));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue2.length
    },
    clearQueue: {
      value: () => {
        queue2.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
var pLimitExports = pLimit$2.exports;
const pLimit = pLimitExports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts) => {
  opts = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts);
  const limit2 = pLimit(opts.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$6 = require$$0$6;
const pathExists = pathExistsExports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$6.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$6.resolve(options.cwd, el))) {
      return el;
    }
  }
};
var locatePathExports = locatePath$1.exports;
const path$5 = require$$0$6;
const locatePath = locatePathExports;
findUp$1.exports = (filename, opts = {}) => {
  const startDir = path$5.resolve(opts.cwd || "");
  const { root } = path$5.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find2(dir) {
      locatePath(filenames, { cwd: dir }).then((file2) => {
        if (file2) {
          resolve2(path$5.join(dir, file2));
        } else if (dir === root) {
          resolve2(null);
        } else {
          find2(path$5.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts = {}) => {
  let dir = path$5.resolve(opts.cwd || "");
  const { root } = path$5.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file2 = locatePath.sync(filenames, { cwd: dir });
    if (file2) {
      return path$5.join(dir, file2);
    }
    if (dir === root) {
      return null;
    }
    dir = path$5.dirname(dir);
  }
};
var findUpExports = findUp$1.exports;
const findUp = findUpExports;
pkgUp.exports = async ({ cwd } = {}) => findUp("package.json", { cwd });
pkgUp.exports.sync = ({ cwd } = {}) => findUp.sync("package.json", { cwd });
var pkgUpExports = pkgUp.exports;
var envPaths$1 = { exports: {} };
const path$4 = require$$0$6;
const os = require$$1$2;
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env } = process;
const macos = (name) => {
  const library = path$4.join(homedir, "Library");
  return {
    data: path$4.join(library, "Application Support", name),
    config: path$4.join(library, "Preferences", name),
    cache: path$4.join(library, "Caches", name),
    log: path$4.join(library, "Logs", name),
    temp: path$4.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env.APPDATA || path$4.join(homedir, "AppData", "Roaming");
  const localAppData = env.LOCALAPPDATA || path$4.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path$4.join(localAppData, name, "Data"),
    config: path$4.join(appData, name, "Config"),
    cache: path$4.join(localAppData, name, "Cache"),
    log: path$4.join(localAppData, name, "Log"),
    temp: path$4.join(tmpdir, name)
  };
};
const linux$1 = (name) => {
  const username = path$4.basename(homedir);
  return {
    data: path$4.join(env.XDG_DATA_HOME || path$4.join(homedir, ".local", "share"), name),
    config: path$4.join(env.XDG_CONFIG_HOME || path$4.join(homedir, ".config"), name),
    cache: path$4.join(env.XDG_CACHE_HOME || path$4.join(homedir, ".cache"), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path$4.join(env.XDG_STATE_HOME || path$4.join(homedir, ".local", "state"), name),
    temp: path$4.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux$1(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var envPathsExports = envPaths$1.exports;
var dist$i = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$2 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: /* @__PURE__ */ new Set(),
  queueWaiting: /* @__PURE__ */ new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver2);
      const resolver2 = () => resolve2(cleanup);
      RetryfyQueue.add(resolver2);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp2) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp2)
            throw error2;
          if (isRetriableError(error2)) {
            const delay2 = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay2));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp2) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp2)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$2, "__esModule", { value: true });
const fs$1 = require$$1$3;
const util_1$T = require$$1$1;
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$T.promisify(fs$1.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$T.promisify(fs$1.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$T.promisify(fs$1.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$T.promisify(fs$1.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$T.promisify(fs$1.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$T.promisify(fs$1.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$T.promisify(fs$1.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$T.promisify(fs$1.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$T.promisify(fs$1.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$T.promisify(fs$1.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$T.promisify(fs$1.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$T.promisify(fs$1.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$T.promisify(fs$1.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$T.promisify(fs$1.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$T.promisify(fs$1.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs$1.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs$1.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs$1.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs$1.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs$1.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs$1.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs$1.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs$1.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs$1.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs$1.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs$1.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs$1.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs$1.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs$1.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$2.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue2 = Queues[id2];
    if (!queue2)
      return;
    queue2.shift();
    const job = queue2[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue2 = Queues[id2];
      if (!queue2)
        queue2 = Queues[id2] = [];
      queue2.push(resolve2);
      if (queue2.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$3 = require$$0$6;
const consts_1$1 = consts;
const fs_1$1 = fs$2;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp2 = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp2}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$3.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$i, "__esModule", { value: true });
dist$i.writeFileSync = dist$i.writeFile = dist$i.readFileSync = dist$i.readFile = void 0;
const path$2 = require$$0$6;
const consts_1 = consts;
const fs_1 = fs$2;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout2 = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout2)(filePath, options);
}
dist$i.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout2 = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout2)(filePath, options);
}
dist$i.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$i.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout2 = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat = await fs_1.default.statAttempt(filePath);
      if (stat) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat.uid, gid: stat.gid };
        if (useStatMode)
          options.mode = stat.mode;
      }
    }
    const parentPath = path$2.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout2)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout2)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout2)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout2)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout2)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout2)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout2)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout2 = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat = fs_1.default.statSyncAttempt(filePath);
      if (stat) {
        options = { ...options };
        if (useStatChown)
          options.chown = { uid: stat.uid, gid: stat.gid };
        if (useStatMode)
          options.mode = stat.mode;
      }
    }
    const parentPath = path$2.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout2)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout2)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout2)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout2)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout2)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout2)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout2)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$i.writeFileSync = writeFileSync;
var ajv$1 = { exports: {} };
var core$5 = {};
var validate$1 = {};
var boolSchema$1 = {};
var errors$2 = {};
var codegen$1 = {};
var code$3 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports2._CodeOrName = _CodeOrName;
  exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports2.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports2.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports2._Code = _Code;
  exports2.nil = new _Code("");
  function _(strs, ...args2) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args2.length) {
      addCodeArg(code2, args2[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports2._ = _;
  const plus = new _Code("+");
  function str(strs, ...args2) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args2.length) {
      expr.push(plus);
      addCodeArg(expr, args2[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports2.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports2.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports2.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify(x) {
    return new _Code(safeStringify(x));
  }
  exports2.stringify = stringify;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports2.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports2.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports2.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports2.regexpCode = regexpCode;
})(code$3);
var scope$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
  const code_12 = code$3;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
  exports2.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports2.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports2.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports2.ValueScope = ValueScope;
})(scope$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
  const code_12 = code$3;
  const scope_1 = scope$1;
  var code_2 = code$3;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope$1;
  Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports2.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from2, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from2;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from: from2, to } = this;
      return `for(${varKind} ${name}=${from2}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args2, async2) {
      super();
      this.name = name;
      this.args = args2;
      this.async = async2;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node2, forBody) {
      this._blockNode(node2);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from2, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from2, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i) => {
          this.var(name, (0, code_12._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node2 = new Return();
      this._blockNode(node2);
      this.code(value);
      if (node2.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node2 = new Try();
      this._blockNode(node2);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node2.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node2.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args2 = code_12.nil, async2, funcBody) {
      this._blockNode(new Func(name, args2, async2));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node2) {
      this._currNode.nodes.push(node2);
      return this;
    }
    _blockNode(node2) {
      this._currNode.nodes.push(node2);
      this._nodes.push(node2);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node2) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node2;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node2) {
      const ns = this._nodes;
      ns[ns.length - 1] = node2;
    }
  }
  exports2.CodeGen = CodeGen;
  function addNames(names2, from2) {
    for (const n in from2)
      names2[n] = (names2[n] || 0) + (from2[n] || 0);
    return names2;
  }
  function addExprNames(names2, from2) {
    return from2 instanceof code_12._CodeOrName ? addNames(names2, from2.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from2) {
    for (const n in from2)
      names2[n] = (names2[n] || 0) - (from2[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_12._)`!${par(x)}`;
  }
  exports2.not = not2;
  const andCode = mappend(exports2.operators.AND);
  function and(...args2) {
    return args2.reduce(andCode);
  }
  exports2.and = and;
  const orCode = mappend(exports2.operators.OR);
  function or(...args2) {
    return args2.reduce(orCode);
  }
  exports2.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : (0, code_12._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : (0, code_12._)`(${x})`;
  }
})(codegen$1);
var util$4 = {};
Object.defineProperty(util$4, "__esModule", { value: true });
util$4.checkStrictMode = util$4.getErrorPath = util$4.Type = util$4.useFunc = util$4.setEvaluated = util$4.evaluatedPropsToName = util$4.mergeEvaluated = util$4.eachItem = util$4.unescapeJsonPointer = util$4.escapeJsonPointer = util$4.escapeFragment = util$4.unescapeFragment = util$4.schemaRefOrVal = util$4.schemaHasRulesButRef = util$4.schemaHasRules = util$4.checkUnknownRules = util$4.alwaysValidSchema = util$4.toHash = void 0;
const codegen_1$$ = codegen$1;
const code_1$l = code$3;
function toHash$1(arr) {
  const hash = {};
  for (const item of arr)
    hash[item] = true;
  return hash;
}
util$4.toHash = toHash$1;
function alwaysValidSchema$1(it, schema) {
  if (typeof schema == "boolean")
    return schema;
  if (Object.keys(schema).length === 0)
    return true;
  checkUnknownRules$1(it, schema);
  return !schemaHasRules$1(schema, it.self.RULES.all);
}
util$4.alwaysValidSchema = alwaysValidSchema$1;
function checkUnknownRules$1(it, schema = it.schema) {
  const { opts, self: self2 } = it;
  if (!opts.strictSchema)
    return;
  if (typeof schema === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key in schema) {
    if (!rules2[key])
      checkStrictMode$1(it, `unknown keyword: "${key}"`);
  }
}
util$4.checkUnknownRules = checkUnknownRules$1;
function schemaHasRules$1(schema, rules2) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (rules2[key])
      return true;
  return false;
}
util$4.schemaHasRules = schemaHasRules$1;
function schemaHasRulesButRef$1(schema, RULES) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (key !== "$ref" && RULES.all[key])
      return true;
  return false;
}
util$4.schemaHasRulesButRef = schemaHasRulesButRef$1;
function schemaRefOrVal$1({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
  if (!$data) {
    if (typeof schema == "number" || typeof schema == "boolean")
      return schema;
    if (typeof schema == "string")
      return (0, codegen_1$$._)`${schema}`;
  }
  return (0, codegen_1$$._)`${topSchemaRef}${schemaPath}${(0, codegen_1$$.getProperty)(keyword2)}`;
}
util$4.schemaRefOrVal = schemaRefOrVal$1;
function unescapeFragment$1(str) {
  return unescapeJsonPointer$1(decodeURIComponent(str));
}
util$4.unescapeFragment = unescapeFragment$1;
function escapeFragment$1(str) {
  return encodeURIComponent(escapeJsonPointer$1(str));
}
util$4.escapeFragment = escapeFragment$1;
function escapeJsonPointer$1(str) {
  if (typeof str == "number")
    return `${str}`;
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util$4.escapeJsonPointer = escapeJsonPointer$1;
function unescapeJsonPointer$1(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util$4.unescapeJsonPointer = unescapeJsonPointer$1;
function eachItem$1(xs, f) {
  if (Array.isArray(xs)) {
    for (const x of xs)
      f(x);
  } else {
    f(xs);
  }
}
util$4.eachItem = eachItem$1;
function makeMergeEvaluated$1({ mergeNames, mergeToName, mergeValues, resultToName }) {
  return (gen, from2, to, toName) => {
    const res = to === void 0 ? from2 : to instanceof codegen_1$$.Name ? (from2 instanceof codegen_1$$.Name ? mergeNames(gen, from2, to) : mergeToName(gen, from2, to), to) : from2 instanceof codegen_1$$.Name ? (mergeToName(gen, to, from2), from2) : mergeValues(from2, to);
    return toName === codegen_1$$.Name && !(res instanceof codegen_1$$.Name) ? resultToName(gen, res) : res;
  };
}
util$4.mergeEvaluated = {
  props: makeMergeEvaluated$1({
    mergeNames: (gen, from2, to) => gen.if((0, codegen_1$$._)`${to} !== true && ${from2} !== undefined`, () => {
      gen.if((0, codegen_1$$._)`${from2} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$$._)`${to} || {}`).code((0, codegen_1$$._)`Object.assign(${to}, ${from2})`));
    }),
    mergeToName: (gen, from2, to) => gen.if((0, codegen_1$$._)`${to} !== true`, () => {
      if (from2 === true) {
        gen.assign(to, true);
      } else {
        gen.assign(to, (0, codegen_1$$._)`${to} || {}`);
        setEvaluated$1(gen, to, from2);
      }
    }),
    mergeValues: (from2, to) => from2 === true ? true : { ...from2, ...to },
    resultToName: evaluatedPropsToName$1
  }),
  items: makeMergeEvaluated$1({
    mergeNames: (gen, from2, to) => gen.if((0, codegen_1$$._)`${to} !== true && ${from2} !== undefined`, () => gen.assign(to, (0, codegen_1$$._)`${from2} === true ? true : ${to} > ${from2} ? ${to} : ${from2}`)),
    mergeToName: (gen, from2, to) => gen.if((0, codegen_1$$._)`${to} !== true`, () => gen.assign(to, from2 === true ? true : (0, codegen_1$$._)`${to} > ${from2} ? ${to} : ${from2}`)),
    mergeValues: (from2, to) => from2 === true ? true : Math.max(from2, to),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName$1(gen, ps) {
  if (ps === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$$._)`{}`);
  if (ps !== void 0)
    setEvaluated$1(gen, props, ps);
  return props;
}
util$4.evaluatedPropsToName = evaluatedPropsToName$1;
function setEvaluated$1(gen, props, ps) {
  Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$$._)`${props}${(0, codegen_1$$.getProperty)(p)}`, true));
}
util$4.setEvaluated = setEvaluated$1;
const snippets$1 = {};
function useFunc$1(gen, f) {
  return gen.scopeValue("func", {
    ref: f,
    code: snippets$1[f.code] || (snippets$1[f.code] = new code_1$l._Code(f.code))
  });
}
util$4.useFunc = useFunc$1;
var Type$1;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type$1 || (util$4.Type = Type$1 = {}));
function getErrorPath$1(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$$.Name) {
    const isNumber2 = dataPropType === Type$1.Num;
    return jsPropertySyntax ? isNumber2 ? (0, codegen_1$$._)`"[" + ${dataProp} + "]"` : (0, codegen_1$$._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1$$._)`"/" + ${dataProp}` : (0, codegen_1$$._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$$.getProperty)(dataProp).toString() : "/" + escapeJsonPointer$1(dataProp);
}
util$4.getErrorPath = getErrorPath$1;
function checkStrictMode$1(it, msg, mode = it.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it.self.logger.warn(msg);
}
util$4.checkStrictMode = checkStrictMode$1;
var names$3 = {};
Object.defineProperty(names$3, "__esModule", { value: true });
const codegen_1$_ = codegen$1;
const names$2 = {
  // validation function arguments
  data: new codegen_1$_.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$_.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$_.Name("instancePath"),
  parentData: new codegen_1$_.Name("parentData"),
  parentDataProperty: new codegen_1$_.Name("parentDataProperty"),
  rootData: new codegen_1$_.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$_.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$_.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$_.Name("errors"),
  // counter of validation errors
  this: new codegen_1$_.Name("this"),
  // "globals"
  self: new codegen_1$_.Name("self"),
  scope: new codegen_1$_.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$_.Name("json"),
  jsonPos: new codegen_1$_.Name("jsonPos"),
  jsonLen: new codegen_1$_.Name("jsonLen"),
  jsonPart: new codegen_1$_.Name("jsonPart")
};
names$3.default = names$2;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
  const codegen_12 = codegen$1;
  const util_12 = util$4;
  const names_12 = names$3;
  exports2.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports2.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports2.reportError = reportError;
  function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports2.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports2.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports2.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors$2);
Object.defineProperty(boolSchema$1, "__esModule", { value: true });
boolSchema$1.boolOrEmptySchema = boolSchema$1.topBoolOrEmptySchema = void 0;
const errors_1$7 = errors$2;
const codegen_1$Z = codegen$1;
const names_1$d = names$3;
const boolError$1 = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema$1(it) {
  const { gen, schema, validateName } = it;
  if (schema === false) {
    falseSchemaError$1(it, false);
  } else if (typeof schema == "object" && schema.$async === true) {
    gen.return(names_1$d.default.data);
  } else {
    gen.assign((0, codegen_1$Z._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema$1.topBoolOrEmptySchema = topBoolOrEmptySchema$1;
function boolOrEmptySchema$1(it, valid2) {
  const { gen, schema } = it;
  if (schema === false) {
    gen.var(valid2, false);
    falseSchemaError$1(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema$1.boolOrEmptySchema = boolOrEmptySchema$1;
function falseSchemaError$1(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  (0, errors_1$7.reportError)(cxt, boolError$1, void 0, overrideAllErrors);
}
var dataType$1 = {};
var rules$1 = {};
Object.defineProperty(rules$1, "__esModule", { value: true });
rules$1.getRules = rules$1.isJSONType = void 0;
const _jsonTypes$1 = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes$1 = new Set(_jsonTypes$1);
function isJSONType$1(x) {
  return typeof x == "string" && jsonTypes$1.has(x);
}
rules$1.isJSONType = isJSONType$1;
function getRules$1() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules$1.getRules = getRules$1;
var applicability$1 = {};
Object.defineProperty(applicability$1, "__esModule", { value: true });
applicability$1.shouldUseRule = applicability$1.shouldUseGroup = applicability$1.schemaHasRulesForType = void 0;
function schemaHasRulesForType$1({ schema, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup$1(schema, group);
}
applicability$1.schemaHasRulesForType = schemaHasRulesForType$1;
function shouldUseGroup$1(schema, group) {
  return group.rules.some((rule) => shouldUseRule$1(schema, rule));
}
applicability$1.shouldUseGroup = shouldUseGroup$1;
function shouldUseRule$1(schema, rule) {
  var _a;
  return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
}
applicability$1.shouldUseRule = shouldUseRule$1;
Object.defineProperty(dataType$1, "__esModule", { value: true });
dataType$1.reportTypeError = dataType$1.checkDataTypes = dataType$1.checkDataType = dataType$1.coerceAndCheckDataType = dataType$1.getJSONTypes = dataType$1.getSchemaTypes = dataType$1.DataType = void 0;
const rules_1$1 = rules$1;
const applicability_1$3 = applicability$1;
const errors_1$6 = errors$2;
const codegen_1$Y = codegen$1;
const util_1$S = util$4;
var DataType$1;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType$1 || (dataType$1.DataType = DataType$1 = {}));
function getSchemaTypes$1(schema) {
  const types2 = getJSONTypes$1(schema.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType$1.getSchemaTypes = getSchemaTypes$1;
function getJSONTypes$1(ts) {
  const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
  if (types2.every(rules_1$1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType$1.getJSONTypes = getJSONTypes$1;
function coerceAndCheckDataType$1(it, types2) {
  const { gen, data, opts } = it;
  const coerceTo = coerceToTypes$1(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$3.schemaHasRulesForType)(it, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes$1(types2, data, opts.strictNumbers, DataType$1.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData$1(it, types2, coerceTo);
      else
        reportTypeError$1(it);
    });
  }
  return checkTypes;
}
dataType$1.coerceAndCheckDataType = coerceAndCheckDataType$1;
const COERCIBLE$1 = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes$1(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE$1.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData$1(it, types2, coerceTo) {
  const { gen, data, opts } = it;
  const dataType2 = gen.let("dataType", (0, codegen_1$Y._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$Y._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$Y._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$Y._)`${data}[0]`).assign(dataType2, (0, codegen_1$Y._)`typeof ${data}`).if(checkDataTypes$1(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$Y._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE$1.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError$1(it);
  gen.endIf();
  gen.if((0, codegen_1$Y._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData$1(it, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$Y._)`"" + ${data}`).elseIf((0, codegen_1$Y._)`${data} === null`).assign(coerced, (0, codegen_1$Y._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$Y._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$Y._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$Y._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$Y._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$Y._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$Y._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$Y._)`[${data}]`);
    }
  }
}
function assignParentData$1({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$Y._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$Y._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType$1(dataType2, data, strictNums, correct = DataType$1.Correct) {
  const EQ = correct === DataType$1.Correct ? codegen_1$Y.operators.EQ : codegen_1$Y.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$Y._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$Y._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$Y._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$Y._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$Y._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType$1.Correct ? cond : (0, codegen_1$Y.not)(cond);
  function numCond(_cond = codegen_1$Y.nil) {
    return (0, codegen_1$Y.and)((0, codegen_1$Y._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$Y._)`isFinite(${data})` : codegen_1$Y.nil);
  }
}
dataType$1.checkDataType = checkDataType$1;
function checkDataTypes$1(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType$1(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$S.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$Y._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$Y._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$Y.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$Y.and)(cond, checkDataType$1(t2, data, strictNums, correct));
  return cond;
}
dataType$1.checkDataTypes = checkDataTypes$1;
const typeError$1 = {
  message: ({ schema }) => `must be ${schema}`,
  params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$Y._)`{type: ${schema}}` : (0, codegen_1$Y._)`{type: ${schemaValue}}`
};
function reportTypeError$1(it) {
  const cxt = getTypeErrorContext$1(it);
  (0, errors_1$6.reportError)(cxt, typeError$1);
}
dataType$1.reportTypeError = reportTypeError$1;
function getTypeErrorContext$1(it) {
  const { gen, data, schema } = it;
  const schemaCode = (0, util_1$S.schemaRefOrVal)(it, schema, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema,
    params: {},
    it
  };
}
var defaults$3 = {};
Object.defineProperty(defaults$3, "__esModule", { value: true });
defaults$3.assignDefaults = void 0;
const codegen_1$X = codegen$1;
const util_1$R = util$4;
function assignDefaults$1(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault$1(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault$1(it, i, sch.default));
  }
}
defaults$3.assignDefaults = assignDefaults$1;
function assignDefault$1(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$X._)`${data}${(0, codegen_1$X.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$R.checkStrictMode)(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$X._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$X._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$X._)`${childData} = ${(0, codegen_1$X.stringify)(defaultValue)}`);
}
var keyword$1 = {};
var code$2 = {};
Object.defineProperty(code$2, "__esModule", { value: true });
code$2.validateUnion = code$2.validateArray = code$2.usePattern = code$2.callValidateCode = code$2.schemaProperties = code$2.allSchemaProperties = code$2.noPropertyInData = code$2.propertyInData = code$2.isOwnProperty = code$2.hasPropFunc = code$2.reportMissingProp = code$2.checkMissingProp = code$2.checkReportMissingProp = void 0;
const codegen_1$W = codegen$1;
const util_1$Q = util$4;
const names_1$c = names$3;
const util_2$3 = util$4;
function checkReportMissingProp$1(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData$1(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$W._)`${prop}` }, true);
    cxt.error();
  });
}
code$2.checkReportMissingProp = checkReportMissingProp$1;
function checkMissingProp$1({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$W.or)(...properties2.map((prop) => (0, codegen_1$W.and)(noPropertyInData$1(gen, data, prop, opts.ownProperties), (0, codegen_1$W._)`${missing} = ${prop}`)));
}
code$2.checkMissingProp = checkMissingProp$1;
function reportMissingProp$1(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code$2.reportMissingProp = reportMissingProp$1;
function hasPropFunc$1(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$W._)`Object.prototype.hasOwnProperty`
  });
}
code$2.hasPropFunc = hasPropFunc$1;
function isOwnProperty$1(gen, data, property) {
  return (0, codegen_1$W._)`${hasPropFunc$1(gen)}.call(${data}, ${property})`;
}
code$2.isOwnProperty = isOwnProperty$1;
function propertyInData$1(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$W._)`${data}${(0, codegen_1$W.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$W._)`${cond} && ${isOwnProperty$1(gen, data, property)}` : cond;
}
code$2.propertyInData = propertyInData$1;
function noPropertyInData$1(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$W._)`${data}${(0, codegen_1$W.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$W.or)(cond, (0, codegen_1$W.not)(isOwnProperty$1(gen, data, property))) : cond;
}
code$2.noPropertyInData = noPropertyInData$1;
function allSchemaProperties$1(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code$2.allSchemaProperties = allSchemaProperties$1;
function schemaProperties$1(it, schemaMap) {
  return allSchemaProperties$1(schemaMap).filter((p) => !(0, util_1$Q.alwaysValidSchema)(it, schemaMap[p]));
}
code$2.schemaProperties = schemaProperties$1;
function callValidateCode$1({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$W._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$c.default.instancePath, (0, codegen_1$W.strConcat)(names_1$c.default.instancePath, errorPath)],
    [names_1$c.default.parentData, it.parentData],
    [names_1$c.default.parentDataProperty, it.parentDataProperty],
    [names_1$c.default.rootData, names_1$c.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$c.default.dynamicAnchors, names_1$c.default.dynamicAnchors]);
  const args2 = (0, codegen_1$W._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$W.nil ? (0, codegen_1$W._)`${func}.call(${context}, ${args2})` : (0, codegen_1$W._)`${func}(${args2})`;
}
code$2.callValidateCode = callValidateCode$1;
const newRegExp$1 = (0, codegen_1$W._)`new RegExp`;
function usePattern$1({ gen, it: { opts } }, pattern2) {
  const u = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$W._)`${regExp.code === "new RegExp" ? newRegExp$1 : (0, util_2$3.useFunc)(gen, regExp)}(${pattern2}, ${u})`
  });
}
code$2.usePattern = usePattern$1;
function validateArray$1(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$W._)`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$Q.Type.Num
      }, valid2);
      gen.if((0, codegen_1$W.not)(valid2), notValid);
    });
  }
}
code$2.validateArray = validateArray$1;
function validateUnion$1(cxt) {
  const { gen, schema, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema))
    throw new Error("ajv implementation error");
  const alwaysValid = schema.some((sch) => (0, util_1$Q.alwaysValidSchema)(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$W._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$W.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code$2.validateUnion = validateUnion$1;
Object.defineProperty(keyword$1, "__esModule", { value: true });
keyword$1.validateKeywordUsage = keyword$1.validSchemaType = keyword$1.funcKeywordCode = keyword$1.macroKeywordCode = void 0;
const codegen_1$V = codegen$1;
const names_1$b = names$3;
const code_1$k = code$2;
const errors_1$5 = errors$2;
function macroKeywordCode$1(cxt, def2) {
  const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
  const schemaRef = useKeyword$1(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$V.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword$1.macroKeywordCode = macroKeywordCode$1;
function funcKeywordCode$1(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
  checkAsyncKeyword$1(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
  const validateRef = useKeyword$1(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData$1(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData$1(cxt);
      reportErrs(() => addErrs$1(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$V._)`await `), (e) => gen.assign(valid2, false).if((0, codegen_1$V._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$V._)`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$V._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$V.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$V._)`await ` : codegen_1$V.nil) {
    const passCxt = it.opts.passContext ? names_1$b.default.this : names_1$b.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$V._)`${_await}${(0, code_1$k.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if((0, codegen_1$V.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword$1.funcKeywordCode = funcKeywordCode$1;
function modifyData$1(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$V._)`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs$1(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$V._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$b.default.vErrors, (0, codegen_1$V._)`${names_1$b.default.vErrors} === null ? ${errs} : ${names_1$b.default.vErrors}.concat(${errs})`).assign(names_1$b.default.errors, (0, codegen_1$V._)`${names_1$b.default.vErrors}.length`);
    (0, errors_1$5.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword$1({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword$1(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$V.stringify)(result) });
}
function validSchemaType$1(schema, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
}
keyword$1.validSchemaType = validSchemaType$1;
function validateKeywordUsage$1({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword$1.validateKeywordUsage = validateKeywordUsage$1;
var subschema$1 = {};
Object.defineProperty(subschema$1, "__esModule", { value: true });
subschema$1.extendSubschemaMode = subschema$1.extendSubschemaData = subschema$1.getSubschema = void 0;
const codegen_1$U = codegen$1;
const util_1$P = util$4;
function getSubschema$1(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$U._)`${it.schemaPath}${(0, codegen_1$U.getProperty)(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$U._)`${it.schemaPath}${(0, codegen_1$U.getProperty)(keyword2)}${(0, codegen_1$U.getProperty)(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1$P.escapeFragment)(schemaProp)}`
    };
  }
  if (schema !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema$1.getSubschema = getSubschema$1;
function extendSubschemaData$1(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it;
    const nextData = gen.let("data", (0, codegen_1$U._)`${it.data}${(0, codegen_1$U.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$U.str)`${errorPath}${(0, util_1$P.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$U._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$U.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema$1.extendSubschemaData = extendSubschemaData$1;
function extendSubschemaMode$1(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema$1.extendSubschemaMode = extendSubschemaMode$1;
var resolve$4 = {};
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse$1 = { exports: {} };
var traverse$3 = jsonSchemaTraverse$1.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse$1(opts, pre, post, schema, "", schema);
};
traverse$3.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$3.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$3.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$3.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse$1(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$3.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse$1(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$3.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse$1(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr$1(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$3.keywords || opts.allKeys && !(key in traverse$3.skipKeywords)) {
        _traverse$1(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr$1(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports$1 = jsonSchemaTraverse$1.exports;
Object.defineProperty(resolve$4, "__esModule", { value: true });
resolve$4.getSchemaRefs = resolve$4.resolveUrl = resolve$4.normalizeId = resolve$4._getFullPath = resolve$4.getFullPath = resolve$4.inlineRef = void 0;
const util_1$O = util$4;
const equal$6 = fastDeepEqual;
const traverse$2 = jsonSchemaTraverseExports$1;
const SIMPLE_INLINED$1 = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef$1(schema, limit2 = true) {
  if (typeof schema == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef$1(schema);
  if (!limit2)
    return false;
  return countKeys$1(schema) <= limit2;
}
resolve$4.inlineRef = inlineRef$1;
const REF_KEYWORDS$1 = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef$1(schema) {
  for (const key in schema) {
    if (REF_KEYWORDS$1.has(key))
      return true;
    const sch = schema[key];
    if (Array.isArray(sch) && sch.some(hasRef$1))
      return true;
    if (typeof sch == "object" && hasRef$1(sch))
      return true;
  }
  return false;
}
function countKeys$1(schema) {
  let count2 = 0;
  for (const key in schema) {
    if (key === "$ref")
      return Infinity;
    count2++;
    if (SIMPLE_INLINED$1.has(key))
      continue;
    if (typeof schema[key] == "object") {
      (0, util_1$O.eachItem)(schema[key], (sch) => count2 += countKeys$1(sch));
    }
    if (count2 === Infinity)
      return Infinity;
  }
  return count2;
}
function getFullPath$1(resolver2, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId$1(id2);
  const p = resolver2.parse(id2);
  return _getFullPath$1(resolver2, p);
}
resolve$4.getFullPath = getFullPath$1;
function _getFullPath$1(resolver2, p) {
  const serialized = resolver2.serialize(p);
  return serialized.split("#")[0] + "#";
}
resolve$4._getFullPath = _getFullPath$1;
const TRAILING_SLASH_HASH$1 = /#\/?$/;
function normalizeId$1(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH$1, "") : "";
}
resolve$4.normalizeId = normalizeId$1;
function resolveUrl$2(resolver2, baseId, id2) {
  id2 = normalizeId$1(id2);
  return resolver2.resolve(baseId, id2);
}
resolve$4.resolveUrl = resolveUrl$2;
const ANCHOR$1 = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs$1(schema, baseId) {
  if (typeof schema == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId$1(schema[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath$1(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse$2(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId$1(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId$1(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR$1.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$6(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$4.getSchemaRefs = getSchemaRefs$1;
Object.defineProperty(validate$1, "__esModule", { value: true });
validate$1.getData = validate$1.KeywordCxt = validate$1.validateFunctionCode = void 0;
const boolSchema_1$1 = boolSchema$1;
const dataType_1$3 = dataType$1;
const applicability_1$2 = applicability$1;
const dataType_2$1 = dataType$1;
const defaults_1$1 = defaults$3;
const keyword_1$1 = keyword$1;
const subschema_1$1 = subschema$1;
const codegen_1$T = codegen$1;
const names_1$a = names$3;
const resolve_1$5 = resolve$4;
const util_1$N = util$4;
const errors_1$4 = errors$2;
function validateFunctionCode$1(it) {
  if (isSchemaObj$1(it)) {
    checkKeywords$1(it);
    if (schemaCxtHasRules$1(it)) {
      topSchemaObjCode$1(it);
      return;
    }
  }
  validateFunction$1(it, () => (0, boolSchema_1$1.topBoolOrEmptySchema)(it));
}
validate$1.validateFunctionCode = validateFunctionCode$1;
function validateFunction$1({ gen, validateName, schema, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$T._)`${names_1$a.default.data}, ${names_1$a.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$T._)`"use strict"; ${funcSourceUrl$1(schema, opts)}`);
      destructureValCxtES5$1(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$T._)`${names_1$a.default.data}, ${destructureValCxt$1(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl$1(schema, opts)).code(body));
  }
}
function destructureValCxt$1(opts) {
  return (0, codegen_1$T._)`{${names_1$a.default.instancePath}="", ${names_1$a.default.parentData}, ${names_1$a.default.parentDataProperty}, ${names_1$a.default.rootData}=${names_1$a.default.data}${opts.dynamicRef ? (0, codegen_1$T._)`, ${names_1$a.default.dynamicAnchors}={}` : codegen_1$T.nil}}={}`;
}
function destructureValCxtES5$1(gen, opts) {
  gen.if(names_1$a.default.valCxt, () => {
    gen.var(names_1$a.default.instancePath, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.instancePath}`);
    gen.var(names_1$a.default.parentData, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.parentData}`);
    gen.var(names_1$a.default.parentDataProperty, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.parentDataProperty}`);
    gen.var(names_1$a.default.rootData, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$a.default.dynamicAnchors, (0, codegen_1$T._)`${names_1$a.default.valCxt}.${names_1$a.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$a.default.instancePath, (0, codegen_1$T._)`""`);
    gen.var(names_1$a.default.parentData, (0, codegen_1$T._)`undefined`);
    gen.var(names_1$a.default.parentDataProperty, (0, codegen_1$T._)`undefined`);
    gen.var(names_1$a.default.rootData, names_1$a.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$a.default.dynamicAnchors, (0, codegen_1$T._)`{}`);
  });
}
function topSchemaObjCode$1(it) {
  const { schema, opts, gen } = it;
  validateFunction$1(it, () => {
    if (opts.$comment && schema.$comment)
      commentKeyword$1(it);
    checkNoDefault$1(it);
    gen.let(names_1$a.default.vErrors, null);
    gen.let(names_1$a.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated$1(it);
    typeAndKeywords$1(it);
    returnResults$1(it);
  });
  return;
}
function resetEvaluated$1(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", (0, codegen_1$T._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$T._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$T._)`${it.evaluated}.props`, (0, codegen_1$T._)`undefined`));
  gen.if((0, codegen_1$T._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$T._)`${it.evaluated}.items`, (0, codegen_1$T._)`undefined`));
}
function funcSourceUrl$1(schema, opts) {
  const schId = typeof schema == "object" && schema[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$T._)`/*# sourceURL=${schId} */` : codegen_1$T.nil;
}
function subschemaCode$1(it, valid2) {
  if (isSchemaObj$1(it)) {
    checkKeywords$1(it);
    if (schemaCxtHasRules$1(it)) {
      subSchemaObjCode$1(it, valid2);
      return;
    }
  }
  (0, boolSchema_1$1.boolOrEmptySchema)(it, valid2);
}
function schemaCxtHasRules$1({ schema, self: self2 }) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj$1(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode$1(it, valid2) {
  const { schema, gen, opts } = it;
  if (opts.$comment && schema.$comment)
    commentKeyword$1(it);
  updateContext$1(it);
  checkAsyncSchema$1(it);
  const errsCount = gen.const("_errs", names_1$a.default.errors);
  typeAndKeywords$1(it, errsCount);
  gen.var(valid2, (0, codegen_1$T._)`${errsCount} === ${names_1$a.default.errors}`);
}
function checkKeywords$1(it) {
  (0, util_1$N.checkUnknownRules)(it);
  checkRefsAndKeywords$1(it);
}
function typeAndKeywords$1(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords$1(it, [], false, errsCount);
  const types2 = (0, dataType_1$3.getSchemaTypes)(it.schema);
  const checkedTypes = (0, dataType_1$3.coerceAndCheckDataType)(it, types2);
  schemaKeywords$1(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords$1(it) {
  const { schema, errSchemaPath, opts, self: self2 } = it;
  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$N.schemaHasRulesButRef)(schema, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault$1(it) {
  const { schema, opts } = it;
  if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$N.checkStrictMode)(it, "default is ignored in the schema root");
  }
}
function updateContext$1(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = (0, resolve_1$5.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
}
function checkAsyncSchema$1(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword$1({ gen, schemaEnv, schema, errSchemaPath, opts }) {
  const msg = schema.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$T._)`${names_1$a.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$T.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$T._)`${names_1$a.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults$1(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError3, opts } = it;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$T._)`${names_1$a.default.errors} === 0`, () => gen.return(names_1$a.default.data), () => gen.throw((0, codegen_1$T._)`new ${ValidationError3}(${names_1$a.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$T._)`${validateName}.errors`, names_1$a.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated$1(it);
    gen.return((0, codegen_1$T._)`${names_1$a.default.errors} === 0`);
  }
}
function assignEvaluated$1({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$T.Name)
    gen.assign((0, codegen_1$T._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$T.Name)
    gen.assign((0, codegen_1$T._)`${evaluated}.items`, items2);
}
function schemaKeywords$1(it, types2, typeErrors, errsCount) {
  const { gen, schema, data, allErrors, opts, self: self2 } = it;
  const { RULES } = self2;
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$N.schemaHasRulesButRef)(schema, RULES))) {
    gen.block(() => keywordCode$1(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes$1(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1$2.shouldUseGroup)(schema, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2$1.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords$1(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2$1.reportTypeError)(it);
      }
      gen.endIf();
    } else {
      iterateKeywords$1(it, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$T._)`${names_1$a.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords$1(it, group) {
  const { gen, schema, opts: { useDefaults } } = it;
  if (useDefaults)
    (0, defaults_1$1.assignDefaults)(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1$2.shouldUseRule)(schema, rule)) {
        keywordCode$1(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes$1(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes$1(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes$1(it, types2);
  checkKeywordTypes$1(it, it.dataTypes);
}
function checkContextTypes$1(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType$1(it.dataTypes, t2)) {
      strictTypesError$1(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes$1(it, types2);
}
function checkMultipleTypes$1(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError$1(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes$1(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1$2.shouldUseRule)(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType$1(ts, t2))) {
        strictTypesError$1(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType$1(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType$1(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function narrowSchemaTypes$1(it, withTypes) {
  const ts = [];
  for (const t2 of it.dataTypes) {
    if (includesType$1(withTypes, t2))
      ts.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts.push("integer");
  }
  it.dataTypes = ts;
}
function strictTypesError$1(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$N.checkStrictMode)(it, msg, it.opts.strictTypes);
}
let KeywordCxt$1 = class KeywordCxt {
  constructor(it, def2, keyword2) {
    (0, keyword_1$1.validateKeywordUsage)(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$N.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData$1(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1$1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$a.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$T.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$T.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$T._)`${schemaCode} !== undefined && (${(0, codegen_1$T.or)(this.invalid$data(), condition)})`);
  }
  error(append2, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append2, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append2, errorPaths);
  }
  _error(append2, errorPaths) {
    (append2 ? errors_1$4.reportExtraError : errors_1$4.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1$4.reportError)(this, this.def.$dataError || errors_1$4.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1$4.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$T.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$T.nil, $dataValid = codegen_1$T.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$T.or)((0, codegen_1$T._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$T.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$T.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return (0, codegen_1$T.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$T.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$T._)`${(0, dataType_2$1.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2$1.DataType.Wrong)}`;
      }
      return codegen_1$T.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$T._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$T.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1$1.getSubschema)(this.it, appl);
    (0, subschema_1$1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1$1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode$1(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$N.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$N.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$T.Name));
      return true;
    }
  }
};
validate$1.KeywordCxt = KeywordCxt$1;
function keywordCode$1(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt$1(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1$1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1$1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1$1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData$1($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$a.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER$1.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$a.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER$1.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$T._)`${data}${(0, codegen_1$T.getProperty)((0, util_1$N.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$T._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate$1.getData = getData$1;
var validation_error$1 = {};
Object.defineProperty(validation_error$1, "__esModule", { value: true });
let ValidationError$1 = class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
};
validation_error$1.default = ValidationError$1;
var ref_error$1 = {};
Object.defineProperty(ref_error$1, "__esModule", { value: true });
const resolve_1$4 = resolve$4;
let MissingRefError$1 = class MissingRefError extends Error {
  constructor(resolver2, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$4.resolveUrl)(resolver2, baseId, ref2);
    this.missingSchema = (0, resolve_1$4.normalizeId)((0, resolve_1$4.getFullPath)(resolver2, this.missingRef));
  }
};
ref_error$1.default = MissingRefError$1;
var compile$1 = {};
Object.defineProperty(compile$1, "__esModule", { value: true });
compile$1.resolveSchema = compile$1.getCompilingSchema = compile$1.resolveRef = compile$1.compileSchema = compile$1.SchemaEnv = void 0;
const codegen_1$S = codegen$1;
const validation_error_1$1 = validation_error$1;
const names_1$9 = names$3;
const resolve_1$3 = resolve$4;
const util_1$M = util$4;
const validate_1$3 = validate$1;
let SchemaEnv$1 = class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema;
    if (typeof env2.schema == "object")
      schema = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1$3.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
    this.refs = {};
  }
};
compile$1.SchemaEnv = SchemaEnv$1;
function compileSchema$1(sch) {
  const _sch = getCompilingSchema$1.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1$3.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$S.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1$1.default,
      code: (0, codegen_1$S._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$9.default.data,
    parentData: names_1$9.default.parentData,
    parentDataProperty: names_1$9.default.parentDataProperty,
    dataNames: [names_1$9.default.data],
    dataPathArr: [codegen_1$S.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$S.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$S.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$S._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$3.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$9.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$9.default.self}`, `${names_1$9.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$S.Name ? void 0 : props,
        items: items2 instanceof codegen_1$S.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$S.Name,
        dynamicItems: items2 instanceof codegen_1$S.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$S.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile$1.compileSchema = compileSchema$1;
function resolveRef$1(root, baseId, ref2) {
  var _a;
  ref2 = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve$3.call(this, root, ref2);
  if (_sch === void 0) {
    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema)
      _sch = new SchemaEnv$1({ schema, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile$1.call(this, _sch);
}
compile$1.resolveRef = resolveRef$1;
function inlineOrCompile$1(sch) {
  if ((0, resolve_1$3.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema$1.call(this, sch);
}
function getCompilingSchema$1(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv$1(sch, schEnv))
      return sch;
  }
}
compile$1.getCompilingSchema = getCompilingSchema$1;
function sameSchemaEnv$1(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve$3(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema$1.call(this, root, ref2);
}
function resolveSchema$1(root, ref2) {
  const p = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1$3._getFullPath)(this.opts.uriResolver, p);
  let baseId = (0, resolve_1$3.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer$1.call(this, p, root);
  }
  const id2 = (0, resolve_1$3.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema$1.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer$1.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema$1.call(this, schOrRef);
  if (id2 === (0, resolve_1$3.normalizeId)(ref2)) {
    const { schema } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema[schemaId];
    if (schId)
      baseId = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv$1({ schema, schemaId, root, baseId });
  }
  return getJsonPointer$1.call(this, p, schOrRef);
}
compile$1.resolveSchema = resolveSchema$1;
const PREVENT_SCOPE_CHANGE$1 = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer$1(parsedRef, { baseId, schema, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema === "boolean")
      return;
    const partSchema = schema[(0, util_1$M.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema = partSchema;
    const schId = typeof schema === "object" && schema[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE$1.has(part) && schId) {
      baseId = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env2;
  if (typeof schema != "boolean" && schema.$ref && !(0, util_1$M.schemaHasRulesButRef)(schema, this.RULES)) {
    const $ref = (0, resolve_1$3.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
    env2 = resolveSchema$1.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv$1({ schema, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$3 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description$1 = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$3 = "object";
const required$3 = [
  "$data"
];
const properties$5 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$3 = false;
const require$$9$1 = {
  $id: $id$3,
  description: description$1,
  type: type$3,
  required: required$3,
  properties: properties$5,
  additionalProperties: additionalProperties$3
};
var uri$3 = {};
var fastUri$1 = { exports: {} };
const isUUID$1 = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
const isIPv4$1 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
function stringArrayToHexStripped(input) {
  let acc = "";
  let code2 = 0;
  let i = 0;
  for (i = 0; i < input.length; i++) {
    code2 = input[i].charCodeAt(0);
    if (code2 === 48) {
      continue;
    }
    if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
      return "";
    }
    acc += input[i];
    break;
  }
  for (i += 1; i < input.length; i++) {
    code2 = input[i].charCodeAt(0);
    if (!(code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102)) {
      return "";
    }
    acc += input[i];
  }
  return acc;
}
const nonSimpleDomain$1 = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
function consumeIsZone(buffer2) {
  buffer2.length = 0;
  return true;
}
function consumeHextets(buffer2, address, output) {
  if (buffer2.length) {
    const hex = stringArrayToHexStripped(buffer2);
    if (hex !== "") {
      address.push(hex);
    } else {
      output.error = true;
      return false;
    }
    buffer2.length = 0;
  }
  return true;
}
function getIPV6(input) {
  let tokenCount = 0;
  const output = { error: false, address: "", zone: "" };
  const address = [];
  const buffer2 = [];
  let endipv6Encountered = false;
  let endIpv6 = false;
  let consume = consumeHextets;
  for (let i = 0; i < input.length; i++) {
    const cursor = input[i];
    if (cursor === "[" || cursor === "]") {
      continue;
    }
    if (cursor === ":") {
      if (endipv6Encountered === true) {
        endIpv6 = true;
      }
      if (!consume(buffer2, address, output)) {
        break;
      }
      if (++tokenCount > 7) {
        output.error = true;
        break;
      }
      if (i > 0 && input[i - 1] === ":") {
        endipv6Encountered = true;
      }
      address.push(":");
      continue;
    } else if (cursor === "%") {
      if (!consume(buffer2, address, output)) {
        break;
      }
      consume = consumeIsZone;
    } else {
      buffer2.push(cursor);
      continue;
    }
  }
  if (buffer2.length) {
    if (consume === consumeIsZone) {
      output.zone = buffer2.join("");
    } else if (endIpv6) {
      address.push(buffer2.join(""));
    } else {
      address.push(stringArrayToHexStripped(buffer2));
    }
  }
  output.address = address.join("");
  return output;
}
function normalizeIPv6$1(host) {
  if (findToken(host, ":") < 2) {
    return { host, isIPV6: false };
  }
  const ipv6 = getIPV6(host);
  if (!ipv6.error) {
    let newHost = ipv6.address;
    let escapedHost = ipv6.address;
    if (ipv6.zone) {
      newHost += "%" + ipv6.zone;
      escapedHost += "%25" + ipv6.zone;
    }
    return { host: newHost, isIPV6: true, escapedHost };
  } else {
    return { host, isIPV6: false };
  }
}
function findToken(str, token) {
  let ind = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === token)
      ind++;
  }
  return ind;
}
function removeDotSegments$1(path2) {
  let input = path2;
  const output = [];
  let nextSlash = -1;
  let len = 0;
  while (len = input.length) {
    if (len === 1) {
      if (input === ".") {
        break;
      } else if (input === "/") {
        output.push("/");
        break;
      } else {
        output.push(input);
        break;
      }
    } else if (len === 2) {
      if (input[0] === ".") {
        if (input[1] === ".") {
          break;
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === "." || input[1] === "/") {
          output.push("/");
          break;
        }
      }
    } else if (len === 3) {
      if (input === "/..") {
        if (output.length !== 0) {
          output.pop();
        }
        output.push("/");
        break;
      }
    }
    if (input[0] === ".") {
      if (input[1] === ".") {
        if (input[2] === "/") {
          input = input.slice(3);
          continue;
        }
      } else if (input[1] === "/") {
        input = input.slice(2);
        continue;
      }
    } else if (input[0] === "/") {
      if (input[1] === ".") {
        if (input[2] === "/") {
          input = input.slice(2);
          continue;
        } else if (input[2] === ".") {
          if (input[3] === "/") {
            input = input.slice(3);
            if (output.length !== 0) {
              output.pop();
            }
            continue;
          }
        }
      }
    }
    if ((nextSlash = input.indexOf("/", 1)) === -1) {
      output.push(input);
      break;
    } else {
      output.push(input.slice(0, nextSlash));
      input = input.slice(nextSlash);
    }
  }
  return output.join("");
}
function normalizeComponentEncoding$1(component, esc) {
  const func = esc !== true ? escape : unescape;
  if (component.scheme !== void 0) {
    component.scheme = func(component.scheme);
  }
  if (component.userinfo !== void 0) {
    component.userinfo = func(component.userinfo);
  }
  if (component.host !== void 0) {
    component.host = func(component.host);
  }
  if (component.path !== void 0) {
    component.path = func(component.path);
  }
  if (component.query !== void 0) {
    component.query = func(component.query);
  }
  if (component.fragment !== void 0) {
    component.fragment = func(component.fragment);
  }
  return component;
}
function recomposeAuthority$1(component) {
  const uriTokens = [];
  if (component.userinfo !== void 0) {
    uriTokens.push(component.userinfo);
    uriTokens.push("@");
  }
  if (component.host !== void 0) {
    let host = unescape(component.host);
    if (!isIPv4$1(host)) {
      const ipV6res = normalizeIPv6$1(host);
      if (ipV6res.isIPV6 === true) {
        host = `[${ipV6res.escapedHost}]`;
      } else {
        host = component.host;
      }
    }
    uriTokens.push(host);
  }
  if (typeof component.port === "number" || typeof component.port === "string") {
    uriTokens.push(":");
    uriTokens.push(String(component.port));
  }
  return uriTokens.length ? uriTokens.join("") : void 0;
}
var utils$3 = {
  nonSimpleDomain: nonSimpleDomain$1,
  recomposeAuthority: recomposeAuthority$1,
  normalizeComponentEncoding: normalizeComponentEncoding$1,
  removeDotSegments: removeDotSegments$1,
  isIPv4: isIPv4$1,
  isUUID: isUUID$1,
  normalizeIPv6: normalizeIPv6$1,
  stringArrayToHexStripped
};
const { isUUID } = utils$3;
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
const supportedSchemeNames = (
  /** @type {const} */
  [
    "http",
    "https",
    "ws",
    "wss",
    "urn",
    "urn:uuid"
  ]
);
function isValidSchemeName(name) {
  return supportedSchemeNames.indexOf(
    /** @type {*} */
    name
  ) !== -1;
}
function wsIsSecure(wsComponent) {
  if (wsComponent.secure === true) {
    return true;
  } else if (wsComponent.secure === false) {
    return false;
  } else if (wsComponent.scheme) {
    return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
  } else {
    return false;
  }
}
function httpParse(component) {
  if (!component.host) {
    component.error = component.error || "HTTP URIs must have a host.";
  }
  return component;
}
function httpSerialize(component) {
  const secure = String(component.scheme).toLowerCase() === "https";
  if (component.port === (secure ? 443 : 80) || component.port === "") {
    component.port = void 0;
  }
  if (!component.path) {
    component.path = "/";
  }
  return component;
}
function wsParse(wsComponent) {
  wsComponent.secure = wsIsSecure(wsComponent);
  wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
  wsComponent.path = void 0;
  wsComponent.query = void 0;
  return wsComponent;
}
function wsSerialize(wsComponent) {
  if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
    wsComponent.port = void 0;
  }
  if (typeof wsComponent.secure === "boolean") {
    wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
    wsComponent.secure = void 0;
  }
  if (wsComponent.resourceName) {
    const [path2, query2] = wsComponent.resourceName.split("?");
    wsComponent.path = path2 && path2 !== "/" ? path2 : void 0;
    wsComponent.query = query2;
    wsComponent.resourceName = void 0;
  }
  wsComponent.fragment = void 0;
  return wsComponent;
}
function urnParse(urnComponent, options) {
  if (!urnComponent.path) {
    urnComponent.error = "URN can not be parsed";
    return urnComponent;
  }
  const matches = urnComponent.path.match(URN_REG);
  if (matches) {
    const scheme = options.scheme || urnComponent.scheme || "urn";
    urnComponent.nid = matches[1].toLowerCase();
    urnComponent.nss = matches[2];
    const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
    const schemeHandler = getSchemeHandler$1(urnScheme);
    urnComponent.path = void 0;
    if (schemeHandler) {
      urnComponent = schemeHandler.parse(urnComponent, options);
    }
  } else {
    urnComponent.error = urnComponent.error || "URN can not be parsed.";
  }
  return urnComponent;
}
function urnSerialize(urnComponent, options) {
  if (urnComponent.nid === void 0) {
    throw new Error("URN without nid cannot be serialized");
  }
  const scheme = options.scheme || urnComponent.scheme || "urn";
  const nid = urnComponent.nid.toLowerCase();
  const urnScheme = `${scheme}:${options.nid || nid}`;
  const schemeHandler = getSchemeHandler$1(urnScheme);
  if (schemeHandler) {
    urnComponent = schemeHandler.serialize(urnComponent, options);
  }
  const uriComponent = urnComponent;
  const nss = urnComponent.nss;
  uriComponent.path = `${nid || options.nid}:${nss}`;
  options.skipEscape = true;
  return uriComponent;
}
function urnuuidParse(urnComponent, options) {
  const uuidComponent = urnComponent;
  uuidComponent.uuid = uuidComponent.nss;
  uuidComponent.nss = void 0;
  if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
    uuidComponent.error = uuidComponent.error || "UUID is not valid.";
  }
  return uuidComponent;
}
function urnuuidSerialize(uuidComponent) {
  const urnComponent = uuidComponent;
  urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
  return urnComponent;
}
const http$2 = (
  /** @type {SchemeHandler} */
  {
    scheme: "http",
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
  }
);
const https$2 = (
  /** @type {SchemeHandler} */
  {
    scheme: "https",
    domainHost: http$2.domainHost,
    parse: httpParse,
    serialize: httpSerialize
  }
);
const ws = (
  /** @type {SchemeHandler} */
  {
    scheme: "ws",
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
  }
);
const wss = (
  /** @type {SchemeHandler} */
  {
    scheme: "wss",
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
  }
);
const urn = (
  /** @type {SchemeHandler} */
  {
    scheme: "urn",
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
  }
);
const urnuuid = (
  /** @type {SchemeHandler} */
  {
    scheme: "urn:uuid",
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
  }
);
const SCHEMES$1 = (
  /** @type {Record<SchemeName, SchemeHandler>} */
  {
    http: http$2,
    https: https$2,
    ws,
    wss,
    urn,
    "urn:uuid": urnuuid
  }
);
Object.setPrototypeOf(SCHEMES$1, null);
function getSchemeHandler$1(scheme) {
  return scheme && (SCHEMES$1[
    /** @type {SchemeName} */
    scheme
  ] || SCHEMES$1[
    /** @type {SchemeName} */
    scheme.toLowerCase()
  ]) || void 0;
}
var schemes = {
  wsIsSecure,
  SCHEMES: SCHEMES$1,
  isValidSchemeName,
  getSchemeHandler: getSchemeHandler$1
};
const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = utils$3;
const { SCHEMES, getSchemeHandler } = schemes;
function normalize(uri2, options) {
  if (typeof uri2 === "string") {
    uri2 = /** @type {T} */
    serialize(parse$7(uri2, options), options);
  } else if (typeof uri2 === "object") {
    uri2 = /** @type {T} */
    parse$7(serialize(uri2, options), options);
  }
  return uri2;
}
function resolve$2(baseURI, relativeURI, options) {
  const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
  const resolved = resolveComponent(parse$7(baseURI, schemelessOptions), parse$7(relativeURI, schemelessOptions), schemelessOptions, true);
  schemelessOptions.skipEscape = true;
  return serialize(resolved, schemelessOptions);
}
function resolveComponent(base, relative, options, skipNormalization) {
  const target = {};
  if (!skipNormalization) {
    base = parse$7(serialize(base, options), options);
    relative = parse$7(serialize(relative, options), options);
  }
  options = options || {};
  if (!options.tolerant && relative.scheme) {
    target.scheme = relative.scheme;
    target.userinfo = relative.userinfo;
    target.host = relative.host;
    target.port = relative.port;
    target.path = removeDotSegments(relative.path || "");
    target.query = relative.query;
  } else {
    if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (!relative.path) {
        target.path = base.path;
        if (relative.query !== void 0) {
          target.query = relative.query;
        } else {
          target.query = base.query;
        }
      } else {
        if (relative.path[0] === "/") {
          target.path = removeDotSegments(relative.path);
        } else {
          if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
            target.path = "/" + relative.path;
          } else if (!base.path) {
            target.path = relative.path;
          } else {
            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
          }
          target.path = removeDotSegments(target.path);
        }
        target.query = relative.query;
      }
      target.userinfo = base.userinfo;
      target.host = base.host;
      target.port = base.port;
    }
    target.scheme = base.scheme;
  }
  target.fragment = relative.fragment;
  return target;
}
function equal$5(uriA, uriB, options) {
  if (typeof uriA === "string") {
    uriA = unescape(uriA);
    uriA = serialize(normalizeComponentEncoding(parse$7(uriA, options), true), { ...options, skipEscape: true });
  } else if (typeof uriA === "object") {
    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
  }
  if (typeof uriB === "string") {
    uriB = unescape(uriB);
    uriB = serialize(normalizeComponentEncoding(parse$7(uriB, options), true), { ...options, skipEscape: true });
  } else if (typeof uriB === "object") {
    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
  }
  return uriA.toLowerCase() === uriB.toLowerCase();
}
function serialize(cmpts, opts) {
  const component = {
    host: cmpts.host,
    scheme: cmpts.scheme,
    userinfo: cmpts.userinfo,
    port: cmpts.port,
    path: cmpts.path,
    query: cmpts.query,
    nid: cmpts.nid,
    nss: cmpts.nss,
    uuid: cmpts.uuid,
    fragment: cmpts.fragment,
    reference: cmpts.reference,
    resourceName: cmpts.resourceName,
    secure: cmpts.secure,
    error: ""
  };
  const options = Object.assign({}, opts);
  const uriTokens = [];
  const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
  if (schemeHandler && schemeHandler.serialize)
    schemeHandler.serialize(component, options);
  if (component.path !== void 0) {
    if (!options.skipEscape) {
      component.path = escape(component.path);
      if (component.scheme !== void 0) {
        component.path = component.path.split("%3A").join(":");
      }
    } else {
      component.path = unescape(component.path);
    }
  }
  if (options.reference !== "suffix" && component.scheme) {
    uriTokens.push(component.scheme, ":");
  }
  const authority = recomposeAuthority(component);
  if (authority !== void 0) {
    if (options.reference !== "suffix") {
      uriTokens.push("//");
    }
    uriTokens.push(authority);
    if (component.path && component.path[0] !== "/") {
      uriTokens.push("/");
    }
  }
  if (component.path !== void 0) {
    let s = component.path;
    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
      s = removeDotSegments(s);
    }
    if (authority === void 0 && s[0] === "/" && s[1] === "/") {
      s = "/%2F" + s.slice(2);
    }
    uriTokens.push(s);
  }
  if (component.query !== void 0) {
    uriTokens.push("?", component.query);
  }
  if (component.fragment !== void 0) {
    uriTokens.push("#", component.fragment);
  }
  return uriTokens.join("");
}
const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function parse$7(uri2, opts) {
  const options = Object.assign({}, opts);
  const parsed = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  };
  let isIP = false;
  if (options.reference === "suffix") {
    if (options.scheme) {
      uri2 = options.scheme + ":" + uri2;
    } else {
      uri2 = "//" + uri2;
    }
  }
  const matches = uri2.match(URI_PARSE);
  if (matches) {
    parsed.scheme = matches[1];
    parsed.userinfo = matches[3];
    parsed.host = matches[4];
    parsed.port = parseInt(matches[5], 10);
    parsed.path = matches[6] || "";
    parsed.query = matches[7];
    parsed.fragment = matches[8];
    if (isNaN(parsed.port)) {
      parsed.port = matches[5];
    }
    if (parsed.host) {
      const ipv4result = isIPv4(parsed.host);
      if (ipv4result === false) {
        const ipv6result = normalizeIPv6(parsed.host);
        parsed.host = ipv6result.host.toLowerCase();
        isIP = ipv6result.isIPV6;
      } else {
        isIP = true;
      }
    }
    if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
      parsed.reference = "same-document";
    } else if (parsed.scheme === void 0) {
      parsed.reference = "relative";
    } else if (parsed.fragment === void 0) {
      parsed.reference = "absolute";
    } else {
      parsed.reference = "uri";
    }
    if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
      parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
    }
    const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
      if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
        try {
          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
        } catch (e) {
          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
        }
      }
    }
    if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
      if (uri2.indexOf("%") !== -1) {
        if (parsed.scheme !== void 0) {
          parsed.scheme = unescape(parsed.scheme);
        }
        if (parsed.host !== void 0) {
          parsed.host = unescape(parsed.host);
        }
      }
      if (parsed.path) {
        parsed.path = escape(unescape(parsed.path));
      }
      if (parsed.fragment) {
        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
      }
    }
    if (schemeHandler && schemeHandler.parse) {
      schemeHandler.parse(parsed, options);
    }
  } else {
    parsed.error = parsed.error || "URI can not be parsed.";
  }
  return parsed;
}
const fastUri = {
  SCHEMES,
  normalize,
  resolve: resolve$2,
  resolveComponent,
  equal: equal$5,
  serialize,
  parse: parse$7
};
fastUri$1.exports = fastUri;
fastUri$1.exports.default = fastUri;
fastUri$1.exports.fastUri = fastUri;
var fastUriExports = fastUri$1.exports;
Object.defineProperty(uri$3, "__esModule", { value: true });
const uri$2 = fastUriExports;
uri$2.code = 'require("ajv/dist/runtime/uri").default';
uri$3.default = uri$2;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
  var validate_12 = validate$1;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen$1;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error$1;
  const ref_error_12 = ref_error$1;
  const rules_12 = rules$1;
  const compile_12 = compile$1;
  const codegen_2 = codegen$1;
  const resolve_12 = resolve$4;
  const dataType_12 = dataType$1;
  const util_12 = util$4;
  const $dataRefSchema = require$$9$1;
  const uri_1 = uri$3;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id2 = schema[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_12.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema2;
      $schema2 = schema.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id2 = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  exports2.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
})(core$5);
var draft7$1 = {};
var core$4 = {};
var id$1 = {};
Object.defineProperty(id$1, "__esModule", { value: true });
const def$V = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id$1.default = def$V;
var ref$1 = {};
Object.defineProperty(ref$1, "__esModule", { value: true });
ref$1.callRef = ref$1.getValidate = void 0;
const ref_error_1$3 = ref_error$1;
const code_1$j = code$2;
const codegen_1$R = codegen$1;
const names_1$8 = names$3;
const compile_1$3 = compile$1;
const util_1$L = util$4;
const def$U = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1$3.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$3.default(it.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$3.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef$1(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef$1(cxt, (0, codegen_1$R._)`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v = getValidate$1(cxt, sch);
      callRef$1(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$R.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$R.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate$1(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$R._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref$1.getValidate = getValidate$1;
function callRef$1(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts } = it;
  const passCxt = opts.passContext ? names_1$8.default.this : codegen_1$R.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$R._)`await ${(0, code_1$j.callValidateCode)(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if((0, codegen_1$R._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$j.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = (0, codegen_1$R._)`${source2}.errors`;
    gen.assign(names_1$8.default.vErrors, (0, codegen_1$R._)`${names_1$8.default.vErrors} === null ? ${errs} : ${names_1$8.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$8.default.errors, (0, codegen_1$R._)`${names_1$8.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$L.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$R._)`${source2}.evaluated.props`);
        it.props = util_1$L.mergeEvaluated.props(gen, props, it.props, codegen_1$R.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$L.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$R._)`${source2}.evaluated.items`);
        it.items = util_1$L.mergeEvaluated.items(gen, items2, it.items, codegen_1$R.Name);
      }
    }
  }
}
ref$1.callRef = callRef$1;
ref$1.default = def$U;
Object.defineProperty(core$4, "__esModule", { value: true });
const id_1$1 = id$1;
const ref_1$1 = ref$1;
const core$3 = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1$1.default,
  ref_1$1.default
];
core$4.default = core$3;
var validation$3 = {};
var limitNumber$1 = {};
Object.defineProperty(limitNumber$1, "__esModule", { value: true });
const codegen_1$Q = codegen$1;
const ops$1 = codegen_1$Q.operators;
const KWDs$1 = {
  maximum: { okStr: "<=", ok: ops$1.LTE, fail: ops$1.GT },
  minimum: { okStr: ">=", ok: ops$1.GTE, fail: ops$1.LT },
  exclusiveMaximum: { okStr: "<", ok: ops$1.LT, fail: ops$1.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops$1.GT, fail: ops$1.LTE }
};
const error$B = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$Q.str)`must be ${KWDs$1[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$Q._)`{comparison: ${KWDs$1[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$T = {
  keyword: Object.keys(KWDs$1),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$B,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$Q._)`${data} ${KWDs$1[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber$1.default = def$T;
var multipleOf$1 = {};
Object.defineProperty(multipleOf$1, "__esModule", { value: true });
const codegen_1$P = codegen$1;
const error$A = {
  message: ({ schemaCode }) => (0, codegen_1$P.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$P._)`{multipleOf: ${schemaCode}}`
};
const def$S = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$A,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$P._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$P._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$P._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf$1.default = def$S;
var limitLength$1 = {};
var ucs2length$3 = {};
Object.defineProperty(ucs2length$3, "__esModule", { value: true });
function ucs2length$2(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$3.default = ucs2length$2;
ucs2length$2.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength$1, "__esModule", { value: true });
const codegen_1$O = codegen$1;
const util_1$K = util$4;
const ucs2length_1$1 = ucs2length$3;
const error$z = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$O.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$O._)`{limit: ${schemaCode}}`
};
const def$R = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$z,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$O.operators.GT : codegen_1$O.operators.LT;
    const len = it.opts.unicode === false ? (0, codegen_1$O._)`${data}.length` : (0, codegen_1$O._)`${(0, util_1$K.useFunc)(cxt.gen, ucs2length_1$1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$O._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength$1.default = def$R;
var pattern$1 = {};
Object.defineProperty(pattern$1, "__esModule", { value: true });
const code_1$i = code$2;
const codegen_1$N = codegen$1;
const error$y = {
  message: ({ schemaCode }) => (0, codegen_1$N.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$N._)`{pattern: ${schemaCode}}`
};
const def$Q = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$y,
  code(cxt) {
    const { data, $data, schema, schemaCode, it } = cxt;
    const u = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$N._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$i.usePattern)(cxt, schema);
    cxt.fail$data((0, codegen_1$N._)`!${regExp}.test(${data})`);
  }
};
pattern$1.default = def$Q;
var limitProperties$1 = {};
Object.defineProperty(limitProperties$1, "__esModule", { value: true });
const codegen_1$M = codegen$1;
const error$x = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$M.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$M._)`{limit: ${schemaCode}}`
};
const def$P = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$x,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$M.operators.GT : codegen_1$M.operators.LT;
    cxt.fail$data((0, codegen_1$M._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties$1.default = def$P;
var required$2 = {};
Object.defineProperty(required$2, "__esModule", { value: true });
const code_1$h = code$2;
const codegen_1$L = codegen$1;
const util_1$J = util$4;
const error$w = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$L.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$L._)`{missingProperty: ${missingProperty}}`
};
const def$O = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$w,
  code(cxt) {
    const { gen, schema, schemaCode, data, $data, it } = cxt;
    const { opts } = it;
    if (!$data && schema.length === 0)
      return;
    const useLoop = schema.length >= opts.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$J.checkStrictMode)(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$L.nil, loopAllRequired);
      } else {
        for (const prop of schema) {
          (0, code_1$h.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$h.checkMissingProp)(cxt, schema, missing));
        (0, code_1$h.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$h.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$h.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$L.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$L.nil);
    }
  }
};
required$2.default = def$O;
var limitItems$1 = {};
Object.defineProperty(limitItems$1, "__esModule", { value: true });
const codegen_1$K = codegen$1;
const error$v = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$K.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$K._)`{limit: ${schemaCode}}`
};
const def$N = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$v,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$K.operators.GT : codegen_1$K.operators.LT;
    cxt.fail$data((0, codegen_1$K._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems$1.default = def$N;
var uniqueItems$1 = {};
var equal$4 = {};
Object.defineProperty(equal$4, "__esModule", { value: true });
const equal$3 = fastDeepEqual;
equal$3.code = 'require("ajv/dist/runtime/equal").default';
equal$4.default = equal$3;
Object.defineProperty(uniqueItems$1, "__esModule", { value: true });
const dataType_1$2 = dataType$1;
const codegen_1$J = codegen$1;
const util_1$I = util$4;
const equal_1$5 = equal$4;
const error$u = {
  message: ({ params: { i, j } }) => (0, codegen_1$J.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => (0, codegen_1$J._)`{i: ${i}, j: ${j}}`
};
const def$M = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$u,
  code(cxt) {
    const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1$2.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$J._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", (0, codegen_1$J._)`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$J._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1$2.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1$2.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$J._)`{}`);
      gen.for((0, codegen_1$J._)`;${i}--;`, () => {
        gen.let(item, (0, codegen_1$J._)`${data}[${i}]`);
        gen.if(wrongType, (0, codegen_1$J._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$J._)`typeof ${item} == "string"`, (0, codegen_1$J._)`${item} += "_"`);
        gen.if((0, codegen_1$J._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, (0, codegen_1$J._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$J._)`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = (0, util_1$I.useFunc)(gen, equal_1$5.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$J._)`;${i}--;`, () => gen.for((0, codegen_1$J._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$J._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems$1.default = def$M;
var _const$1 = {};
Object.defineProperty(_const$1, "__esModule", { value: true });
const codegen_1$I = codegen$1;
const util_1$H = util$4;
const equal_1$4 = equal$4;
const error$t = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$I._)`{allowedValue: ${schemaCode}}`
};
const def$L = {
  keyword: "const",
  $data: true,
  error: error$t,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema } = cxt;
    if ($data || schema && typeof schema == "object") {
      cxt.fail$data((0, codegen_1$I._)`!${(0, util_1$H.useFunc)(gen, equal_1$4.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$I._)`${schema} !== ${data}`);
    }
  }
};
_const$1.default = def$L;
var _enum$1 = {};
Object.defineProperty(_enum$1, "__esModule", { value: true });
const codegen_1$H = codegen$1;
const util_1$G = util$4;
const equal_1$3 = equal$4;
const error$s = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$H._)`{allowedValues: ${schemaCode}}`
};
const def$K = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$s,
  code(cxt) {
    const { gen, data, $data, schema, schemaCode, it } = cxt;
    if (!$data && schema.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema.length >= it.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$G.useFunc)(gen, equal_1$3.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$H.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$H._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema[i];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$H._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$H._)`${data} === ${sch}`;
    }
  }
};
_enum$1.default = def$K;
Object.defineProperty(validation$3, "__esModule", { value: true });
const limitNumber_1$1 = limitNumber$1;
const multipleOf_1$1 = multipleOf$1;
const limitLength_1$1 = limitLength$1;
const pattern_1$1 = pattern$1;
const limitProperties_1$1 = limitProperties$1;
const required_1$1 = required$2;
const limitItems_1$1 = limitItems$1;
const uniqueItems_1$1 = uniqueItems$1;
const const_1$1 = _const$1;
const enum_1$1 = _enum$1;
const validation$2 = [
  // number
  limitNumber_1$1.default,
  multipleOf_1$1.default,
  // string
  limitLength_1$1.default,
  pattern_1$1.default,
  // object
  limitProperties_1$1.default,
  required_1$1.default,
  // array
  limitItems_1$1.default,
  uniqueItems_1$1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1$1.default,
  enum_1$1.default
];
validation$3.default = validation$2;
var applicator$1 = {};
var additionalItems$1 = {};
Object.defineProperty(additionalItems$1, "__esModule", { value: true });
additionalItems$1.validateAdditionalItems = void 0;
const codegen_1$G = codegen$1;
const util_1$F = util$4;
const error$r = {
  message: ({ params: { len } }) => (0, codegen_1$G.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$G._)`{limit: ${len}}`
};
const def$J = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$r,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$F.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems$1(cxt, items2);
  }
};
function validateAdditionalItems$1(cxt, items2) {
  const { gen, schema, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", (0, codegen_1$G._)`${data}.length`);
  if (schema === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$G._)`${len} <= ${items2.length}`);
  } else if (typeof schema == "object" && !(0, util_1$F.alwaysValidSchema)(it, schema)) {
    const valid2 = gen.var("valid", (0, codegen_1$G._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$G.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$F.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if((0, codegen_1$G.not)(valid2), () => gen.break());
    });
  }
}
additionalItems$1.validateAdditionalItems = validateAdditionalItems$1;
additionalItems$1.default = def$J;
var prefixItems$1 = {};
var items$1 = {};
Object.defineProperty(items$1, "__esModule", { value: true });
items$1.validateTuple = void 0;
const codegen_1$F = codegen$1;
const util_1$E = util$4;
const code_1$g = code$2;
const def$I = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema, it } = cxt;
    if (Array.isArray(schema))
      return validateTuple$1(cxt, "additionalItems", schema);
    it.items = true;
    if ((0, util_1$E.alwaysValidSchema)(it, schema))
      return;
    cxt.ok((0, code_1$g.validateArray)(cxt));
  }
};
function validateTuple$1(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$E.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$F._)`${data}.length`);
  schArr.forEach((sch, i) => {
    if ((0, util_1$E.alwaysValidSchema)(it, sch))
      return;
    gen.if((0, codegen_1$F._)`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$E.checkStrictMode)(it, msg, opts.strictTuples);
    }
  }
}
items$1.validateTuple = validateTuple$1;
items$1.default = def$I;
Object.defineProperty(prefixItems$1, "__esModule", { value: true });
const items_1$3 = items$1;
const def$H = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$3.validateTuple)(cxt, "items")
};
prefixItems$1.default = def$H;
var items2020$1 = {};
Object.defineProperty(items2020$1, "__esModule", { value: true });
const codegen_1$E = codegen$1;
const util_1$D = util$4;
const code_1$f = code$2;
const additionalItems_1$3 = additionalItems$1;
const error$q = {
  message: ({ params: { len } }) => (0, codegen_1$E.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$E._)`{limit: ${len}}`
};
const def$G = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$q,
  code(cxt) {
    const { schema, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if ((0, util_1$D.alwaysValidSchema)(it, schema))
      return;
    if (prefixItems2)
      (0, additionalItems_1$3.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$f.validateArray)(cxt));
  }
};
items2020$1.default = def$G;
var contains$1 = {};
Object.defineProperty(contains$1, "__esModule", { value: true });
const codegen_1$D = codegen$1;
const util_1$C = util$4;
const error$p = {
  message: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1$D.str)`must contain at least ${min2} valid item(s)` : (0, codegen_1$D.str)`must contain at least ${min2} and no more than ${max2} valid item(s)`,
  params: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1$D._)`{minContains: ${min2}}` : (0, codegen_1$D._)`{minContains: ${min2}, maxContains: ${max2}}`
};
const def$F = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$p,
  code(cxt) {
    const { gen, schema, parentSchema, data, it } = cxt;
    let min2;
    let max2;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min2 = minContains === void 0 ? 1 : minContains;
      max2 = maxContains;
    } else {
      min2 = 1;
    }
    const len = gen.const("len", (0, codegen_1$D._)`${data}.length`);
    cxt.setParams({ min: min2, max: max2 });
    if (max2 === void 0 && min2 === 0) {
      (0, util_1$C.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max2 !== void 0 && min2 > max2) {
      (0, util_1$C.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$C.alwaysValidSchema)(it, schema)) {
      let cond = (0, codegen_1$D._)`${len} >= ${min2}`;
      if (max2 !== void 0)
        cond = (0, codegen_1$D._)`${cond} && ${len} <= ${max2}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max2 === void 0 && min2 === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min2 === 0) {
      gen.let(valid2, true);
      if (max2 !== void 0)
        gen.if((0, codegen_1$D._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count2 = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count2)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$C.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count2) {
      gen.code((0, codegen_1$D._)`${count2}++`);
      if (max2 === void 0) {
        gen.if((0, codegen_1$D._)`${count2} >= ${min2}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$D._)`${count2} > ${max2}`, () => gen.assign(valid2, false).break());
        if (min2 === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$D._)`${count2} >= ${min2}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains$1.default = def$F;
var dependencies$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
  const codegen_12 = codegen$1;
  const util_12 = util$4;
  const code_12 = code$2;
  exports2.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports2.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports2.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports2.validateSchemaDeps = validateSchemaDeps;
  exports2.default = def2;
})(dependencies$1);
var propertyNames$1 = {};
Object.defineProperty(propertyNames$1, "__esModule", { value: true });
const codegen_1$C = codegen$1;
const util_1$B = util$4;
const error$o = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$C._)`{propertyName: ${params.propertyName}}`
};
const def$E = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$o,
  code(cxt) {
    const { gen, schema, data, it } = cxt;
    if ((0, util_1$B.alwaysValidSchema)(it, schema))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$C.not)(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames$1.default = def$E;
var additionalProperties$2 = {};
Object.defineProperty(additionalProperties$2, "__esModule", { value: true });
const code_1$e = code$2;
const codegen_1$B = codegen$1;
const names_1$7 = names$3;
const util_1$A = util$4;
const error$n = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$B._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$D = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$n,
  code(cxt) {
    const { gen, schema, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it;
    it.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$A.alwaysValidSchema)(it, schema))
      return;
    const props = (0, code_1$e.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$e.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$B._)`${errsCount} === ${names_1$7.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$A.schemaRefOrVal)(it, parentSchema.properties, "properties");
        definedProp = (0, code_1$e.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1$B.or)(...props.map((p) => (0, codegen_1$B._)`${key} === ${p}`));
      } else {
        definedProp = codegen_1$B.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$B.or)(definedProp, ...patProps.map((p) => (0, codegen_1$B._)`${(0, code_1$e.usePattern)(cxt, p)}.test(${key})`));
      }
      return (0, codegen_1$B.not)(definedProp);
    }
    function deleteAdditional(key) {
      gen.code((0, codegen_1$B._)`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
        deleteAdditional(key);
        return;
      }
      if (schema === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema == "object" && !(0, util_1$A.alwaysValidSchema)(it, schema)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if((0, codegen_1$B.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$B.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$A.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties$2.default = def$D;
var properties$4 = {};
Object.defineProperty(properties$4, "__esModule", { value: true });
const validate_1$2 = validate$1;
const code_1$d = code$2;
const util_1$z = util$4;
const additionalProperties_1$3 = additionalProperties$2;
const def$C = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$3.default.code(new validate_1$2.KeywordCxt(it, additionalProperties_1$3.default, "additionalProperties"));
    }
    const allProps = (0, code_1$d.allSchemaProperties)(schema);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$z.mergeEvaluated.props(gen, (0, util_1$z.toHash)(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !(0, util_1$z.alwaysValidSchema)(it, schema[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$d.propertyInData)(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$4.default = def$C;
var patternProperties$1 = {};
Object.defineProperty(patternProperties$1, "__esModule", { value: true });
const code_1$c = code$2;
const codegen_1$A = codegen$1;
const util_1$y = util$4;
const util_2$2 = util$4;
const def$B = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, data, parentSchema, it } = cxt;
    const { opts } = it;
    const patterns = (0, code_1$c.allSchemaProperties)(schema);
    const alwaysValidPatterns = patterns.filter((p) => (0, util_1$y.alwaysValidSchema)(it, schema[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$A.Name)) {
      it.props = (0, util_2$2.evaluatedPropsToName)(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$y.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if((0, codegen_1$A._)`${(0, code_1$c.usePattern)(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2$2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$A._)`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if((0, codegen_1$A.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties$1.default = def$B;
var not$1 = {};
Object.defineProperty(not$1, "__esModule", { value: true });
const util_1$x = util$4;
const def$A = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema, it } = cxt;
    if ((0, util_1$x.alwaysValidSchema)(it, schema)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not$1.default = def$A;
var anyOf$1 = {};
Object.defineProperty(anyOf$1, "__esModule", { value: true });
const code_1$b = code$2;
const def$z = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1$b.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf$1.default = def$z;
var oneOf$1 = {};
Object.defineProperty(oneOf$1, "__esModule", { value: true });
const codegen_1$z = codegen$1;
const util_1$w = util$4;
const error$m = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$z._)`{passingSchemas: ${params.passing}}`
};
const def$y = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$m,
  code(cxt) {
    const { gen, schema, parentSchema, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if ((0, util_1$w.alwaysValidSchema)(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if((0, codegen_1$z._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$z._)`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$z.Name);
        });
      });
    }
  }
};
oneOf$1.default = def$y;
var allOf$1 = {};
Object.defineProperty(allOf$1, "__esModule", { value: true });
const util_1$v = util$4;
const def$x = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema.forEach((sch, i) => {
      if ((0, util_1$v.alwaysValidSchema)(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf$1.default = def$x;
var _if$1 = {};
Object.defineProperty(_if$1, "__esModule", { value: true });
const codegen_1$y = codegen$1;
const util_1$u = util$4;
const error$l = {
  message: ({ params }) => (0, codegen_1$y.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$y._)`{failingKeyword: ${params.ifClause}}`
};
const def$w = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$l,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$u.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema$1(it, "then");
    const hasElse = hasSchema$1(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$y.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$y._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema$1(it, keyword2) {
  const schema = it.schema[keyword2];
  return schema !== void 0 && !(0, util_1$u.alwaysValidSchema)(it, schema);
}
_if$1.default = def$w;
var thenElse$1 = {};
Object.defineProperty(thenElse$1, "__esModule", { value: true });
const util_1$t = util$4;
const def$v = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      (0, util_1$t.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse$1.default = def$v;
Object.defineProperty(applicator$1, "__esModule", { value: true });
const additionalItems_1$2 = additionalItems$1;
const prefixItems_1$1 = prefixItems$1;
const items_1$2 = items$1;
const items2020_1$1 = items2020$1;
const contains_1$1 = contains$1;
const dependencies_1$1 = dependencies$1;
const propertyNames_1$1 = propertyNames$1;
const additionalProperties_1$2 = additionalProperties$2;
const properties_1$1 = properties$4;
const patternProperties_1$1 = patternProperties$1;
const not_1$1 = not$1;
const anyOf_1$1 = anyOf$1;
const oneOf_1$1 = oneOf$1;
const allOf_1$1 = allOf$1;
const if_1$1 = _if$1;
const thenElse_1$1 = thenElse$1;
function getApplicator$1(draft2020 = false) {
  const applicator2 = [
    // any
    not_1$1.default,
    anyOf_1$1.default,
    oneOf_1$1.default,
    allOf_1$1.default,
    if_1$1.default,
    thenElse_1$1.default,
    // object
    propertyNames_1$1.default,
    additionalProperties_1$2.default,
    dependencies_1$1.default,
    properties_1$1.default,
    patternProperties_1$1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1$1.default, items2020_1$1.default);
  else
    applicator2.push(additionalItems_1$2.default, items_1$2.default);
  applicator2.push(contains_1$1.default);
  return applicator2;
}
applicator$1.default = getApplicator$1;
var format$5 = {};
var format$4 = {};
Object.defineProperty(format$4, "__esModule", { value: true });
const codegen_1$x = codegen$1;
const error$k = {
  message: ({ schemaCode }) => (0, codegen_1$x.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$x._)`{format: ${schemaCode}}`
};
const def$u = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$k,
  code(cxt, ruleType) {
    const { gen, data, $data, schema, schemaCode, it } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$x._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$x._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$x._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$x._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$x._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$x.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$x.nil;
        return (0, codegen_1$x._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$x._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$x._)`${format2}(${data})`;
        const validData = (0, codegen_1$x._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$x._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$x.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$x._)`${opts.code.formats}${(0, codegen_1$x.getProperty)(schema)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$x._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$x._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$x._)`${fmtRef}(${data})` : (0, codegen_1$x._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$4.default = def$u;
Object.defineProperty(format$5, "__esModule", { value: true });
const format_1$3 = format$4;
const format$3 = [format_1$3.default];
format$5.default = format$3;
var metadata$1 = {};
Object.defineProperty(metadata$1, "__esModule", { value: true });
metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
metadata$1.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata$1.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7$1, "__esModule", { value: true });
const core_1$1 = core$4;
const validation_1$1 = validation$3;
const applicator_1$1 = applicator$1;
const format_1$2 = format$5;
const metadata_1$1 = metadata$1;
const draft7Vocabularies$1 = [
  core_1$1.default,
  validation_1$1.default,
  (0, applicator_1$1.default)(),
  format_1$2.default,
  metadata_1$1.metadataVocabulary,
  metadata_1$1.contentVocabulary
];
draft7$1.default = draft7Vocabularies$1;
var discriminator$1 = {};
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: true });
types$1.DiscrError = void 0;
var DiscrError$1;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError$1 || (types$1.DiscrError = DiscrError$1 = {}));
Object.defineProperty(discriminator$1, "__esModule", { value: true });
const codegen_1$w = codegen$1;
const types_1$1 = types$1;
const compile_1$2 = compile$1;
const ref_error_1$2 = ref_error$1;
const util_1$s = util$4;
const error$j = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1$1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$w._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def$t = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: error$j,
  code(cxt) {
    const { gen, data, schema, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1$w._)`${data}${(0, codegen_1$w.getProperty)(tagName)}`);
    gen.if((0, codegen_1$w._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1$1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1$w._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1$1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1$w.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        let sch = oneOf2[i];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1$s.schemaHasRulesButRef)(sch, it.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1$2.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
          if (sch instanceof compile_1$2.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1$2.default(it.opts.uriResolver, it.baseId, ref2);
        }
        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator$1.default = def$t;
const $schema$1 = "http://json-schema.org/draft-07/schema#";
const $id$2 = "http://json-schema.org/draft-07/schema#";
const title$1 = "Core schema meta-schema";
const definitions$1 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type$2 = [
  "object",
  "boolean"
];
const properties$3 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3$1 = {
  $schema: $schema$1,
  $id: $id$2,
  title: title$1,
  definitions: definitions$1,
  type: type$2,
  properties: properties$3,
  "default": true
};
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
  const core_12 = core$5;
  const draft7_1 = draft7$1;
  const discriminator_1 = discriminator$1;
  const draft7MetaSchema = require$$3$1;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports2.Ajv = Ajv;
  module2.exports = exports2 = Ajv;
  module2.exports.Ajv = Ajv;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = Ajv;
  var validate_12 = validate$1;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen$1;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error$1;
  Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error$1;
  Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv$1, ajv$1.exports);
var ajvExports$1 = ajv$1.exports;
var dist$h = { exports: {} };
var formats = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports2.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: uri2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
  };
  exports2.fastFormats = {
    ...exports2.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports2.formatNames = Object.keys(exports2.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri2(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  const MIN_INT32 = -(2 ** 31);
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors$1 = {};
var codegen = {};
var code$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports2._CodeOrName = _CodeOrName;
  exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports2.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports2.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports2._Code = _Code;
  exports2.nil = new _Code("");
  function _(strs, ...args2) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args2.length) {
      addCodeArg(code2, args2[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports2._ = _;
  const plus = new _Code("+");
  function str(strs, ...args2) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args2.length) {
      expr.push(plus);
      addCodeArg(expr, args2[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports2.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports2.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports2.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify(x) {
    return new _Code(safeStringify(x));
  }
  exports2.stringify = stringify;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports2.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports2.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports2.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports2.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
  exports2.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports2.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports2.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = /* @__PURE__ */ new Map();
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports2.ValueScope = ValueScope;
})(scope);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports2.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from2, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from2;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from: from2, to } = this;
      return `for(${varKind} ${name}=${from2}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args2, async2) {
      super();
      this.name = name;
      this.args = args2;
      this.async = async2;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
      return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node2, forBody) {
      this._blockNode(node2);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from2, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from2, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i) => {
          this.var(name, (0, code_12._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node2 = new Return();
      this._blockNode(node2);
      this.code(value);
      if (node2.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node2 = new Try();
      this._blockNode(node2);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node2.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node2.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args2 = code_12.nil, async2, funcBody) {
      this._blockNode(new Func(name, args2, async2));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node2) {
      this._currNode.nodes.push(node2);
      return this;
    }
    _blockNode(node2) {
      this._currNode.nodes.push(node2);
      this._nodes.push(node2);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node2) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node2;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node2) {
      const ns = this._nodes;
      ns[ns.length - 1] = node2;
    }
  }
  exports2.CodeGen = CodeGen;
  function addNames(names2, from2) {
    for (const n in from2)
      names2[n] = (names2[n] || 0) + (from2[n] || 0);
    return names2;
  }
  function addExprNames(names2, from2) {
    return from2 instanceof code_12._CodeOrName ? addNames(names2, from2.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from2) {
    for (const n in from2)
      names2[n] = (names2[n] || 0) - (from2[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_12._)`!${par(x)}`;
  }
  exports2.not = not2;
  const andCode = mappend(exports2.operators.AND);
  function and(...args2) {
    return args2.reduce(andCode);
  }
  exports2.and = and;
  const orCode = mappend(exports2.operators.OR);
  function or(...args2) {
    return args2.reduce(orCode);
  }
  exports2.or = or;
  function mappend(op) {
    return (x, y) => x === code_12.nil ? y : y === code_12.nil ? x : (0, code_12._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : (0, code_12._)`(${x})`;
  }
})(codegen);
var util$3 = {};
Object.defineProperty(util$3, "__esModule", { value: true });
util$3.checkStrictMode = util$3.getErrorPath = util$3.Type = util$3.useFunc = util$3.setEvaluated = util$3.evaluatedPropsToName = util$3.mergeEvaluated = util$3.eachItem = util$3.unescapeJsonPointer = util$3.escapeJsonPointer = util$3.escapeFragment = util$3.unescapeFragment = util$3.schemaRefOrVal = util$3.schemaHasRulesButRef = util$3.schemaHasRules = util$3.checkUnknownRules = util$3.alwaysValidSchema = util$3.toHash = void 0;
const codegen_1$v = codegen;
const code_1$a = code$1;
function toHash(arr) {
  const hash = {};
  for (const item of arr)
    hash[item] = true;
  return hash;
}
util$3.toHash = toHash;
function alwaysValidSchema(it, schema) {
  if (typeof schema == "boolean")
    return schema;
  if (Object.keys(schema).length === 0)
    return true;
  checkUnknownRules(it, schema);
  return !schemaHasRules(schema, it.self.RULES.all);
}
util$3.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema = it.schema) {
  const { opts, self: self2 } = it;
  if (!opts.strictSchema)
    return;
  if (typeof schema === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key in schema) {
    if (!rules2[key])
      checkStrictMode(it, `unknown keyword: "${key}"`);
  }
}
util$3.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules2) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (rules2[key])
      return true;
  return false;
}
util$3.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (key !== "$ref" && RULES.all[key])
      return true;
  return false;
}
util$3.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
  if (!$data) {
    if (typeof schema == "number" || typeof schema == "boolean")
      return schema;
    if (typeof schema == "string")
      return (0, codegen_1$v._)`${schema}`;
  }
  return (0, codegen_1$v._)`${topSchemaRef}${schemaPath}${(0, codegen_1$v.getProperty)(keyword2)}`;
}
util$3.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
util$3.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
util$3.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
  if (typeof str == "number")
    return `${str}`;
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util$3.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util$3.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
  if (Array.isArray(xs)) {
    for (const x of xs)
      f(x);
  } else {
    f(xs);
  }
}
util$3.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
  return (gen, from2, to, toName) => {
    const res = to === void 0 ? from2 : to instanceof codegen_1$v.Name ? (from2 instanceof codegen_1$v.Name ? mergeNames(gen, from2, to) : mergeToName(gen, from2, to), to) : from2 instanceof codegen_1$v.Name ? (mergeToName(gen, to, from2), from2) : mergeValues(from2, to);
    return toName === codegen_1$v.Name && !(res instanceof codegen_1$v.Name) ? resultToName(gen, res) : res;
  };
}
util$3.mergeEvaluated = {
  props: makeMergeEvaluated({
    mergeNames: (gen, from2, to) => gen.if((0, codegen_1$v._)`${to} !== true && ${from2} !== undefined`, () => {
      gen.if((0, codegen_1$v._)`${from2} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$v._)`${to} || {}`).code((0, codegen_1$v._)`Object.assign(${to}, ${from2})`));
    }),
    mergeToName: (gen, from2, to) => gen.if((0, codegen_1$v._)`${to} !== true`, () => {
      if (from2 === true) {
        gen.assign(to, true);
      } else {
        gen.assign(to, (0, codegen_1$v._)`${to} || {}`);
        setEvaluated(gen, to, from2);
      }
    }),
    mergeValues: (from2, to) => from2 === true ? true : { ...from2, ...to },
    resultToName: evaluatedPropsToName
  }),
  items: makeMergeEvaluated({
    mergeNames: (gen, from2, to) => gen.if((0, codegen_1$v._)`${to} !== true && ${from2} !== undefined`, () => gen.assign(to, (0, codegen_1$v._)`${from2} === true ? true : ${to} > ${from2} ? ${to} : ${from2}`)),
    mergeToName: (gen, from2, to) => gen.if((0, codegen_1$v._)`${to} !== true`, () => gen.assign(to, from2 === true ? true : (0, codegen_1$v._)`${to} > ${from2} ? ${to} : ${from2}`)),
    mergeValues: (from2, to) => from2 === true ? true : Math.max(from2, to),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName(gen, ps) {
  if (ps === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$v._)`{}`);
  if (ps !== void 0)
    setEvaluated(gen, props, ps);
  return props;
}
util$3.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
  Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$v._)`${props}${(0, codegen_1$v.getProperty)(p)}`, true));
}
util$3.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f) {
  return gen.scopeValue("func", {
    ref: f,
    code: snippets[f.code] || (snippets[f.code] = new code_1$a._Code(f.code))
  });
}
util$3.useFunc = useFunc;
var Type;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type || (util$3.Type = Type = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$v.Name) {
    const isNumber2 = dataPropType === Type.Num;
    return jsPropertySyntax ? isNumber2 ? (0, codegen_1$v._)`"[" + ${dataProp} + "]"` : (0, codegen_1$v._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1$v._)`"/" + ${dataProp}` : (0, codegen_1$v._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$v.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
util$3.getErrorPath = getErrorPath;
function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it.self.logger.warn(msg);
}
util$3.checkStrictMode = checkStrictMode;
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$u = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$u.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$u.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$u.Name("instancePath"),
  parentData: new codegen_1$u.Name("parentData"),
  parentDataProperty: new codegen_1$u.Name("parentDataProperty"),
  rootData: new codegen_1$u.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$u.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$u.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$u.Name("errors"),
  // counter of validation errors
  this: new codegen_1$u.Name("this"),
  // "globals"
  self: new codegen_1$u.Name("self"),
  scope: new codegen_1$u.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$u.Name("json"),
  jsonPos: new codegen_1$u.Name("jsonPos"),
  jsonLen: new codegen_1$u.Name("jsonLen"),
  jsonPart: new codegen_1$u.Name("jsonPart")
};
names$1.default = names;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util$3;
  const names_12 = names$1;
  exports2.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports2.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports2.reportError = reportError;
  function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports2.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports2.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports2.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors$1);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$3 = errors$1;
const codegen_1$t = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema, validateName } = it;
  if (schema === false) {
    falseSchemaError(it, false);
  } else if (typeof schema == "object" && schema.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign((0, codegen_1$t._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema } = it;
  if (schema === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  (0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
  return group.rules.some((rule) => shouldUseRule(schema, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
  var _a;
  return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
Object.defineProperty(dataType, "__esModule", { value: true });
dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
const rules_1 = rules;
const applicability_1$1 = applicability;
const errors_1$2 = errors$1;
const codegen_1$s = codegen;
const util_1$r = util$3;
var DataType;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType || (dataType.DataType = DataType = {}));
function getSchemaTypes(schema) {
  const types2 = getJSONTypes(schema.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts) {
  const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
  if (types2.every(rules_1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types2) {
  const { gen, data, opts } = it;
  const coerceTo = coerceToTypes(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData(it, types2, coerceTo);
      else
        reportTypeError(it);
    });
  }
  return checkTypes;
}
dataType.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData(it, types2, coerceTo) {
  const { gen, data, opts } = it;
  const dataType2 = gen.let("dataType", (0, codegen_1$s._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$s._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$s._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$s._)`${data}[0]`).assign(dataType2, (0, codegen_1$s._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$s._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError(it);
  gen.endIf();
  gen.if((0, codegen_1$s._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData(it, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$s._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$s._)`"" + ${data}`).elseIf((0, codegen_1$s._)`${data} === null`).assign(coerced, (0, codegen_1$s._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$s._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$s._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$s._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$s._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$s._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$s._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$s._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$s._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$s._)`[${data}]`);
    }
  }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$s._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$s._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
  const EQ = correct === DataType.Correct ? codegen_1$s.operators.EQ : codegen_1$s.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$s._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$s._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$s._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$s._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$s._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType.Correct ? cond : (0, codegen_1$s.not)(cond);
  function numCond(_cond = codegen_1$s.nil) {
    return (0, codegen_1$s.and)((0, codegen_1$s._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$s._)`isFinite(${data})` : codegen_1$s.nil);
  }
}
dataType.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$r.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$s._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$s._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$s.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$s.and)(cond, checkDataType(t2, data, strictNums, correct));
  return cond;
}
dataType.checkDataTypes = checkDataTypes;
const typeError = {
  message: ({ schema }) => `must be ${schema}`,
  params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$s._)`{type: ${schema}}` : (0, codegen_1$s._)`{type: ${schemaValue}}`
};
function reportTypeError(it) {
  const cxt = getTypeErrorContext(it);
  (0, errors_1$2.reportError)(cxt, typeError);
}
dataType.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
  const { gen, data, schema } = it;
  const schemaCode = (0, util_1$r.schemaRefOrVal)(it, schema, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema,
    params: {},
    it
  };
}
var defaults$2 = {};
Object.defineProperty(defaults$2, "__esModule", { value: true });
defaults$2.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$q = util$3;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it, i, sch.default));
  }
}
defaults$2.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$r._)`${data}${(0, codegen_1$r.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$q.checkStrictMode)(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$r._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$r._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$r._)`${childData} = ${(0, codegen_1$r.stringify)(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$p = util$3;
const names_1$5 = names$1;
const util_2$1 = util$3;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$q._)`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$q.or)(...properties2.map((prop) => (0, codegen_1$q.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$q._)`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$q._)`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return (0, codegen_1$q._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$q._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$q._)`${data}${(0, codegen_1$q.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$q.or)(cond, (0, codegen_1$q.not)(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$p.alwaysValidSchema)(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$q._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, (0, codegen_1$q.strConcat)(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args2 = (0, codegen_1$q._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? (0, codegen_1$q._)`${func}.call(${context}, ${args2})` : (0, codegen_1$q._)`${func}(${args2})`;
}
code.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$q._)`new RegExp`;
function usePattern({ gen, it: { opts } }, pattern2) {
  const u = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$q._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern2}, ${u})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$q._)`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$p.Type.Num
      }, valid2);
      gen.if((0, codegen_1$q.not)(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema))
    throw new Error("ajv implementation error");
  const alwaysValid = schema.some((sch) => (0, util_1$p.alwaysValidSchema)(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, (0, codegen_1$q._)`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$q.not)(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors$1;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$p._)`await `), (e) => gen.assign(valid2, false).if((0, codegen_1$p._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$p._)`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$p._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$p._)`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, (0, codegen_1$p._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if((0, codegen_1$p.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$p._)`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$p._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
    (0, errors_1$1.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$p.stringify)(result) });
}
function validSchemaType(schema, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$o = util$3;
function getSubschema(it, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$o._)`${it.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$o._)`${it.schemaPath}${(0, codegen_1$o.getProperty)(keyword2)}${(0, codegen_1$o.getProperty)(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${(0, util_1$o.escapeFragment)(schemaProp)}`
    };
  }
  if (schema !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it;
    const nextData = gen.let("data", (0, codegen_1$o._)`${it.data}${(0, codegen_1$o.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$o.str)`${errorPath}${(0, util_1$o.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$o._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema, "", schema);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == "object" && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$n = util$3;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema, limit2 = true) {
  if (typeof schema == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema);
  if (!limit2)
    return false;
  return countKeys(schema) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema) {
  for (const key in schema) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema) {
  let count2 = 0;
  for (const key in schema) {
    if (key === "$ref")
      return Infinity;
    count2++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema[key] == "object") {
      (0, util_1$n.eachItem)(schema[key], (sch) => count2 += countKeys(sch));
    }
    if (count2 === Infinity)
      return Infinity;
  }
  return count2;
}
function getFullPath(resolver2, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId(id2);
  const p = resolver2.parse(id2);
  return _getFullPath(resolver2, p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(resolver2, p) {
  const serialized = resolver2.serialize(p);
  return serialized.split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl$1(resolver2, baseId, id2) {
  id2 = normalizeId(id2);
  return resolver2.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl$1;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
  if (typeof schema == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId(schema[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults$2;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$m = util$3;
const errors_1 = errors$1;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$n._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
      destructureValCxtES5(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$n._)`${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
  }
}
function destructureValCxt(opts) {
  return (0, codegen_1$n._)`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$n._)`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, (0, codegen_1$n._)`""`);
    gen.var(names_1$3.default.parentData, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._)`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._)`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema, opts, gen } = it;
  validateFunction(it, () => {
    if (opts.$comment && schema.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", (0, codegen_1$n._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$n._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$n._)`${it.evaluated}.props`, (0, codegen_1$n._)`undefined`));
  gen.if((0, codegen_1$n._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$n._)`${it.evaluated}.items`, (0, codegen_1$n._)`undefined`));
}
function funcSourceUrl(schema, opts) {
  const schId = typeof schema == "object" && schema[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$n._)`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  (0, boolSchema_1.boolOrEmptySchema)(it, valid2);
}
function schemaCxtHasRules({ schema, self: self2 }) {
  if (typeof schema == "boolean")
    return !schema;
  for (const key in schema)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema, gen, opts } = it;
  if (opts.$comment && schema.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, (0, codegen_1$n._)`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  (0, util_1$m.checkUnknownRules)(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = (0, dataType_1$1.getSchemaTypes)(it.schema);
  const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema, errSchemaPath, opts, self: self2 } = it;
  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$m.schemaHasRulesButRef)(schema, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema, opts } = it;
  if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$m.checkStrictMode)(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = (0, resolve_1$2.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
  const msg = schema.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$n.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$n._)`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError3, opts } = it;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$n._)`new ${ValidationError3}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$n._)`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated(it);
    gen.return((0, codegen_1$n._)`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign((0, codegen_1$n._)`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema, data, allErrors, opts, self: self2 } = it;
  const { RULES } = self2;
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$m.schemaHasRulesButRef)(schema, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1.shouldUseGroup)(schema, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2.reportTypeError)(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$n._)`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema, opts: { useDefaults } } = it;
  if (useDefaults)
    (0, defaults_1.assignDefaults)(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1.shouldUseRule)(schema, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes(it, types2);
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function narrowSchemaTypes(it, withTypes) {
  const ts = [];
  for (const t2 of it.dataTypes) {
    if (includesType(withTypes, t2))
      ts.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts.push("integer");
  }
  it.dataTypes = ts;
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$m.checkStrictMode)(it, msg, it.opts.strictTypes);
}
class KeywordCxt2 {
  constructor(it, def2, keyword2) {
    (0, keyword_1.validateKeywordUsage)(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$m.schemaRefOrVal)(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$n.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$n._)`${schemaCode} !== undefined && (${(0, codegen_1$n.or)(this.invalid$data(), condition)})`);
  }
  error(append2, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append2, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append2, errorPaths);
  }
  _error(append2, errorPaths) {
    (append2 ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$n.or)((0, codegen_1$n._)`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return (0, codegen_1$n.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$n._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$n._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
    (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$m.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$m.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt2;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt2(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$n._)`${data}${(0, codegen_1$n.getProperty)((0, util_1$m.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$n._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError2 extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError2;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError2 extends Error {
  constructor(resolver2, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$1.resolveUrl)(resolver2, baseId, ref2);
    this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver2, this.missingRef));
  }
}
ref_error.default = MissingRefError2;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$l = util$3;
const validate_1$1 = validate;
class SchemaEnv2 {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema;
    if (typeof env2.schema == "object")
      schema = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv2;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: (0, codegen_1$m._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$m.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$m._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$1.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$m.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref2) {
  var _a;
  ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root, ref2);
  if (_sch === void 0) {
    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema)
      _sch = new SchemaEnv2({ schema, schemaId, root, baseId });
  }
  if (_sch === void 0)
    return;
  return root.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
}
function resolveSchema(root, ref2) {
  const p = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
  if (Object.keys(root.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root);
  }
  const id2 = (0, resolve_1.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === (0, resolve_1.normalizeId)(ref2)) {
    const { schema } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema[schemaId];
    if (schId)
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv2({ schema, schemaId, root, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema === "boolean")
      return;
    const partSchema = schema[(0, util_1$l.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema = partSchema;
    const schId = typeof schema === "object" && schema[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env2;
  if (typeof schema != "boolean" && schema.$ref && !(0, util_1$l.schemaHasRulesButRef)(schema, this.RULES)) {
    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
    env2 = resolveSchema.call(this, root, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv2({ schema, schemaId, root, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
var uri$1 = {};
Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = fastUriExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_12 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util$3;
  const $dataRefSchema = require$$9;
  const uri_1 = uri$1;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
      messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id2 = schema[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_12.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema2;
      $schema2 = schema.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id2 = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  exports2.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1$1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1$1 = compile;
const util_1$k = util$3;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it;
    const { root } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
      return callRootRef();
    const schOrEnv = compile_1$1.resolveRef.call(self2, root, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$1.default(it.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root });
      return callRef(cxt, (0, codegen_1$l._)`${rootName}.validate`, root, root.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$l.stringify)(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$l._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts } = it;
  const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$l._)`await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if((0, codegen_1$l._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = (0, codegen_1$l._)`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, (0, codegen_1$l._)`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, (0, codegen_1$l._)`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$k.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$l._)`${source2}.evaluated.props`);
        it.props = util_1$k.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$k.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$l._)`${source2}.evaluated.items`);
        it.items = util_1$k.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$k._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$k._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => (0, codegen_1$j.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$j._)`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$j._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$j._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$j._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$j = util$3;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$i.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? (0, codegen_1$i._)`${data}.length` : (0, codegen_1$i._)`${(0, util_1$j.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$i._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => (0, codegen_1$h.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$h._)`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema, schemaCode, it } = cxt;
    const u = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$h._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema);
    cxt.fail$data((0, codegen_1$h._)`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$g.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$g._)`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data((0, codegen_1$g._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$i = util$3;
const error$d = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$f.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$f._)`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema, schemaCode, data, $data, it } = cxt;
    const { opts } = it;
    if (!$data && schema.length === 0)
      return;
    const useLoop = schema.length >= opts.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$i.checkStrictMode)(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema) {
          (0, code_1$6.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
        (0, code_1$6.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$f.not)(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$e.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$e._)`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data((0, codegen_1$e._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$h = util$3;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i, j } }) => (0, codegen_1$d.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
  params: ({ params: { i, j } }) => (0, codegen_1$d._)`{i: ${i}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, (0, codegen_1$d._)`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i = gen.let("i", (0, codegen_1$d._)`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i, j });
      gen.assign(valid2, true);
      gen.if((0, codegen_1$d._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$d._)`{}`);
      gen.for((0, codegen_1$d._)`;${i}--;`, () => {
        gen.let(item, (0, codegen_1$d._)`${data}[${i}]`);
        gen.if(wrongType, (0, codegen_1$d._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$d._)`typeof ${item} == "string"`, (0, codegen_1$d._)`${item} += "_"`);
        gen.if((0, codegen_1$d._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, (0, codegen_1$d._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code((0, codegen_1$d._)`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j) {
      const eql = (0, util_1$h.useFunc)(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$d._)`;${i}--;`, () => gen.for((0, codegen_1$d._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$d._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$g = util$3;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$c._)`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema } = cxt;
    if ($data || schema && typeof schema == "object") {
      cxt.fail$data((0, codegen_1$c._)`!${(0, util_1$g.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$c._)`${schema} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$f = util$3;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$b._)`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema, schemaCode, it } = cxt;
    if (!$data && schema.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema.length >= it.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$f.useFunc)(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = (0, codegen_1$b.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$b._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema[i];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$b._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$b._)`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$e = util$3;
const error$8 = {
  message: ({ params: { len } }) => (0, codegen_1$a.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$a._)`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$e.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", (0, codegen_1$a._)`${data}.length`);
  if (schema === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$a._)`${len} <= ${items2.length}`);
  } else if (typeof schema == "object" && !(0, util_1$e.alwaysValidSchema)(it, schema)) {
    const valid2 = gen.var("valid", (0, codegen_1$a._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$a.not)(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$e.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if((0, codegen_1$a.not)(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$d = util$3;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema, it } = cxt;
    if (Array.isArray(schema))
      return validateTuple(cxt, "additionalItems", schema);
    it.items = true;
    if ((0, util_1$d.alwaysValidSchema)(it, schema))
      return;
    cxt.ok((0, code_1$5.validateArray)(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$d.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$9._)`${data}.length`);
  schArr.forEach((sch, i) => {
    if ((0, util_1$d.alwaysValidSchema)(it, sch))
      return;
    gen.if((0, codegen_1$9._)`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$d.checkStrictMode)(it, msg, opts.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$c = util$3;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => (0, codegen_1$8.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$8._)`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if ((0, util_1$c.alwaysValidSchema)(it, schema))
      return;
    if (prefixItems2)
      (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$4.validateArray)(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$b = util$3;
const error$6 = {
  message: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1$7.str)`must contain at least ${min2} valid item(s)` : (0, codegen_1$7.str)`must contain at least ${min2} and no more than ${max2} valid item(s)`,
  params: ({ params: { min: min2, max: max2 } }) => max2 === void 0 ? (0, codegen_1$7._)`{minContains: ${min2}}` : (0, codegen_1$7._)`{minContains: ${min2}, maxContains: ${max2}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema, parentSchema, data, it } = cxt;
    let min2;
    let max2;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min2 = minContains === void 0 ? 1 : minContains;
      max2 = maxContains;
    } else {
      min2 = 1;
    }
    const len = gen.const("len", (0, codegen_1$7._)`${data}.length`);
    cxt.setParams({ min: min2, max: max2 });
    if (max2 === void 0 && min2 === 0) {
      (0, util_1$b.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max2 !== void 0 && min2 > max2) {
      (0, util_1$b.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$b.alwaysValidSchema)(it, schema)) {
      let cond = (0, codegen_1$7._)`${len} >= ${min2}`;
      if (max2 !== void 0)
        cond = (0, codegen_1$7._)`${cond} && ${len} <= ${max2}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max2 === void 0 && min2 === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else if (min2 === 0) {
      gen.let(valid2, true);
      if (max2 !== void 0)
        gen.if((0, codegen_1$7._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid2, false);
      validateItemsWithCount();
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count2 = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count2)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$b.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count2) {
      gen.code((0, codegen_1$7._)`${count2}++`);
      if (max2 === void 0) {
        gen.if((0, codegen_1$7._)`${count2} >= ${min2}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if((0, codegen_1$7._)`${count2} > ${max2}`, () => gen.assign(valid2, false).break());
        if (min2 === 1)
          gen.assign(valid2, true);
        else
          gen.if((0, codegen_1$7._)`${count2} >= ${min2}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util$3;
  const code_12 = code;
  exports2.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports2.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports2.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
          cxt.mergeValidEvaluated(schCxt, valid2);
        },
        () => gen.var(valid2, true)
        // TODO var
      );
      cxt.ok(valid2);
    }
  }
  exports2.validateSchemaDeps = validateSchemaDeps;
  exports2.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$a = util$3;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$6._)`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema, data, it } = cxt;
    if ((0, util_1$a.alwaysValidSchema)(it, schema))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if((0, codegen_1$6.not)(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$9 = util$3;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$5._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it;
    it.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$9.alwaysValidSchema)(it, schema))
      return;
    const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$5._)`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$9.schemaRefOrVal)(it, parentSchema.properties, "properties");
        definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1$5.or)(...props.map((p) => (0, codegen_1$5._)`${key} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$5.or)(definedProp, ...patProps.map((p) => (0, codegen_1$5._)`${(0, code_1$3.usePattern)(cxt, p)}.test(${key})`));
      }
      return (0, codegen_1$5.not)(definedProp);
    }
    function deleteAdditional(key) {
      gen.code((0, codegen_1$5._)`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
        deleteAdditional(key);
        return;
      }
      if (schema === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema == "object" && !(0, util_1$9.alwaysValidSchema)(it, schema)) {
        const valid2 = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if((0, codegen_1$5.not)(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if((0, codegen_1$5.not)(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$9.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$8 = util$3;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = (0, code_1$2.allSchemaProperties)(schema);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$8.mergeEvaluated.props(gen, (0, util_1$8.toHash)(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !(0, util_1$8.alwaysValidSchema)(it, schema[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$2.propertyInData)(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$7 = util$3;
const util_2 = util$3;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema, data, parentSchema, it } = cxt;
    const { opts } = it;
    const patterns = (0, code_1$1.allSchemaProperties)(schema);
    const alwaysValidPatterns = patterns.filter((p) => (0, util_1$7.alwaysValidSchema)(it, schema[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$7.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if((0, codegen_1$4._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$4._)`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if((0, codegen_1$4.not)(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$6 = util$3;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema, it } = cxt;
    if ((0, util_1$6.alwaysValidSchema)(it, schema)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$5 = util$3;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$3._)`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema, parentSchema, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if ((0, util_1$5.alwaysValidSchema)(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if((0, codegen_1$3._)`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, (0, codegen_1$3._)`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$4 = util$3;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema.forEach((sch, i) => {
      if ((0, util_1$4.alwaysValidSchema)(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$3 = util$3;
const error$2 = {
  message: ({ params }) => (0, codegen_1$2.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$2._)`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$3.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$2.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$2._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema = it.schema[keyword2];
  return schema !== void 0 && !(0, util_1$3.alwaysValidSchema)(it, schema);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$2 = util$3;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      (0, util_1$2.checkStrictMode)(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => (0, codegen_1$1.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$1._)`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema, schemaCode, it } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$1._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$1._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$1.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$1.nil;
        return (0, codegen_1$1._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$1._)`${format2}(${data})`;
        const validData = (0, codegen_1$1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$1._)`${opts.code.formats}${(0, codegen_1$1.getProperty)(schema)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$1._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$1._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$1._)`${fmtRef}(${data})` : (0, codegen_1$1._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  (0, applicator_1.default)(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
types.DiscrError = void 0;
var DiscrError;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError || (types.DiscrError = DiscrError = {}));
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const compile_1 = compile;
const ref_error_1 = ref_error;
const util_1$1 = util$3;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
    gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        let sch = oneOf2[i];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1$1.schemaHasRulesButRef)(sch, it.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
          if (sch instanceof compile_1.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
        }
        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
const require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports2.Ajv = Ajv;
  module2.exports = exports2 = Ajv;
  module2.exports.Ajv = Ajv;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error;
  Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error;
  Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(ajv, ajv.exports);
var ajvExports = ajv.exports;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatLimitDefinition = void 0;
  const ajv_1 = ajvExports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports2.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts.code.formats ? codegen_12._`${opts.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports2.formatLimitDefinition);
    return ajv2;
  };
  exports2.default = formatLimitPlugin;
})(limit);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv2, opts, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module2.exports = exports2 = formatsPlugin;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = formatsPlugin;
})(dist$h, dist$h.exports);
var distExports = dist$h.exports;
const copyProperty = (to, from2, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from2, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from2) => {
  const fromPrototype = Object.getPrototypeOf(from2);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from2, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from2.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
const mimicFn$4 = (to, from2, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from2)) {
    copyProperty(to, from2, property, ignoreNonConfigurable);
  }
  changePrototype(to, from2);
  changeToString(to, from2, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout2;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout2 = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout2) {
      clearTimeout(timeout2);
      timeout2 = void 0;
    }
  };
  return debouncedFunction;
};
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$7 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args2) => console.error("SEMVER", ...args2) : () => {
};
var debug_1$4 = debug$7;
(function(module2, exports2) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1$4;
  exports2 = module2.exports = {};
  const re2 = exports2.re = [];
  const safeRe = exports2.safeRe = [];
  const src2 = exports2.src = [];
  const safeSrc = exports2.safeSrc = [];
  const t2 = exports2.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max2] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src2[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t2.NONNUMERICIDENTIFIER]}|${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NONNUMERICIDENTIFIER]}|${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src2[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src2[t2.COERCEPLAIN] + `(?:${src2[t2.PRERELEASE]})?(?:${src2[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t2.COERCE], true);
  createToken("COERCERTLFULL", src2[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  if (typeof a === "number" && typeof b === "number") {
    return a === b ? 0 : a < b ? -1 : 1;
  }
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$6 = debug_1$4;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version, options) {
    options = parseOptions(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug$6("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$6("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.major < other.major) {
      return -1;
    }
    if (this.major > other.major) {
      return 1;
    }
    if (this.minor < other.minor) {
      return -1;
    }
    if (this.minor > other.minor) {
      return 1;
    }
    if (this.patch < other.patch) {
      return -1;
    }
    if (this.patch > other.patch) {
      return 1;
    }
    return 0;
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug$6("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug$6("build compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    if (release.startsWith("pre")) {
      if (!identifier && identifierBase === false) {
        throw new Error("invalid increment argument: identifier is empty");
      }
      if (identifier) {
        const match = `-${identifier}`.match(this.options.loose ? re$1[t$1.PRERELEASELOOSE] : re$1[t$1.PRERELEASE]);
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`);
        }
      }
    }
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "release":
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`);
        }
        this.prerelease.length = 0;
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$1 = SemVer$d;
const SemVer$c = semver$1;
const parse$6 = (version, options, throwErrors = false) => {
  if (version instanceof SemVer$c) {
    return version;
  }
  try {
    return new SemVer$c(version, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version, options) => {
  const v = parse$5(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$2 = (version, options) => {
  const s = parse$4(version.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$2;
const SemVer$b = semver$1;
const inc$1 = (version, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version instanceof SemVer$b ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return "minor";
      }
      return "patch";
    }
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$1;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$1;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$1;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$2 = parse_1;
const prerelease$1 = (version, options) => {
  const parsed = parse$2(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$1;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$1;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$1;
const parse$1 = parse_1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version, options) => {
  if (version instanceof SemVer$5) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$1(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
};
var coerce_1 = coerce$1;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.map.get(key);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key);
      this.map.set(key, value);
      return value;
    }
  }
  delete(key) {
    return this.map.delete(key);
  }
  set(key, value) {
    const deleted = this.delete(key);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key, value);
    }
    return this;
  }
}
var lrucache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first2 = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first2];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache2.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lrucache;
  const cache2 = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1$4;
  const SemVer3 = semver$1;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    comp = comp.replace(re2[t2.BUILD], "");
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from2 = "";
    } else if (isX(fm)) {
      from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from2 = `>=${from2}`;
    } else {
      from2 = `>=${from2}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from2} ${to}`.trim();
  };
  const testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug2(set[i].semver);
        if (set[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY2 || version === ANY2) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1$4;
  const SemVer3 = semver$1;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$1;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max2 || maxSV.compare(v) === -1) {
        max2 = v;
        maxSV = new SemVer$4(max2, options);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$1;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min2 || minSV.compare(v) === 1) {
        min2 = v;
        minSV = new SemVer$3(min2, options);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$1;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$1;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version, range2, hilo, options) => {
  version = new SemVer$1(version, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version, range2, options) => outside$2(version, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version, range2, options) => outside$1(version, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let first2 = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version of v) {
    const included = satisfies$2(version, range2, options);
    if (included) {
      prev = version;
      if (!first2) {
        first2 = version;
      }
    } else {
      if (prev) {
        set.push([first2, prev]);
      }
      prev = null;
      first2 = null;
    }
  }
  if (first2) {
    set.push([first2, null]);
  }
  const ranges = [];
  for (const [min2, max2] of set) {
    if (min2 === max2) {
      ranges.push(min2);
    } else if (!max2 && min2 === v[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min2}`);
    } else if (min2 === v[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min2} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants = constants$1;
const SemVer2 = semver$1;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean$1 = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse,
  valid,
  clean: clean$1,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from2) => {
  for (const prop of Reflect.ownKeys(from2)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from2, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
var mimicFnExports = mimicFn$2.exports;
const mimicFn = mimicFnExports;
const calledFunctions = /* @__PURE__ */ new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
var onetimeExports = onetime$1.exports;
(function(module2, exports2) {
  var __classPrivateFieldSet2 = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state2, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state2.set(receiver, value), value;
  };
  var __classPrivateFieldGet2 = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state2, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports2, "__esModule", { value: true });
  const util_12 = require$$1$1;
  const fs2 = require$$1$3;
  const path2 = require$$0$6;
  const crypto2 = require$$0$5;
  const assert2 = require$$4$2;
  const events_1 = require$$0$8;
  const dotProp$1 = dotProp;
  const pkgUp2 = pkgUpExports;
  const envPaths2 = envPathsExports;
  const atomically = dist$i;
  const ajv_1 = ajvExports$1;
  const ajv_formats_1 = distExports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetimeExports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return /* @__PURE__ */ Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module2.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = /* @__PURE__ */ new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = {
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true,
        configFileMode: 438,
        ...partialOptions
      };
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp2.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet2(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        (0, ajv_formats_1.default)(ajv2);
        const schema = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet2(this, _Conf_validator, ajv2.compile(schema), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet2(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet2(this, _Conf_defaultValues, {
          ...__classPrivateFieldGet2(this, _Conf_defaultValues, "f"),
          ...options.defaults
        }, "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_1.EventEmitter();
      __classPrivateFieldSet2(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store);
      try {
        assert2.deepEqual(fileStore, store);
      } catch (_b2) {
        this.store = store;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet2(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store } = this;
      return key in store ? store[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store } = this;
      const set = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet2(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store, key2, value2);
        } else {
          store[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set(key2, value2);
        }
      } else {
        set(key, value);
      }
      this.store = store;
    }
    /**
    	    Check if an item exists.
    
    	    @param key - The key of the item to check.
    	    */
    has(key) {
      if (__classPrivateFieldGet2(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    /**
    	    Reset items to their default values, as defined by the `defaults` or `schema` option.
    
    	    @see `clear()` to reset all items.
    
    	    @param keys - The keys of the items to reset.
    	    */
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet2(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet2(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    /**
    	    Delete an item.
    
    	    @param key - The key of the item to delete.
    	    */
    delete(key) {
      const { store } = this;
      if (__classPrivateFieldGet2(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store, key);
      } else {
        delete store[key];
      }
      this.store = store;
    }
    /**
    	    Delete all items.
    
    	    This resets known items to their default values, if defined by the `defaults` or `schema` option.
    	    */
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet2(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    /**
    	    Watches the given `key`, calling `callback` on any changes.
    
    	    @param key - The key wo watch.
    	    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
    	    @returns A function, that when called, will unsubscribe.
    	    */
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    /**
    	    Watches the whole config object, calling `callback` on any changes.
    
    	    @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
    	    @returns A function, that when called, will unsubscribe.
    	    */
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet2(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if ((error2 === null || error2 === void 0 ? void 0 : error2.code) === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet2(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet2(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet2(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto2.pbkdf2Sync(__classPrivateFieldGet2(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto2.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto2.createDecipher(encryptionAlgorithm, __classPrivateFieldGet2(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if ((0, util_12.isDeepStrictEqual)(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet2(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet2(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet2(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet2(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet2(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto2.randomBytes(16);
        const password = crypto2.pbkdf2Sync(__classPrivateFieldGet2(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto2.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      if (process.env.SNAP) {
        fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet2(this, _Conf_options, "f").configFileMode });
      } else {
        try {
          atomically.writeFileSync(this.path, data, { mode: __classPrivateFieldGet2(this, _Conf_options, "f").configFileMode });
        } catch (error2) {
          if ((error2 === null || error2 === void 0 ? void 0 : error2.code) === "EXDEV") {
            fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet2(this, _Conf_options, "f").configFileMode });
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate, beforeEachMigration) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = { ...this.store };
      for (const version of newerVersions) {
        try {
          if (beforeEachMigration) {
            beforeEachMigration(this, {
              fromVersion: previousMigratedVersion,
              toVersion: version,
              finalVersion: versionToMigrate,
              versions: newerVersions
            });
          }
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = { ...this.store };
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet2(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver$12.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store } = this;
      dotProp$1.set(store, key, value);
      this.store = store;
    }
  }
  exports2.default = Conf2;
  module2.exports = Conf2;
  module2.exports.default = Conf2;
})(source, source.exports);
var sourceExports = source.exports;
const path$1 = require$$0$6;
const { app, ipcMain, ipcRenderer, shell } = require$$1$5;
const Conf = sourceExports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = {
      name: "config",
      ...options
    };
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path$1.isAbsolute(options.cwd) ? options.cwd : path$1.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  async openInEditor() {
    const error2 = await shell.openPath(this.path);
    if (error2) {
      throw new Error(error2);
    }
  }
}
var electronStore = ElectronStore;
const Store = /* @__PURE__ */ getDefaultExportFromCjs(electronStore);
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators2, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i = decorators2.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators2[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
let ConfigService = class {
  constructor() {
    this.store = new Store({
      defaults: {
        serial: {
          port: "",
          baudRate: 9600,
          dataBits: 8,
          stopBits: 1,
          parity: "none"
        },
        http: {
          url: "http://example.com/api/v1/data"
        }
      }
    });
  }
  getConfig() {
    return this.store.store;
  }
  setConfig(config2) {
    this.store.store = config2;
  }
  getSerialConfig() {
    return this.store.get("serial");
  }
  getHttpConfig() {
    return this.store.get("http");
  }
  setSerialConfig(config2) {
    this.store.set("serial", config2);
  }
  setHttpConfig(config2) {
    this.store.set("http", config2);
  }
};
ConfigService = __decorateClass$3([
  commonExports.Injectable()
], ConfigService);
var dist$g = {};
var dist$f = {};
Object.defineProperty(dist$f, "__esModule", { value: true });
dist$f.ByteLengthParser = void 0;
const stream_1$d = require$$0$4;
class ByteLengthParser extends stream_1$d.Transform {
  length;
  position;
  buffer;
  constructor(options) {
    super(options);
    if (typeof options.length !== "number") {
      throw new TypeError('"length" is not a number');
    }
    if (options.length < 1) {
      throw new TypeError('"length" is not greater than 0');
    }
    this.length = options.length;
    this.position = 0;
    this.buffer = Buffer.alloc(this.length);
  }
  _transform(chunk, _encoding, cb) {
    let cursor = 0;
    while (cursor < chunk.length) {
      this.buffer[this.position] = chunk[cursor];
      cursor++;
      this.position++;
      if (this.position === this.length) {
        this.push(this.buffer);
        this.buffer = Buffer.alloc(this.length);
        this.position = 0;
      }
    }
    cb();
  }
  _flush(cb) {
    this.push(this.buffer.slice(0, this.position));
    this.buffer = Buffer.alloc(this.length);
    cb();
  }
}
dist$f.ByteLengthParser = ByteLengthParser;
var dist$e = {};
Object.defineProperty(dist$e, "__esModule", { value: true });
dist$e.CCTalkParser = void 0;
const stream_1$c = require$$0$4;
class CCTalkParser extends stream_1$c.Transform {
  array;
  cursor;
  lastByteFetchTime;
  maxDelayBetweenBytesMs;
  constructor(maxDelayBetweenBytesMs = 50) {
    super();
    this.array = [];
    this.cursor = 0;
    this.lastByteFetchTime = 0;
    this.maxDelayBetweenBytesMs = maxDelayBetweenBytesMs;
  }
  _transform(buffer2, encoding2, cb) {
    if (this.maxDelayBetweenBytesMs > 0) {
      const now = Date.now();
      if (now - this.lastByteFetchTime > this.maxDelayBetweenBytesMs) {
        this.array = [];
        this.cursor = 0;
      }
      this.lastByteFetchTime = now;
    }
    this.cursor += buffer2.length;
    Array.from(buffer2).map((byte) => this.array.push(byte));
    while (this.cursor > 1 && this.cursor >= this.array[1] + 5) {
      const FullMsgLength = this.array[1] + 5;
      const frame = Buffer.from(this.array.slice(0, FullMsgLength));
      this.array = this.array.slice(frame.length, this.array.length);
      this.cursor -= FullMsgLength;
      this.push(frame);
    }
    cb();
  }
}
dist$e.CCTalkParser = CCTalkParser;
var dist$d = {};
Object.defineProperty(dist$d, "__esModule", { value: true });
dist$d.DelimiterParser = void 0;
const stream_1$b = require$$0$4;
let DelimiterParser$1 = class DelimiterParser extends stream_1$b.Transform {
  includeDelimiter;
  delimiter;
  buffer;
  constructor({ delimiter, includeDelimiter = false, ...options }) {
    super(options);
    if (delimiter === void 0) {
      throw new TypeError('"delimiter" is not a bufferable object');
    }
    if (delimiter.length === 0) {
      throw new TypeError('"delimiter" has a 0 or undefined length');
    }
    this.includeDelimiter = includeDelimiter;
    this.delimiter = Buffer.from(delimiter);
    this.buffer = Buffer.alloc(0);
  }
  _transform(chunk, encoding2, cb) {
    let data = Buffer.concat([this.buffer, chunk]);
    let position;
    while ((position = data.indexOf(this.delimiter)) !== -1) {
      this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));
      data = data.slice(position + this.delimiter.length);
    }
    this.buffer = data;
    cb();
  }
  _flush(cb) {
    this.push(this.buffer);
    this.buffer = Buffer.alloc(0);
    cb();
  }
};
dist$d.DelimiterParser = DelimiterParser$1;
var dist$c = {};
Object.defineProperty(dist$c, "__esModule", { value: true });
dist$c.InterByteTimeoutParser = void 0;
const stream_1$a = require$$0$4;
class InterByteTimeoutParser extends stream_1$a.Transform {
  maxBufferSize;
  currentPacket;
  interval;
  intervalID;
  constructor({ maxBufferSize = 65536, interval: interval2, ...transformOptions }) {
    super(transformOptions);
    if (!interval2) {
      throw new TypeError('"interval" is required');
    }
    if (typeof interval2 !== "number" || Number.isNaN(interval2)) {
      throw new TypeError('"interval" is not a number');
    }
    if (interval2 < 1) {
      throw new TypeError('"interval" is not greater than 0');
    }
    if (typeof maxBufferSize !== "number" || Number.isNaN(maxBufferSize)) {
      throw new TypeError('"maxBufferSize" is not a number');
    }
    if (maxBufferSize < 1) {
      throw new TypeError('"maxBufferSize" is not greater than 0');
    }
    this.maxBufferSize = maxBufferSize;
    this.currentPacket = [];
    this.interval = interval2;
  }
  _transform(chunk, encoding2, cb) {
    if (this.intervalID) {
      clearTimeout(this.intervalID);
    }
    for (let offset = 0; offset < chunk.length; offset++) {
      this.currentPacket.push(chunk[offset]);
      if (this.currentPacket.length >= this.maxBufferSize) {
        this.emitPacket();
      }
    }
    this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);
    cb();
  }
  emitPacket() {
    if (this.intervalID) {
      clearTimeout(this.intervalID);
    }
    if (this.currentPacket.length > 0) {
      this.push(Buffer.from(this.currentPacket));
    }
    this.currentPacket = [];
  }
  _flush(cb) {
    this.emitPacket();
    cb();
  }
}
dist$c.InterByteTimeoutParser = InterByteTimeoutParser;
var dist$b = {};
Object.defineProperty(dist$b, "__esModule", { value: true });
dist$b.PacketLengthParser = void 0;
const stream_1$9 = require$$0$4;
class PacketLengthParser extends stream_1$9.Transform {
  buffer;
  start;
  opts;
  constructor(options = {}) {
    super(options);
    const { delimiter = 170, packetOverhead = 2, lengthBytes = 1, lengthOffset = 1, maxLen = 255 } = options;
    this.opts = {
      delimiter,
      packetOverhead,
      lengthBytes,
      lengthOffset,
      maxLen
    };
    this.buffer = Buffer.alloc(0);
    this.start = false;
  }
  _transform(chunk, encoding2, cb) {
    for (let ndx = 0; ndx < chunk.length; ndx++) {
      const byte = chunk[ndx];
      if (byte === this.opts.delimiter) {
        this.start = true;
      }
      if (true === this.start) {
        this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);
        if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {
          const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);
          if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {
            this.push(this.buffer);
            this.buffer = Buffer.alloc(0);
            this.start = false;
          }
        }
      }
    }
    cb();
  }
  _flush(cb) {
    this.push(this.buffer);
    this.buffer = Buffer.alloc(0);
    cb();
  }
}
dist$b.PacketLengthParser = PacketLengthParser;
var dist$a = {};
Object.defineProperty(dist$a, "__esModule", { value: true });
dist$a.ReadlineParser = void 0;
const parser_delimiter_1$1 = dist$d;
let ReadlineParser$1 = class ReadlineParser extends parser_delimiter_1$1.DelimiterParser {
  constructor(options) {
    const opts = {
      delimiter: Buffer.from("\n", "utf8"),
      encoding: "utf8",
      ...options
    };
    if (typeof opts.delimiter === "string") {
      opts.delimiter = Buffer.from(opts.delimiter, opts.encoding);
    }
    super(opts);
  }
};
dist$a.ReadlineParser = ReadlineParser$1;
var dist$9 = {};
Object.defineProperty(dist$9, "__esModule", { value: true });
dist$9.ReadyParser = void 0;
const stream_1$8 = require$$0$4;
class ReadyParser extends stream_1$8.Transform {
  delimiter;
  readOffset;
  ready;
  constructor({ delimiter, ...options }) {
    if (delimiter === void 0) {
      throw new TypeError('"delimiter" is not a bufferable object');
    }
    if (delimiter.length === 0) {
      throw new TypeError('"delimiter" has a 0 or undefined length');
    }
    super(options);
    this.delimiter = Buffer.from(delimiter);
    this.readOffset = 0;
    this.ready = false;
  }
  _transform(chunk, encoding2, cb) {
    if (this.ready) {
      this.push(chunk);
      return cb();
    }
    const delimiter = this.delimiter;
    let chunkOffset = 0;
    while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {
      if (delimiter[this.readOffset] === chunk[chunkOffset]) {
        this.readOffset++;
      } else {
        this.readOffset = 0;
      }
      chunkOffset++;
    }
    if (this.readOffset === delimiter.length) {
      this.ready = true;
      this.emit("ready");
      const chunkRest = chunk.slice(chunkOffset);
      if (chunkRest.length > 0) {
        this.push(chunkRest);
      }
    }
    cb();
  }
}
dist$9.ReadyParser = ReadyParser;
var dist$8 = {};
Object.defineProperty(dist$8, "__esModule", { value: true });
dist$8.RegexParser = void 0;
const stream_1$7 = require$$0$4;
class RegexParser extends stream_1$7.Transform {
  regex;
  data;
  constructor({ regex, ...options }) {
    const opts = {
      encoding: "utf8",
      ...options
    };
    if (regex === void 0) {
      throw new TypeError('"options.regex" must be a regular expression pattern or object');
    }
    if (!(regex instanceof RegExp)) {
      regex = new RegExp(regex.toString());
    }
    super(opts);
    this.regex = regex;
    this.data = "";
  }
  _transform(chunk, encoding2, cb) {
    const data = this.data + chunk;
    const parts = data.split(this.regex);
    this.data = parts.pop() || "";
    parts.forEach((part) => {
      this.push(part);
    });
    cb();
  }
  _flush(cb) {
    this.push(this.data);
    this.data = "";
    cb();
  }
}
dist$8.RegexParser = RegexParser;
var dist$7 = {};
var decoder = {};
Object.defineProperty(decoder, "__esModule", { value: true });
decoder.SlipDecoder = void 0;
const stream_1$6 = require$$0$4;
class SlipDecoder extends stream_1$6.Transform {
  opts;
  buffer;
  escape;
  start;
  constructor(options = {}) {
    super(options);
    const { START, ESC = 219, END = 192, ESC_START, ESC_END = 220, ESC_ESC = 221 } = options;
    this.opts = {
      START,
      ESC,
      END,
      ESC_START,
      ESC_END,
      ESC_ESC
    };
    this.buffer = Buffer.alloc(0);
    this.escape = false;
    this.start = false;
  }
  _transform(chunk, encoding2, cb) {
    for (let ndx = 0; ndx < chunk.length; ndx++) {
      let byte = chunk[ndx];
      if (byte === this.opts.START) {
        this.start = true;
        continue;
      } else if (void 0 == this.opts.START) {
        this.start = true;
      }
      if (this.escape) {
        if (byte === this.opts.ESC_START && this.opts.START) {
          byte = this.opts.START;
        } else if (byte === this.opts.ESC_ESC) {
          byte = this.opts.ESC;
        } else if (byte === this.opts.ESC_END) {
          byte = this.opts.END;
        } else {
          this.escape = false;
          this.push(this.buffer);
          this.buffer = Buffer.alloc(0);
        }
      } else {
        if (byte === this.opts.ESC) {
          this.escape = true;
          continue;
        }
        if (byte === this.opts.END) {
          this.push(this.buffer);
          this.buffer = Buffer.alloc(0);
          this.escape = false;
          this.start = false;
          continue;
        }
      }
      this.escape = false;
      if (this.start) {
        this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);
      }
    }
    cb();
  }
  _flush(cb) {
    this.push(this.buffer);
    this.buffer = Buffer.alloc(0);
    cb();
  }
}
decoder.SlipDecoder = SlipDecoder;
var encoder = {};
Object.defineProperty(encoder, "__esModule", { value: true });
encoder.SlipEncoder = void 0;
const stream_1$5 = require$$0$4;
class SlipEncoder extends stream_1$5.Transform {
  opts;
  constructor(options = {}) {
    super(options);
    const { START, ESC = 219, END = 192, ESC_START, ESC_END = 220, ESC_ESC = 221, bluetoothQuirk = false } = options;
    this.opts = {
      START,
      ESC,
      END,
      ESC_START,
      ESC_END,
      ESC_ESC,
      bluetoothQuirk
    };
  }
  _transform(chunk, encoding2, cb) {
    const chunkLength = chunk.length;
    if (this.opts.bluetoothQuirk && chunkLength === 0) {
      return cb();
    }
    const encoded = Buffer.alloc(chunkLength * 2 + 2);
    let j = 0;
    if (this.opts.bluetoothQuirk == true) {
      encoded[j++] = this.opts.END;
    }
    if (this.opts.START !== void 0) {
      encoded[j++] = this.opts.START;
    }
    for (let i = 0; i < chunkLength; i++) {
      let byte = chunk[i];
      if (byte === this.opts.START && this.opts.ESC_START) {
        encoded[j++] = this.opts.ESC;
        byte = this.opts.ESC_START;
      } else if (byte === this.opts.END) {
        encoded[j++] = this.opts.ESC;
        byte = this.opts.ESC_END;
      } else if (byte === this.opts.ESC) {
        encoded[j++] = this.opts.ESC;
        byte = this.opts.ESC_ESC;
      }
      encoded[j++] = byte;
    }
    encoded[j++] = this.opts.END;
    cb(null, encoded.slice(0, j));
  }
}
encoder.SlipEncoder = SlipEncoder;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar2(decoder, exports2);
  __exportStar2(encoder, exports2);
})(dist$7);
var dist$6 = {};
var utils$2 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.convertHeaderBufferToObj = exports2.HEADER_LENGTH = void 0;
  exports2.HEADER_LENGTH = 6;
  const toOctetStr = (num) => {
    let str = Number(num).toString(2);
    while (str.length < 8) {
      str = `0${str}`;
    }
    return str;
  };
  const convertHeaderBufferToObj = (buf) => {
    const headerStr = Array.from(buf.slice(0, exports2.HEADER_LENGTH)).reduce((accum, curr) => `${accum}${toOctetStr(curr)}`, "");
    const isVersion1 = headerStr.slice(0, 3) === "000";
    const versionNumber = isVersion1 ? 1 : "UNKNOWN_VERSION";
    const type2 = Number(headerStr[3]);
    const secondaryHeader = Number(headerStr[4]);
    const apid = parseInt(headerStr.slice(5, 16), 2);
    const sequenceFlags = parseInt(headerStr.slice(16, 18), 2);
    const packetName = parseInt(headerStr.slice(18, 32), 2);
    const dataLength = parseInt(headerStr.slice(-16), 2) + 1;
    return {
      versionNumber,
      identification: {
        apid,
        secondaryHeader,
        type: type2
      },
      sequenceControl: {
        packetName,
        sequenceFlags
      },
      dataLength
    };
  };
  exports2.convertHeaderBufferToObj = convertHeaderBufferToObj;
})(utils$2);
Object.defineProperty(dist$6, "__esModule", { value: true });
dist$6.SpacePacketParser = void 0;
const stream_1$4 = require$$0$4;
const utils_1 = utils$2;
class SpacePacketParser extends stream_1$4.Transform {
  timeCodeFieldLength;
  ancillaryDataFieldLength;
  dataBuffer;
  headerBuffer;
  dataLength;
  expectingHeader;
  dataSlice;
  header;
  /**
   * A Transform stream that accepts a stream of octet data and emits object representations of
   * CCSDS Space Packets once a packet has been completely received.
   * @param {Object} [options] Configuration options for the stream
   * @param {Number} options.timeCodeFieldLength The length of the time code field within the data
   * @param {Number} options.ancillaryDataFieldLength The length of the ancillary data field within the data
   */
  constructor(options = {}) {
    super({ ...options, objectMode: true });
    this.timeCodeFieldLength = options.timeCodeFieldLength || 0;
    this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;
    this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;
    this.dataBuffer = Buffer.alloc(0);
    this.headerBuffer = Buffer.alloc(0);
    this.dataLength = 0;
    this.expectingHeader = true;
  }
  /**
   * Bundle the header, secondary header if present, and the data into a JavaScript object to emit.
   * If more data has been received past the current packet, begin the process of parsing the next
   * packet(s).
   */
  pushCompletedPacket() {
    if (!this.header) {
      throw new Error("Missing header");
    }
    const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));
    const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));
    const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));
    const completedPacket = {
      header: { ...this.header },
      data: data.toString()
    };
    if (timeCode.length > 0 || ancillaryData.length > 0) {
      completedPacket.secondaryHeader = {};
      if (timeCode.length) {
        completedPacket.secondaryHeader.timeCode = timeCode.toString();
      }
      if (ancillaryData.length) {
        completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();
      }
    }
    this.push(completedPacket);
    const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));
    if (nextChunk.length >= utils_1.HEADER_LENGTH) {
      this.extractHeader(nextChunk);
    } else {
      this.headerBuffer = nextChunk;
      this.dataBuffer = Buffer.alloc(0);
      this.expectingHeader = true;
      this.dataLength = 0;
      this.header = void 0;
    }
  }
  /**
   * Build the Stream's headerBuffer property from the received Buffer chunk; extract data from it
   * if it's complete. If there's more to the chunk than just the header, initiate handling the
   * packet data.
   * @param chunk -  Build the Stream's headerBuffer property from
   */
  extractHeader(chunk) {
    const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);
    const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);
    if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {
      this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);
      this.dataLength = this.header.dataLength;
      this.headerBuffer = Buffer.alloc(0);
      this.expectingHeader = false;
    } else {
      this.headerBuffer = headerAsBuffer;
    }
    if (startOfDataBuffer.length > 0) {
      this.dataBuffer = Buffer.from(startOfDataBuffer);
      if (this.dataBuffer.length >= this.dataLength) {
        this.pushCompletedPacket();
      }
    }
  }
  _transform(chunk, encoding2, cb) {
    if (this.expectingHeader) {
      this.extractHeader(chunk);
    } else {
      this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);
      if (this.dataBuffer.length >= this.dataLength) {
        this.pushCompletedPacket();
      }
    }
    cb();
  }
  _flush(cb) {
    const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);
    const remainingArray = Array.from(remaining);
    this.push(remainingArray);
    cb();
  }
}
dist$6.SpacePacketParser = SpacePacketParser;
var serialportMock = {};
var dist$5 = {};
var src$2 = { exports: {} };
var browser$2 = { exports: {} };
var ms$2;
var hasRequiredMs$2;
function requireMs$2() {
  if (hasRequiredMs$2)
    return ms$2;
  hasRequiredMs$2 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$2 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$2;
}
var common$2;
var hasRequiredCommon$2;
function requireCommon$2() {
  if (hasRequiredCommon$2)
    return common$2;
  hasRequiredCommon$2 = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$2();
    createDebug.destroy = destroy2;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args2) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$2 = setup;
  return common$2;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$2.exports;
  hasRequiredBrowser$2 = 1;
  (function(module2, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = requireCommon$2()(exports2);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser$2, browser$2.exports);
  return browser$2.exports;
}
var node$2 = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag)
    return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor)
    return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$1$2;
  const tty = require$$0$7;
  const hasFlag2 = requireHasFlag();
  const { env: env2 } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env2.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env2.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign3) => sign3 in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode$2;
function requireNode$2() {
  if (hasRequiredNode$2)
    return node$2.exports;
  hasRequiredNode$2 = 1;
  (function(module2, exports2) {
    const tty = require$$0$7;
    const util2 = require$$1$1;
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args2) {
      return process.stderr.write(util2.format(...args2) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = requireCommon$2()(exports2);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$2, node$2.exports);
  return node$2.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src$2.exports = requireBrowser$2();
} else {
  src$2.exports = requireNode$2();
}
var srcExports$2 = src$2.exports;
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$5, "__esModule", { value: true });
dist$5.SerialPortStream = dist$5.DisconnectedError = void 0;
const stream_1$3 = require$$0$4;
const debug_1$3 = __importDefault$3(srcExports$2);
const debug$5 = (0, debug_1$3.default)("serialport/stream");
class DisconnectedError extends Error {
  disconnected;
  constructor(message) {
    super(message);
    this.disconnected = true;
  }
}
dist$5.DisconnectedError = DisconnectedError;
const defaultSetFlags = {
  brk: false,
  cts: false,
  dtr: true,
  rts: true
};
function allocNewReadPool(poolSize) {
  const pool = Buffer.allocUnsafe(poolSize);
  pool.used = 0;
  return pool;
}
class SerialPortStream extends stream_1$3.Duplex {
  port;
  _pool;
  _kMinPoolSpace;
  opening;
  closing;
  settings;
  /**
   * Create a new serial port object for the `path`. In the case of invalid arguments or invalid options, when constructing a new SerialPort it will throw an error. The port will open automatically by default, which is the equivalent of calling `port.open(openCallback)` in the next tick. You can disable this by setting the option `autoOpen` to `false`.
   * @emits open
   * @emits data
   * @emits close
   * @emits error
   */
  constructor(options, openCallback) {
    const settings = {
      autoOpen: true,
      endOnClose: false,
      highWaterMark: 64 * 1024,
      ...options
    };
    super({
      highWaterMark: settings.highWaterMark
    });
    if (!settings.binding) {
      throw new TypeError('"Bindings" is invalid pass it as `options.binding`');
    }
    if (!settings.path) {
      throw new TypeError(`"path" is not defined: ${settings.path}`);
    }
    if (typeof settings.baudRate !== "number") {
      throw new TypeError(`"baudRate" must be a number: ${settings.baudRate}`);
    }
    this.settings = settings;
    this.opening = false;
    this.closing = false;
    this._pool = allocNewReadPool(this.settings.highWaterMark);
    this._kMinPoolSpace = 128;
    if (this.settings.autoOpen) {
      this.open(openCallback);
    }
  }
  get path() {
    return this.settings.path;
  }
  get baudRate() {
    return this.settings.baudRate;
  }
  get isOpen() {
    return (this.port?.isOpen ?? false) && !this.closing;
  }
  _error(error2, callback) {
    if (callback) {
      callback.call(this, error2);
    } else {
      this.emit("error", error2);
    }
  }
  _asyncError(error2, callback) {
    process.nextTick(() => this._error(error2, callback));
  }
  /**
   * Opens a connection to the given serial port.
   * @param {ErrorCallback=} openCallback - Called after a connection is opened. If this is not provided and an error occurs, it will be emitted on the port's `error` event.
   * @emits open
   */
  open(openCallback) {
    if (this.isOpen) {
      return this._asyncError(new Error("Port is already open"), openCallback);
    }
    if (this.opening) {
      return this._asyncError(new Error("Port is opening"), openCallback);
    }
    const { highWaterMark, binding: binding2, autoOpen, endOnClose, ...openOptions } = this.settings;
    this.opening = true;
    debug$5("opening", `path: ${this.path}`);
    this.settings.binding.open(openOptions).then((port) => {
      debug$5("opened", `path: ${this.path}`);
      this.port = port;
      this.opening = false;
      this.emit("open");
      if (openCallback) {
        openCallback.call(this, null);
      }
    }, (err) => {
      this.opening = false;
      debug$5("Binding #open had an error", err);
      this._error(err, openCallback);
    });
  }
  /**
   * Changes the baud rate for an open port. Emits an error or calls the callback if the baud rate isn't supported.
   * @param {object=} options Only supports `baudRate`.
   * @param {number=} [options.baudRate] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.
   * @param {ErrorCallback=} [callback] Called once the port's baud rate changes. If `.update` is called without a callback, and there is an error, an error event is emitted.
   * @returns {undefined}
   */
  update(options, callback) {
    if (!this.isOpen || !this.port) {
      debug$5("update attempted, but port is not open");
      return this._asyncError(new Error("Port is not open"), callback);
    }
    debug$5("update", `baudRate: ${options.baudRate}`);
    this.port.update(options).then(() => {
      debug$5("binding.update", "finished");
      this.settings.baudRate = options.baudRate;
      if (callback) {
        callback.call(this, null);
      }
    }, (err) => {
      debug$5("binding.update", "error", err);
      return this._error(err, callback);
    });
  }
  write(data, encoding2, callback) {
    if (Array.isArray(data)) {
      data = Buffer.from(data);
    }
    if (typeof encoding2 === "function") {
      return super.write(data, encoding2);
    }
    return super.write(data, encoding2, callback);
  }
  _write(data, encoding2, callback) {
    if (!this.isOpen || !this.port) {
      this.once("open", () => {
        this._write(data, encoding2, callback);
      });
      return;
    }
    debug$5("_write", `${data.length} bytes of data`);
    this.port.write(data).then(() => {
      debug$5("binding.write", "write finished");
      callback(null);
    }, (err) => {
      debug$5("binding.write", "error", err);
      if (!err.canceled) {
        this._disconnected(err);
      }
      callback(err);
    });
  }
  _writev(data, callback) {
    debug$5("_writev", `${data.length} chunks of data`);
    const dataV = data.map((write) => write.chunk);
    this._write(Buffer.concat(dataV), void 0, callback);
  }
  _read(bytesToRead) {
    if (!this.isOpen || !this.port) {
      debug$5("_read", "queueing _read for after open");
      this.once("open", () => {
        this._read(bytesToRead);
      });
      return;
    }
    if (!this._pool || this._pool.length - this._pool.used < this._kMinPoolSpace) {
      debug$5("_read", "discarding the read buffer pool because it is below kMinPoolSpace");
      this._pool = allocNewReadPool(this.settings.highWaterMark);
    }
    const pool = this._pool;
    const toRead = Math.min(pool.length - pool.used, bytesToRead);
    const start = pool.used;
    debug$5("_read", `reading`, { start, toRead });
    this.port.read(pool, start, toRead).then(({ bytesRead }) => {
      debug$5("binding.read", `finished`, { bytesRead });
      if (bytesRead === 0) {
        debug$5("binding.read", "Zero bytes read closing readable stream");
        this.push(null);
        return;
      }
      pool.used += bytesRead;
      this.push(pool.slice(start, start + bytesRead));
    }, (err) => {
      debug$5("binding.read", `error`, err);
      if (!err.canceled) {
        this._disconnected(err);
      }
      this._read(bytesToRead);
    });
  }
  _disconnected(err) {
    if (!this.isOpen) {
      debug$5("disconnected aborted because already closed", err);
      return;
    }
    debug$5("disconnected", err);
    this.close(void 0, new DisconnectedError(err.message));
  }
  /**
   * Closes an open connection.
   *
   * If there are in progress writes when the port is closed the writes will error.
   * @param {ErrorCallback} callback Called once a connection is closed.
   * @param {Error} disconnectError used internally to propagate a disconnect error
   */
  close(callback, disconnectError = null) {
    if (!this.isOpen || !this.port) {
      debug$5("close attempted, but port is not open");
      return this._asyncError(new Error("Port is not open"), callback);
    }
    this.closing = true;
    debug$5("#close");
    this.port.close().then(() => {
      this.closing = false;
      debug$5("binding.close", "finished");
      this.emit("close", disconnectError);
      if (this.settings.endOnClose) {
        this.emit("end");
      }
      if (callback) {
        callback.call(this, disconnectError);
      }
    }, (err) => {
      this.closing = false;
      debug$5("binding.close", "had an error", err);
      return this._error(err, callback);
    });
  }
  /**
   * Set control flags on an open port. Uses [`SetCommMask`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363257(v=vs.85).aspx) for Windows and [`ioctl`](http://linux.die.net/man/4/tty_ioctl) for OS X and Linux.
   *
   * All options are operating system default when the port is opened. Every flag is set on each call to the provided or default values. If options isn't provided default options is used.
   */
  set(options, callback) {
    if (!this.isOpen || !this.port) {
      debug$5("set attempted, but port is not open");
      return this._asyncError(new Error("Port is not open"), callback);
    }
    const settings = { ...defaultSetFlags, ...options };
    debug$5("#set", settings);
    this.port.set(settings).then(() => {
      debug$5("binding.set", "finished");
      if (callback) {
        callback.call(this, null);
      }
    }, (err) => {
      debug$5("binding.set", "had an error", err);
      return this._error(err, callback);
    });
  }
  /**
   * Returns the control flags (CTS, DSR, DCD) on the open port.
   * Uses [`GetCommModemStatus`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363258(v=vs.85).aspx) for Windows and [`ioctl`](http://linux.die.net/man/4/tty_ioctl) for mac and linux.
   */
  get(callback) {
    if (!this.isOpen || !this.port) {
      debug$5("get attempted, but port is not open");
      return this._asyncError(new Error("Port is not open"), callback);
    }
    debug$5("#get");
    this.port.get().then((status) => {
      debug$5("binding.get", "finished");
      callback.call(this, null, status);
    }, (err) => {
      debug$5("binding.get", "had an error", err);
      return this._error(err, callback);
    });
  }
  /**
   * Flush discards data received but not read, and written but not transmitted by the operating system. For more technical details, see [`tcflush(fd, TCIOFLUSH)`](http://linux.die.net/man/3/tcflush) for Mac/Linux and [`FlushFileBuffers`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439) for Windows.
   */
  flush(callback) {
    if (!this.isOpen || !this.port) {
      debug$5("flush attempted, but port is not open");
      return this._asyncError(new Error("Port is not open"), callback);
    }
    debug$5("#flush");
    this.port.flush().then(() => {
      debug$5("binding.flush", "finished");
      if (callback) {
        callback.call(this, null);
      }
    }, (err) => {
      debug$5("binding.flush", "had an error", err);
      return this._error(err, callback);
    });
  }
  /**
     * Waits until all output data is transmitted to the serial port. After any pending write has completed it calls [`tcdrain()`](http://linux.die.net/man/3/tcdrain) or [FlushFileBuffers()](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364439(v=vs.85).aspx) to ensure it has been written to the device.
    * @example
    Write the `data` and wait until it has finished transmitting to the target serial port before calling the callback. This will queue until the port is open and writes are finished.
  
    ```js
    function writeAndDrain (data, callback) {
      port.write(data);
      port.drain(callback);
    }
    ```
    */
  drain(callback) {
    debug$5("drain");
    if (!this.isOpen || !this.port) {
      debug$5("drain queuing on port open");
      this.once("open", () => {
        this.drain(callback);
      });
      return;
    }
    this.port.drain().then(() => {
      debug$5("binding.drain", "finished");
      if (callback) {
        callback.call(this, null);
      }
    }, (err) => {
      debug$5("binding.drain", "had an error", err);
      return this._error(err, callback);
    });
  }
}
dist$5.SerialPortStream = SerialPortStream;
var dist$4 = {};
var src$1 = { exports: {} };
var browser$1 = { exports: {} };
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$1;
  hasRequiredMs$1 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common$1;
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1)
    return common$1;
  hasRequiredCommon$1 = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$1();
    createDebug.destroy = destroy2;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args2) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip2 of createDebug.skips) {
        if (matchesTemplate(name, skip2)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$1 = setup;
  return common$1;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$1.exports;
  hasRequiredBrowser$1 = 1;
  (function(module2, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = requireCommon$1()(exports2);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var node$1 = { exports: {} };
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1)
    return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module2, exports2) {
    const tty = require$$0$7;
    const util2 = require$$1$1;
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args2) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args2) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = requireCommon$1()(exports2);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, node$1.exports);
  return node$1.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src$1.exports = requireBrowser$1();
} else {
  src$1.exports = requireNode$1();
}
var srcExports$1 = src$1.exports;
Object.defineProperty(dist$4, "__esModule", { value: true });
var debugFactory = srcExports$1;
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
var debugFactory__default = /* @__PURE__ */ _interopDefaultLegacy(debugFactory);
const debug$4 = debugFactory__default["default"]("serialport/binding-mock");
let ports = {};
let serialNumber = 0;
function resolveNextTick() {
  return new Promise((resolve2) => process.nextTick(() => resolve2()));
}
let CanceledError$2 = class CanceledError extends Error {
  constructor(message) {
    super(message);
    this.canceled = true;
  }
};
const MockBinding = {
  reset() {
    ports = {};
    serialNumber = 0;
  },
  // Create a mock port
  createPort(path2, options = {}) {
    serialNumber++;
    const optWithDefaults = Object.assign({ echo: false, record: false, manufacturer: "The J5 Robotics Company", vendorId: void 0, productId: void 0, maxReadSize: 1024 }, options);
    ports[path2] = {
      data: Buffer.alloc(0),
      echo: optWithDefaults.echo,
      record: optWithDefaults.record,
      readyData: optWithDefaults.readyData,
      maxReadSize: optWithDefaults.maxReadSize,
      info: {
        path: path2,
        manufacturer: optWithDefaults.manufacturer,
        serialNumber: `${serialNumber}`,
        pnpId: void 0,
        locationId: void 0,
        vendorId: optWithDefaults.vendorId,
        productId: optWithDefaults.productId
      }
    };
    debug$4(serialNumber, "created port", JSON.stringify({ path: path2, opt: options }));
  },
  async list() {
    debug$4(null, "list");
    return Object.values(ports).map((port) => port.info);
  },
  async open(options) {
    var _a;
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new TypeError('"options" is not an object');
    }
    if (!options.path) {
      throw new TypeError('"path" is not a valid port');
    }
    if (!options.baudRate) {
      throw new TypeError('"baudRate" is not a valid baudRate');
    }
    const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
    const { path: path2 } = openOptions;
    debug$4(null, `open: opening path ${path2}`);
    const port = ports[path2];
    await resolveNextTick();
    if (!port) {
      throw new Error(`Port does not exist - please call MockBinding.createPort('${path2}') first`);
    }
    const serialNumber2 = port.info.serialNumber;
    if ((_a = port.openOpt) === null || _a === void 0 ? void 0 : _a.lock) {
      debug$4(serialNumber2, "open: Port is locked cannot open");
      throw new Error("Port is locked cannot open");
    }
    debug$4(serialNumber2, `open: opened path ${path2}`);
    port.openOpt = Object.assign({}, openOptions);
    return new MockPortBinding(port, openOptions);
  }
};
class MockPortBinding {
  constructor(port, openOptions) {
    this.port = port;
    this.openOptions = openOptions;
    this.pendingRead = null;
    this.isOpen = true;
    this.lastWrite = null;
    this.recording = Buffer.alloc(0);
    this.writeOperation = null;
    this.serialNumber = port.info.serialNumber;
    if (port.readyData) {
      const data = port.readyData;
      process.nextTick(() => {
        if (this.isOpen) {
          debug$4(this.serialNumber, "emitting ready data");
          this.emitData(data);
        }
      });
    }
  }
  // Emit data on a mock port
  emitData(data) {
    if (!this.isOpen || !this.port) {
      throw new Error("Port must be open to pretend to receive data");
    }
    const bufferData = Buffer.isBuffer(data) ? data : Buffer.from(data);
    debug$4(this.serialNumber, "emitting data - pending read:", Boolean(this.pendingRead));
    this.port.data = Buffer.concat([this.port.data, bufferData]);
    if (this.pendingRead) {
      process.nextTick(this.pendingRead);
      this.pendingRead = null;
    }
  }
  async close() {
    debug$4(this.serialNumber, "close");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    const port = this.port;
    if (!port) {
      throw new Error("already closed");
    }
    port.openOpt = void 0;
    port.data = Buffer.alloc(0);
    debug$4(this.serialNumber, "port is closed");
    this.serialNumber = void 0;
    this.isOpen = false;
    if (this.pendingRead) {
      this.pendingRead(new CanceledError$2("port is closed"));
    }
  }
  async read(buffer2, offset, length) {
    if (!Buffer.isBuffer(buffer2)) {
      throw new TypeError('"buffer" is not a Buffer');
    }
    if (typeof offset !== "number" || isNaN(offset)) {
      throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
    }
    if (typeof length !== "number" || isNaN(length)) {
      throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
    }
    if (buffer2.length < offset + length) {
      throw new Error("buffer is too small");
    }
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    debug$4(this.serialNumber, "read", length, "bytes");
    await resolveNextTick();
    if (!this.isOpen || !this.port) {
      throw new CanceledError$2("Read canceled");
    }
    if (this.port.data.length <= 0) {
      return new Promise((resolve2, reject) => {
        this.pendingRead = (err) => {
          if (err) {
            return reject(err);
          }
          this.read(buffer2, offset, length).then(resolve2, reject);
        };
      });
    }
    const lengthToRead = this.port.maxReadSize > length ? length : this.port.maxReadSize;
    const data = this.port.data.slice(0, lengthToRead);
    const bytesRead = data.copy(buffer2, offset);
    this.port.data = this.port.data.slice(lengthToRead);
    debug$4(this.serialNumber, "read", bytesRead, "bytes");
    return { bytesRead, buffer: buffer2 };
  }
  async write(buffer2) {
    if (!Buffer.isBuffer(buffer2)) {
      throw new TypeError('"buffer" is not a Buffer');
    }
    if (!this.isOpen || !this.port) {
      debug$4("write", "error port is not open");
      throw new Error("Port is not open");
    }
    debug$4(this.serialNumber, "write", buffer2.length, "bytes");
    if (this.writeOperation) {
      throw new Error("Overlapping writes are not supported and should be queued by the serialport object");
    }
    this.writeOperation = (async () => {
      await resolveNextTick();
      if (!this.isOpen || !this.port) {
        throw new Error("Write canceled");
      }
      const data = this.lastWrite = Buffer.from(buffer2);
      if (this.port.record) {
        this.recording = Buffer.concat([this.recording, data]);
      }
      if (this.port.echo) {
        process.nextTick(() => {
          if (this.isOpen) {
            this.emitData(data);
          }
        });
      }
      this.writeOperation = null;
      debug$4(this.serialNumber, "writing finished");
    })();
    return this.writeOperation;
  }
  async update(options) {
    if (typeof options !== "object") {
      throw TypeError('"options" is not an object');
    }
    if (typeof options.baudRate !== "number") {
      throw new TypeError('"options.baudRate" is not a number');
    }
    debug$4(this.serialNumber, "update");
    if (!this.isOpen || !this.port) {
      throw new Error("Port is not open");
    }
    await resolveNextTick();
    if (this.port.openOpt) {
      this.port.openOpt.baudRate = options.baudRate;
    }
  }
  async set(options) {
    if (typeof options !== "object") {
      throw new TypeError('"options" is not an object');
    }
    debug$4(this.serialNumber, "set");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await resolveNextTick();
  }
  async get() {
    debug$4(this.serialNumber, "get");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await resolveNextTick();
    return {
      cts: true,
      dsr: false,
      dcd: false
    };
  }
  async getBaudRate() {
    var _a;
    debug$4(this.serialNumber, "getBaudRate");
    if (!this.isOpen || !this.port) {
      throw new Error("Port is not open");
    }
    await resolveNextTick();
    if (!((_a = this.port.openOpt) === null || _a === void 0 ? void 0 : _a.baudRate)) {
      throw new Error("Internal Error");
    }
    return {
      baudRate: this.port.openOpt.baudRate
    };
  }
  async flush() {
    debug$4(this.serialNumber, "flush");
    if (!this.isOpen || !this.port) {
      throw new Error("Port is not open");
    }
    await resolveNextTick();
    this.port.data = Buffer.alloc(0);
  }
  async drain() {
    debug$4(this.serialNumber, "drain");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await this.writeOperation;
    await resolveNextTick();
  }
}
dist$4.CanceledError = CanceledError$2;
dist$4.MockBinding = MockBinding;
dist$4.MockPortBinding = MockPortBinding;
Object.defineProperty(serialportMock, "__esModule", { value: true });
serialportMock.SerialPortMock = void 0;
const stream_1$2 = dist$5;
const binding_mock_1 = dist$4;
class SerialPortMock extends stream_1$2.SerialPortStream {
  static list = binding_mock_1.MockBinding.list;
  static binding = binding_mock_1.MockBinding;
  constructor(options, openCallback) {
    const opts = {
      binding: binding_mock_1.MockBinding,
      ...options
    };
    super(opts, openCallback);
  }
}
serialportMock.SerialPortMock = SerialPortMock;
var serialport = {};
var dist$3 = {};
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy2;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args2) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser.exports;
  hasRequiredBrowser = 1;
  (function(module2, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = requireCommon()(exports2);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node.exports;
  hasRequiredNode = 1;
  (function(module2, exports2) {
    const tty = require$$0$7;
    const util2 = require$$1$1;
    exports2.init = init2;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args2) {
      return process.stderr.write(util2.format(...args2) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = requireCommon()(exports2);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}
var srcExports = src.exports;
var darwin = {};
var loadBindings = {};
var nodeGypBuild$1 = { exports: {} };
var nodeGypBuild;
var hasRequiredNodeGypBuild;
function requireNodeGypBuild() {
  if (hasRequiredNodeGypBuild)
    return nodeGypBuild;
  hasRequiredNodeGypBuild = 1;
  var fs2 = require$$1$3;
  var path2 = require$$0$6;
  var os2 = require$$1$2;
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : commonjsRequire;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var abi = process.versions.modules;
  var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os2.arch();
  var platform2 = process.env.npm_config_platform || os2.platform();
  var libc = process.env.LIBC || (isAlpine(platform2) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (process.versions.uv || "").split(".")[0];
  nodeGypBuild = load;
  function load(dir) {
    return runtimeRequire(load.resolve(dir));
  }
  load.resolve = load.path = function(dir) {
    dir = path2.resolve(dir || ".");
    try {
      var name = runtimeRequire(path2.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
      if (process.env[name + "_PREBUILD"])
        dir = process.env[name + "_PREBUILD"];
    } catch (err) {
    }
    if (!prebuildsOnly) {
      var release = getFirst(path2.join(dir, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug2 = getFirst(path2.join(dir, "build/Debug"), matchBuild);
      if (debug2)
        return debug2;
    }
    var prebuild = resolve2(dir);
    if (prebuild)
      return prebuild;
    var nearby = resolve2(path2.dirname(process.execPath));
    if (nearby)
      return nearby;
    var target = [
      "platform=" + platform2,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
      // eslint-disable-line
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
    function resolve2(dir2) {
      var tuples = readdirSync(path2.join(dir2, "prebuilds")).map(parseTuple);
      var tuple = tuples.filter(matchTuple(platform2, arch)).sort(compareTuples)[0];
      if (!tuple)
        return;
      var prebuilds = path2.join(dir2, "prebuilds", tuple.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner)
        return path2.join(prebuilds, winner.file);
    }
  };
  function readdirSync(dir) {
    try {
      return fs2.readdirSync(dir);
    } catch (err) {
      return [];
    }
  }
  function getFirst(dir, filter3) {
    var files = readdirSync(dir).filter(filter3);
    return files[0] && path2.join(dir, files[0]);
  }
  function matchBuild(name) {
    return /\.node$/.test(name);
  }
  function parseTuple(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform3 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform3)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform3, architectures };
  }
  function matchTuple(platform3, arch2) {
    return function(tuple) {
      if (tuple == null)
        return false;
      if (tuple.platform !== platform3)
        return false;
      return tuple.architectures.includes(arch2);
    };
  }
  function compareTuples(a, b) {
    return a.architectures.length - b.architectures.length;
  }
  function parseTags(file2) {
    var arr = file2.split(".");
    var extension = arr.pop();
    var tags = { file: file2, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i = 0; i < arr.length; i++) {
      var tag = arr[i];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  }
  function matchTags(runtime2, abi2) {
    return function(tags) {
      if (tags == null)
        return false;
      if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
        return false;
      if (tags.abi !== abi2 && !tags.napi)
        return false;
      if (tags.uv && tags.uv !== uv)
        return false;
      if (tags.armv && tags.armv !== armv)
        return false;
      if (tags.libc && tags.libc !== libc)
        return false;
      return true;
    };
  }
  function runtimeAgnostic(tags) {
    return tags.runtime === "node" && tags.napi;
  }
  function compareTags(runtime2) {
    return function(a, b) {
      if (a.runtime !== b.runtime) {
        return a.runtime === runtime2 ? -1 : 1;
      } else if (a.abi !== b.abi) {
        return a.abi ? -1 : 1;
      } else if (a.specificity !== b.specificity) {
        return a.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  }
  function isNwjs() {
    return !!(process.versions && process.versions.nw);
  }
  function isElectron() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  }
  function isAlpine(platform3) {
    return platform3 === "linux" && fs2.existsSync("/etc/alpine-release");
  }
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
  return nodeGypBuild;
}
if (typeof process.addon === "function") {
  nodeGypBuild$1.exports = process.addon.bind(process);
} else {
  nodeGypBuild$1.exports = requireNodeGypBuild();
}
var nodeGypBuildExports = nodeGypBuild$1.exports;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(loadBindings, "__esModule", { value: true });
loadBindings.asyncWrite = loadBindings.asyncRead = loadBindings.asyncUpdate = loadBindings.asyncSet = loadBindings.asyncOpen = loadBindings.asyncList = loadBindings.asyncGetBaudRate = loadBindings.asyncGet = loadBindings.asyncFlush = loadBindings.asyncDrain = loadBindings.asyncClose = void 0;
const node_gyp_build_1 = __importDefault$2(nodeGypBuildExports);
const util_1 = require$$1$1;
const path_1 = require$$0$6;
const binding = (0, node_gyp_build_1.default)((0, path_1.join)(__dirname, "../"));
loadBindings.asyncClose = binding.close ? (0, util_1.promisify)(binding.close) : async () => {
  throw new Error('"binding.close" Method not implemented');
};
loadBindings.asyncDrain = binding.drain ? (0, util_1.promisify)(binding.drain) : async () => {
  throw new Error('"binding.drain" Method not implemented');
};
loadBindings.asyncFlush = binding.flush ? (0, util_1.promisify)(binding.flush) : async () => {
  throw new Error('"binding.flush" Method not implemented');
};
loadBindings.asyncGet = binding.get ? (0, util_1.promisify)(binding.get) : async () => {
  throw new Error('"binding.get" Method not implemented');
};
loadBindings.asyncGetBaudRate = binding.getBaudRate ? (0, util_1.promisify)(binding.getBaudRate) : async () => {
  throw new Error('"binding.getBaudRate" Method not implemented');
};
loadBindings.asyncList = binding.list ? (0, util_1.promisify)(binding.list) : async () => {
  throw new Error('"binding.list" Method not implemented');
};
loadBindings.asyncOpen = binding.open ? (0, util_1.promisify)(binding.open) : async () => {
  throw new Error('"binding.open" Method not implemented');
};
loadBindings.asyncSet = binding.set ? (0, util_1.promisify)(binding.set) : async () => {
  throw new Error('"binding.set" Method not implemented');
};
loadBindings.asyncUpdate = binding.update ? (0, util_1.promisify)(binding.update) : async () => {
  throw new Error('"binding.update" Method not implemented');
};
loadBindings.asyncRead = binding.read ? (0, util_1.promisify)(binding.read) : async () => {
  throw new Error('"binding.read" Method not implemented');
};
loadBindings.asyncWrite = binding.write ? (0, util_1.promisify)(binding.write) : async () => {
  throw new Error('"binding.write" Method not implemented');
};
var poller = {};
var errors = {};
Object.defineProperty(errors, "__esModule", { value: true });
errors.BindingsError = void 0;
class BindingsError extends Error {
  constructor(message, { canceled = false } = {}) {
    super(message);
    this.canceled = canceled;
  }
}
errors.BindingsError = BindingsError;
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Poller = exports2.EVENTS = void 0;
  const debug_12 = __importDefault2(srcExports);
  const events_1 = require$$0$8;
  const path_12 = require$$0$6;
  const node_gyp_build_12 = __importDefault2(nodeGypBuildExports);
  const errors_12 = errors;
  const { Poller: PollerBindings } = (0, node_gyp_build_12.default)((0, path_12.join)(__dirname, "../"));
  const logger = (0, debug_12.default)("serialport/bindings-cpp/poller");
  exports2.EVENTS = {
    UV_READABLE: 1,
    UV_WRITABLE: 2,
    UV_DISCONNECT: 4
  };
  function handleEvent(error2, eventFlag) {
    if (error2) {
      logger("error", error2);
      this.emit("readable", error2);
      this.emit("writable", error2);
      this.emit("disconnect", error2);
      return;
    }
    if (eventFlag & exports2.EVENTS.UV_READABLE) {
      logger('received "readable"');
      this.emit("readable", null);
    }
    if (eventFlag & exports2.EVENTS.UV_WRITABLE) {
      logger('received "writable"');
      this.emit("writable", null);
    }
    if (eventFlag & exports2.EVENTS.UV_DISCONNECT) {
      logger('received "disconnect"');
      this.emit("disconnect", null);
    }
  }
  class Poller extends events_1.EventEmitter {
    constructor(fd, FDPoller = PollerBindings) {
      logger("Creating poller");
      super();
      this.poller = new FDPoller(fd, handleEvent.bind(this));
    }
    /**
     * Wait for the next event to occur
     * @param {string} event ('readable'|'writable'|'disconnect')
     * @returns {Poller} returns itself
     */
    once(event, callback) {
      switch (event) {
        case "readable":
          this.poll(exports2.EVENTS.UV_READABLE);
          break;
        case "writable":
          this.poll(exports2.EVENTS.UV_WRITABLE);
          break;
        case "disconnect":
          this.poll(exports2.EVENTS.UV_DISCONNECT);
          break;
      }
      return super.once(event, callback);
    }
    /**
     * Ask the bindings to listen for an event, it is recommend to use `.once()` for easy use
     * @param {EVENTS} eventFlag polls for an event or group of events based upon a flag.
     */
    poll(eventFlag = 0) {
      if (eventFlag & exports2.EVENTS.UV_READABLE) {
        logger('Polling for "readable"');
      }
      if (eventFlag & exports2.EVENTS.UV_WRITABLE) {
        logger('Polling for "writable"');
      }
      if (eventFlag & exports2.EVENTS.UV_DISCONNECT) {
        logger('Polling for "disconnect"');
      }
      this.poller.poll(eventFlag);
    }
    /**
     * Stop listening for events and cancel all outstanding listening with an error
     */
    stop() {
      logger("Stopping poller");
      this.poller.stop();
      this.emitCanceled();
    }
    destroy() {
      logger("Destroying poller");
      this.poller.destroy();
      this.emitCanceled();
    }
    emitCanceled() {
      const err = new errors_12.BindingsError("Canceled", { canceled: true });
      this.emit("readable", err);
      this.emit("writable", err);
      this.emit("disconnect", err);
    }
  }
  exports2.Poller = Poller;
})(poller);
var unixRead = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.unixRead = void 0;
  const util_12 = require$$1$1;
  const fs_12 = require$$1$3;
  const errors_12 = errors;
  const debug_12 = __importDefault2(srcExports);
  const logger = (0, debug_12.default)("serialport/bindings-cpp/unixRead");
  const readAsync = (0, util_12.promisify)(fs_12.read);
  const readable2 = (binding2) => {
    return new Promise((resolve2, reject) => {
      if (!binding2.poller) {
        throw new Error("No poller on bindings");
      }
      binding2.poller.once("readable", (err) => err ? reject(err) : resolve2());
    });
  };
  const unixRead2 = async ({ binding: binding2, buffer: buffer2, offset, length, fsReadAsync = readAsync }) => {
    logger("Starting read");
    if (!binding2.isOpen || !binding2.fd) {
      throw new errors_12.BindingsError("Port is not open", { canceled: true });
    }
    try {
      const { bytesRead } = await fsReadAsync(binding2.fd, buffer2, offset, length, null);
      if (bytesRead === 0) {
        return (0, exports2.unixRead)({ binding: binding2, buffer: buffer2, offset, length, fsReadAsync });
      }
      logger("Finished read", bytesRead, "bytes");
      return { bytesRead, buffer: buffer2 };
    } catch (err) {
      logger("read error", err);
      if (err.code === "EAGAIN" || err.code === "EWOULDBLOCK" || err.code === "EINTR") {
        if (!binding2.isOpen) {
          throw new errors_12.BindingsError("Port is not open", { canceled: true });
        }
        logger("waiting for readable because of code:", err.code);
        await readable2(binding2);
        return (0, exports2.unixRead)({ binding: binding2, buffer: buffer2, offset, length, fsReadAsync });
      }
      const disconnectError = err.code === "EBADF" || // Bad file number means we got closed
      err.code === "ENXIO" || // No such device or address probably usb disconnect
      err.code === "UNKNOWN" || err.errno === -1;
      if (disconnectError) {
        err.disconnect = true;
        logger("disconnecting", err);
      }
      throw err;
    }
  };
  exports2.unixRead = unixRead2;
})(unixRead);
var unixWrite = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.unixWrite = void 0;
  const fs_12 = require$$1$3;
  const debug_12 = __importDefault2(srcExports);
  const util_12 = require$$1$1;
  const logger = (0, debug_12.default)("serialport/bindings-cpp/unixWrite");
  const writeAsync = (0, util_12.promisify)(fs_12.write);
  const writable = (binding2) => {
    return new Promise((resolve2, reject) => {
      binding2.poller.once("writable", (err) => err ? reject(err) : resolve2());
    });
  };
  const unixWrite2 = async ({ binding: binding2, buffer: buffer2, offset = 0, fsWriteAsync = writeAsync }) => {
    const bytesToWrite = buffer2.length - offset;
    logger("Starting write", buffer2.length, "bytes offset", offset, "bytesToWrite", bytesToWrite);
    if (!binding2.isOpen || !binding2.fd) {
      throw new Error("Port is not open");
    }
    try {
      const { bytesWritten } = await fsWriteAsync(binding2.fd, buffer2, offset, bytesToWrite);
      logger("write returned: wrote", bytesWritten, "bytes");
      if (bytesWritten + offset < buffer2.length) {
        if (!binding2.isOpen) {
          throw new Error("Port is not open");
        }
        return (0, exports2.unixWrite)({ binding: binding2, buffer: buffer2, offset: bytesWritten + offset, fsWriteAsync });
      }
      logger("Finished writing", bytesWritten + offset, "bytes");
    } catch (err) {
      logger("write errored", err);
      if (err.code === "EAGAIN" || err.code === "EWOULDBLOCK" || err.code === "EINTR") {
        if (!binding2.isOpen) {
          throw new Error("Port is not open");
        }
        logger("waiting for writable because of code:", err.code);
        await writable(binding2);
        return (0, exports2.unixWrite)({ binding: binding2, buffer: buffer2, offset, fsWriteAsync });
      }
      const disconnectError = err.code === "EBADF" || // Bad file number means we got closed
      err.code === "ENXIO" || // No such device or address probably usb disconnect
      err.code === "UNKNOWN" || err.errno === -1;
      if (disconnectError) {
        err.disconnect = true;
        logger("disconnecting", err);
      }
      logger("error", err);
      throw err;
    }
  };
  exports2.unixWrite = unixWrite2;
})(unixWrite);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(darwin, "__esModule", { value: true });
darwin.DarwinPortBinding = darwin.DarwinBinding = void 0;
const debug_1$2 = __importDefault$1(srcExports);
const load_bindings_1$1 = loadBindings;
const poller_1$1 = poller;
const unix_read_1$1 = unixRead;
const unix_write_1$1 = unixWrite;
const debug$3 = (0, debug_1$2.default)("serialport/bindings-cpp");
darwin.DarwinBinding = {
  list() {
    debug$3("list");
    return (0, load_bindings_1$1.asyncList)();
  },
  async open(options) {
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new TypeError('"options" is not an object');
    }
    if (!options.path) {
      throw new TypeError('"path" is not a valid port');
    }
    if (!options.baudRate) {
      throw new TypeError('"baudRate" is not a valid baudRate');
    }
    debug$3("open");
    const openOptions = Object.assign({ vmin: 1, vtime: 0, dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
    const fd = await (0, load_bindings_1$1.asyncOpen)(openOptions.path, openOptions);
    return new DarwinPortBinding(fd, openOptions);
  }
};
class DarwinPortBinding {
  constructor(fd, options) {
    this.fd = fd;
    this.openOptions = options;
    this.poller = new poller_1$1.Poller(fd);
    this.writeOperation = null;
  }
  get isOpen() {
    return this.fd !== null;
  }
  async close() {
    debug$3("close");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    const fd = this.fd;
    this.poller.stop();
    this.poller.destroy();
    this.fd = null;
    await (0, load_bindings_1$1.asyncClose)(fd);
  }
  async read(buffer2, offset, length) {
    if (!Buffer.isBuffer(buffer2)) {
      throw new TypeError('"buffer" is not a Buffer');
    }
    if (typeof offset !== "number" || isNaN(offset)) {
      throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
    }
    if (typeof length !== "number" || isNaN(length)) {
      throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
    }
    debug$3("read");
    if (buffer2.length < offset + length) {
      throw new Error("buffer is too small");
    }
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    return (0, unix_read_1$1.unixRead)({ binding: this, buffer: buffer2, offset, length });
  }
  async write(buffer2) {
    if (!Buffer.isBuffer(buffer2)) {
      throw new TypeError('"buffer" is not a Buffer');
    }
    debug$3("write", buffer2.length, "bytes");
    if (!this.isOpen) {
      debug$3("write", "error port is not open");
      throw new Error("Port is not open");
    }
    this.writeOperation = (async () => {
      if (buffer2.length === 0) {
        return;
      }
      await (0, unix_write_1$1.unixWrite)({ binding: this, buffer: buffer2 });
      this.writeOperation = null;
    })();
    return this.writeOperation;
  }
  async update(options) {
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw TypeError('"options" is not an object');
    }
    if (typeof options.baudRate !== "number") {
      throw new TypeError('"options.baudRate" is not a number');
    }
    debug$3("update");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await (0, load_bindings_1$1.asyncUpdate)(this.fd, options);
  }
  async set(options) {
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new TypeError('"options" is not an object');
    }
    debug$3("set", options);
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await (0, load_bindings_1$1.asyncSet)(this.fd, options);
  }
  async get() {
    debug$3("get");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    return (0, load_bindings_1$1.asyncGet)(this.fd);
  }
  async getBaudRate() {
    debug$3("getBaudRate");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    throw new Error("getBaudRate is not implemented on darwin");
  }
  async flush() {
    debug$3("flush");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await (0, load_bindings_1$1.asyncFlush)(this.fd);
  }
  async drain() {
    debug$3("drain");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await this.writeOperation;
    await (0, load_bindings_1$1.asyncDrain)(this.fd);
  }
}
darwin.DarwinPortBinding = DarwinPortBinding;
var linux = {};
var linuxList$1 = {};
var dist$2 = {};
var dist$1 = {};
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.DelimiterParser = void 0;
const stream_1$1 = require$$0$4;
class DelimiterParser2 extends stream_1$1.Transform {
  constructor({ delimiter, includeDelimiter = false, ...options }) {
    super(options);
    if (delimiter === void 0) {
      throw new TypeError('"delimiter" is not a bufferable object');
    }
    if (delimiter.length === 0) {
      throw new TypeError('"delimiter" has a 0 or undefined length');
    }
    this.includeDelimiter = includeDelimiter;
    this.delimiter = Buffer.from(delimiter);
    this.buffer = Buffer.alloc(0);
  }
  _transform(chunk, encoding2, cb) {
    let data = Buffer.concat([this.buffer, chunk]);
    let position;
    while ((position = data.indexOf(this.delimiter)) !== -1) {
      this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));
      data = data.slice(position + this.delimiter.length);
    }
    this.buffer = data;
    cb();
  }
  _flush(cb) {
    this.push(this.buffer);
    this.buffer = Buffer.alloc(0);
    cb();
  }
}
dist$1.DelimiterParser = DelimiterParser2;
Object.defineProperty(dist$2, "__esModule", { value: true });
dist$2.ReadlineParser = void 0;
const parser_delimiter_1 = dist$1;
class ReadlineParser2 extends parser_delimiter_1.DelimiterParser {
  constructor(options) {
    const opts = {
      delimiter: Buffer.from("\n", "utf8"),
      encoding: "utf8",
      ...options
    };
    if (typeof opts.delimiter === "string") {
      opts.delimiter = Buffer.from(opts.delimiter, opts.encoding);
    }
    super(opts);
  }
}
dist$2.ReadlineParser = ReadlineParser2;
Object.defineProperty(linuxList$1, "__esModule", { value: true });
linuxList$1.linuxList = void 0;
const child_process_1 = require$$0$b;
const parser_readline_1 = dist$2;
function checkPathOfDevice(path2) {
  return /(tty(S|WCH|ACM|USB|AMA|MFD|O|XRUSB)|rfcomm)/.test(path2) && path2;
}
function propName(name) {
  return {
    DEVNAME: "path",
    ID_VENDOR_ENC: "manufacturer",
    ID_SERIAL_SHORT: "serialNumber",
    ID_VENDOR_ID: "vendorId",
    ID_MODEL_ID: "productId",
    DEVLINKS: "pnpId",
    /**
    * Workaround for systemd defect
    * see https://github.com/serialport/bindings-cpp/issues/115
    */
    ID_USB_VENDOR_ENC: "manufacturer",
    ID_USB_SERIAL_SHORT: "serialNumber",
    ID_USB_VENDOR_ID: "vendorId",
    ID_USB_MODEL_ID: "productId"
    // End of workaround
  }[name.toUpperCase()];
}
function decodeHexEscape(str) {
  return str.replace(/\\x([a-fA-F0-9]{2})/g, (a, b) => {
    return String.fromCharCode(parseInt(b, 16));
  });
}
function propVal(name, val) {
  if (name === "pnpId") {
    const match = val.match(/\/by-id\/([^\s]+)/);
    return (match === null || match === void 0 ? void 0 : match[1]) || void 0;
  }
  if (name === "manufacturer") {
    return decodeHexEscape(val);
  }
  if (/^0x/.test(val)) {
    return val.substr(2);
  }
  return val;
}
function linuxList(spawnCmd = child_process_1.spawn) {
  const ports2 = [];
  const udevadm = spawnCmd("udevadm", ["info", "-e"]);
  const lines = udevadm.stdout.pipe(new parser_readline_1.ReadlineParser());
  let skipPort = false;
  let port = {
    path: "",
    manufacturer: void 0,
    serialNumber: void 0,
    pnpId: void 0,
    locationId: void 0,
    vendorId: void 0,
    productId: void 0
  };
  lines.on("data", (line) => {
    const lineType = line.slice(0, 1);
    const data = line.slice(3);
    if (lineType === "P") {
      port = {
        path: "",
        manufacturer: void 0,
        serialNumber: void 0,
        pnpId: void 0,
        locationId: void 0,
        vendorId: void 0,
        productId: void 0
      };
      skipPort = false;
      return;
    }
    if (skipPort) {
      return;
    }
    if (lineType === "N") {
      if (checkPathOfDevice(data)) {
        ports2.push(port);
      } else {
        skipPort = true;
      }
      return;
    }
    if (lineType === "E") {
      const keyValue = data.match(/^(.+)=(.*)/);
      if (!keyValue) {
        return;
      }
      const key = propName(keyValue[1]);
      if (!key) {
        return;
      }
      port[key] = propVal(key, keyValue[2]);
    }
  });
  return new Promise((resolve2, reject) => {
    udevadm.on("close", (code2) => {
      if (code2) {
        reject(new Error(`Error listing ports udevadm exited with error code: ${code2}`));
      }
    });
    udevadm.on("error", reject);
    lines.on("error", reject);
    lines.on("finish", () => resolve2(ports2));
  });
}
linuxList$1.linuxList = linuxList;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(linux, "__esModule", { value: true });
linux.LinuxPortBinding = linux.LinuxBinding = void 0;
const debug_1$1 = __importDefault(srcExports);
const linux_list_1 = linuxList$1;
const poller_1 = poller;
const unix_read_1 = unixRead;
const unix_write_1 = unixWrite;
const load_bindings_1 = loadBindings;
const debug$2 = (0, debug_1$1.default)("serialport/bindings-cpp");
linux.LinuxBinding = {
  list() {
    debug$2("list");
    return (0, linux_list_1.linuxList)();
  },
  async open(options) {
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new TypeError('"options" is not an object');
    }
    if (!options.path) {
      throw new TypeError('"path" is not a valid port');
    }
    if (!options.baudRate) {
      throw new TypeError('"baudRate" is not a valid baudRate');
    }
    debug$2("open");
    const openOptions = Object.assign({ vmin: 1, vtime: 0, dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);
    const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);
    this.fd = fd;
    return new LinuxPortBinding(fd, openOptions);
  }
};
class LinuxPortBinding {
  constructor(fd, openOptions) {
    this.fd = fd;
    this.openOptions = openOptions;
    this.poller = new poller_1.Poller(fd);
    this.writeOperation = null;
  }
  get isOpen() {
    return this.fd !== null;
  }
  async close() {
    debug$2("close");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    const fd = this.fd;
    this.poller.stop();
    this.poller.destroy();
    this.fd = null;
    await (0, load_bindings_1.asyncClose)(fd);
  }
  async read(buffer2, offset, length) {
    if (!Buffer.isBuffer(buffer2)) {
      throw new TypeError('"buffer" is not a Buffer');
    }
    if (typeof offset !== "number" || isNaN(offset)) {
      throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
    }
    if (typeof length !== "number" || isNaN(length)) {
      throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
    }
    debug$2("read");
    if (buffer2.length < offset + length) {
      throw new Error("buffer is too small");
    }
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    return (0, unix_read_1.unixRead)({ binding: this, buffer: buffer2, offset, length });
  }
  async write(buffer2) {
    if (!Buffer.isBuffer(buffer2)) {
      throw new TypeError('"buffer" is not a Buffer');
    }
    debug$2("write", buffer2.length, "bytes");
    if (!this.isOpen) {
      debug$2("write", "error port is not open");
      throw new Error("Port is not open");
    }
    this.writeOperation = (async () => {
      if (buffer2.length === 0) {
        return;
      }
      await (0, unix_write_1.unixWrite)({ binding: this, buffer: buffer2 });
      this.writeOperation = null;
    })();
    return this.writeOperation;
  }
  async update(options) {
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw TypeError('"options" is not an object');
    }
    if (typeof options.baudRate !== "number") {
      throw new TypeError('"options.baudRate" is not a number');
    }
    debug$2("update");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await (0, load_bindings_1.asyncUpdate)(this.fd, options);
  }
  async set(options) {
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new TypeError('"options" is not an object');
    }
    debug$2("set");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await (0, load_bindings_1.asyncSet)(this.fd, options);
  }
  async get() {
    debug$2("get");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    return (0, load_bindings_1.asyncGet)(this.fd);
  }
  async getBaudRate() {
    debug$2("getBaudRate");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    return (0, load_bindings_1.asyncGetBaudRate)(this.fd);
  }
  async flush() {
    debug$2("flush");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await (0, load_bindings_1.asyncFlush)(this.fd);
  }
  async drain() {
    debug$2("drain");
    if (!this.isOpen) {
      throw new Error("Port is not open");
    }
    await this.writeOperation;
    await (0, load_bindings_1.asyncDrain)(this.fd);
  }
}
linux.LinuxPortBinding = LinuxPortBinding;
var win32 = {};
var win32SnParser = {};
Object.defineProperty(win32SnParser, "__esModule", { value: true });
win32SnParser.serialNumParser = void 0;
const PARSERS = [/USB\\(?:.+)\\(.+)/, /FTDIBUS\\(?:.+)\+(.+?)A?\\.+/];
const serialNumParser = (pnpId) => {
  if (!pnpId) {
    return null;
  }
  for (const parser of PARSERS) {
    const sn = pnpId.match(parser);
    if (sn) {
      return sn[1];
    }
  }
  return null;
};
win32SnParser.serialNumParser = serialNumParser;
var hasRequiredWin32;
function requireWin32() {
  if (hasRequiredWin32)
    return win32;
  hasRequiredWin32 = 1;
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(win32, "__esModule", { value: true });
  win32.WindowsPortBinding = win32.WindowsBinding = void 0;
  const debug_12 = __importDefault2(srcExports);
  const _1 = requireDist();
  const load_bindings_12 = loadBindings;
  const win32_sn_parser_1 = win32SnParser;
  const debug2 = (0, debug_12.default)("serialport/bindings-cpp");
  win32.WindowsBinding = {
    async list() {
      const ports2 = await (0, load_bindings_12.asyncList)();
      return ports2.map((port) => {
        if (port.pnpId && !port.serialNumber) {
          const serialNumber2 = (0, win32_sn_parser_1.serialNumParser)(port.pnpId);
          if (serialNumber2) {
            return Object.assign(Object.assign({}, port), { serialNumber: serialNumber2 });
          }
        }
        return port;
      });
    },
    async open(options) {
      if (!options || typeof options !== "object" || Array.isArray(options)) {
        throw new TypeError('"options" is not an object');
      }
      if (!options.path) {
        throw new TypeError('"path" is not a valid port');
      }
      if (!options.baudRate) {
        throw new TypeError('"baudRate" is not a valid baudRate');
      }
      debug2("open");
      const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: "none", rtscts: false, rtsMode: "handshake", xon: false, xoff: false, xany: false, hupcl: true }, options);
      const fd = await (0, load_bindings_12.asyncOpen)(openOptions.path, openOptions);
      return new WindowsPortBinding(fd, openOptions);
    }
  };
  class WindowsPortBinding {
    constructor(fd, options) {
      this.fd = fd;
      this.openOptions = options;
      this.writeOperation = null;
    }
    get isOpen() {
      return this.fd !== null;
    }
    async close() {
      debug2("close");
      if (!this.isOpen) {
        throw new Error("Port is not open");
      }
      const fd = this.fd;
      this.fd = null;
      await (0, load_bindings_12.asyncClose)(fd);
    }
    async read(buffer2, offset, length) {
      if (!Buffer.isBuffer(buffer2)) {
        throw new TypeError('"buffer" is not a Buffer');
      }
      if (typeof offset !== "number" || isNaN(offset)) {
        throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? "NaN" : typeof offset}"`);
      }
      if (typeof length !== "number" || isNaN(length)) {
        throw new TypeError(`"length" is not an integer got "${isNaN(length) ? "NaN" : typeof length}"`);
      }
      debug2("read");
      if (buffer2.length < offset + length) {
        throw new Error("buffer is too small");
      }
      if (!this.isOpen) {
        throw new Error("Port is not open");
      }
      try {
        const bytesRead = await (0, load_bindings_12.asyncRead)(this.fd, buffer2, offset, length);
        return { bytesRead, buffer: buffer2 };
      } catch (err) {
        if (!this.isOpen) {
          throw new _1.BindingsError(err.message, { canceled: true });
        }
        throw err;
      }
    }
    async write(buffer2) {
      if (!Buffer.isBuffer(buffer2)) {
        throw new TypeError('"buffer" is not a Buffer');
      }
      debug2("write", buffer2.length, "bytes");
      if (!this.isOpen) {
        debug2("write", "error port is not open");
        throw new Error("Port is not open");
      }
      this.writeOperation = (async () => {
        if (buffer2.length === 0) {
          return;
        }
        await (0, load_bindings_12.asyncWrite)(this.fd, buffer2);
        this.writeOperation = null;
      })();
      return this.writeOperation;
    }
    async update(options) {
      if (!options || typeof options !== "object" || Array.isArray(options)) {
        throw TypeError('"options" is not an object');
      }
      if (typeof options.baudRate !== "number") {
        throw new TypeError('"options.baudRate" is not a number');
      }
      debug2("update");
      if (!this.isOpen) {
        throw new Error("Port is not open");
      }
      await (0, load_bindings_12.asyncUpdate)(this.fd, options);
    }
    async set(options) {
      if (!options || typeof options !== "object" || Array.isArray(options)) {
        throw new TypeError('"options" is not an object');
      }
      debug2("set", options);
      if (!this.isOpen) {
        throw new Error("Port is not open");
      }
      await (0, load_bindings_12.asyncSet)(this.fd, options);
    }
    async get() {
      debug2("get");
      if (!this.isOpen) {
        throw new Error("Port is not open");
      }
      return (0, load_bindings_12.asyncGet)(this.fd);
    }
    async getBaudRate() {
      debug2("getBaudRate");
      if (!this.isOpen) {
        throw new Error("Port is not open");
      }
      return (0, load_bindings_12.asyncGetBaudRate)(this.fd);
    }
    async flush() {
      debug2("flush");
      if (!this.isOpen) {
        throw new Error("Port is not open");
      }
      await (0, load_bindings_12.asyncFlush)(this.fd);
    }
    async drain() {
      debug2("drain");
      if (!this.isOpen) {
        throw new Error("Port is not open");
      }
      await this.writeOperation;
      await (0, load_bindings_12.asyncDrain)(this.fd);
    }
  }
  win32.WindowsPortBinding = WindowsPortBinding;
  return win32;
}
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist)
    return dist$3;
  hasRequiredDist = 1;
  (function(exports2) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.autoDetect = void 0;
    const debug_12 = __importDefault2(srcExports);
    const darwin_1 = darwin;
    const linux_1 = linux;
    const win32_1 = requireWin32();
    const debug2 = (0, debug_12.default)("serialport/bindings-cpp");
    __exportStar2(dist, exports2);
    __exportStar2(darwin, exports2);
    __exportStar2(linux, exports2);
    __exportStar2(requireWin32(), exports2);
    __exportStar2(errors, exports2);
    function autoDetect() {
      switch (process.platform) {
        case "win32":
          debug2("loading WindowsBinding");
          return win32_1.WindowsBinding;
        case "darwin":
          debug2("loading DarwinBinding");
          return darwin_1.DarwinBinding;
        default:
          debug2("loading LinuxBinding");
          return linux_1.LinuxBinding;
      }
    }
    exports2.autoDetect = autoDetect;
  })(dist$3);
  return dist$3;
}
Object.defineProperty(serialport, "__esModule", { value: true });
serialport.SerialPort = void 0;
const stream_1 = dist$5;
const bindings_cpp_1 = requireDist();
const DetectedBinding = (0, bindings_cpp_1.autoDetect)();
class SerialPort extends stream_1.SerialPortStream {
  static list = DetectedBinding.list;
  static binding = DetectedBinding;
  constructor(options, openCallback) {
    const opts = {
      binding: DetectedBinding,
      ...options
    };
    super(opts, openCallback);
  }
}
serialport.SerialPort = SerialPort;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding2(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar2(dist$f, exports2);
  __exportStar2(dist$e, exports2);
  __exportStar2(dist$d, exports2);
  __exportStar2(dist$c, exports2);
  __exportStar2(dist$b, exports2);
  __exportStar2(dist$a, exports2);
  __exportStar2(dist$9, exports2);
  __exportStar2(dist$8, exports2);
  __exportStar2(dist$7, exports2);
  __exportStar2(dist$6, exports2);
  __exportStar2(serialportMock, exports2);
  __exportStar2(serialport, exports2);
})(dist$g);
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators2, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i = decorators2.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators2[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
let SerialPortService = class {
  constructor(configService2, httpService) {
    this.configService = configService2;
    this.httpService = httpService;
    this.serialPort = null;
    this.isConnected = false;
  }
  async listPorts() {
    try {
      const ports2 = await dist$g.SerialPort.list();
      return ports2.map((port) => ({
        path: port.path,
        manufacturer: port.manufacturer,
        productId: port.productId,
        vendorId: port.vendorId
      }));
    } catch (error2) {
      console.error("Error listing ports:", error2);
      this.sendLog("error", `: ${error2.message}`);
      return [];
    }
  }
  async connect() {
    if (this.isConnected) {
      await this.disconnect();
    }
    try {
      const serialConfig = this.configService.getSerialConfig();
      if (!serialConfig.port) {
        throw new Error("");
      }
      this.sendLog("info", ` ${serialConfig.port} (${serialConfig.baudRate}, ${serialConfig.dataBits}, ${serialConfig.stopBits}, ${serialConfig.parity})...`);
      this.serialPort = new dist$g.SerialPort({
        path: serialConfig.port,
        baudRate: serialConfig.baudRate,
        dataBits: serialConfig.dataBits,
        stopBits: serialConfig.stopBits,
        parity: serialConfig.parity
      });
      this.serialPort.on("open", () => {
        this.isConnected = true;
        this.sendStatusUpdate("connected");
        this.sendLog("success", "");
      });
      this.serialPort.on("data", (data) => {
        this.sendLog("data", `: ${data.toString("hex")}`);
        this.httpService.sendData(data);
      });
      this.serialPort.on("error", (error2) => {
        this.sendLog("error", `: ${error2.message}`);
        this.sendStatusUpdate("error");
        this.isConnected = false;
      });
      this.serialPort.on("close", () => {
        this.isConnected = false;
        this.sendStatusUpdate("disconnected");
        this.sendLog("info", "");
      });
      return true;
    } catch (error2) {
      console.error("Connection error:", error2);
      this.sendLog("error", `: ${error2.message}`);
      this.sendStatusUpdate("error");
      return false;
    }
  }
  async disconnect() {
    if (this.serialPort && this.isConnected) {
      this.serialPort.close((err) => {
        if (err) {
          console.error("Error closing port:", err);
          this.sendLog("error", `: ${err.message}`);
        }
      });
      this.serialPort = null;
      this.isConnected = false;
      this.sendStatusUpdate("disconnected");
    }
  }
  getStatus() {
    if (this.isConnected) {
      const config2 = this.configService.getSerialConfig();
      return `connected (${config2.port})`;
    }
    return this.serialPort ? "connecting" : "disconnected";
  }
  sendStatusUpdate(status) {
    if (exports.mainWindow) {
      exports.mainWindow.webContents.send("serial-status-update", status);
    }
  }
  sendLog(type2, message) {
    if (exports.mainWindow) {
      exports.mainWindow.webContents.send("new-log-entry", {
        type: type2,
        message,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  }
};
SerialPortService = __decorateClass$2([
  commonExports.Injectable()
], SerialPortService);
function bind2(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const { iterator, toStringTag: toStringTag$1 } = Symbol;
const kindOf = ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$2 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag$1 in val) && !(iterator in val);
};
const isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer$1(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    return false;
  }
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction$2(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    if (isBuffer$1(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer$1(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$2(val)) {
      a[key] = bind2(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray2) => {
  return (thing) => {
    return TypedArray2 && thing instanceof TypedArray2;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$2(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$2(thing.append) && thing[toStringTag$1] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source2, i) => {
    if (isObject(source2)) {
      if (stack.indexOf(source2) >= 0) {
        return;
      }
      if (isBuffer$1(source2)) {
        return source2;
      }
      if (!("toJSON" in source2)) {
        stack[i] = source2;
        const target = isArray(source2) ? [] : {};
        forEach(source2, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source2;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source: source2, data }) => {
      if (source2 === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$2(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction$2(thing[iterator]);
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError$1(message, code2, config2, request2, response2) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  if (response2) {
    this.response = response2;
    this.status = response2.status ? response2.status : null;
  }
}
utils$1.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error2, code2, config2, request2, response2, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error2, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error2 && error2.message ? error2.message : "Error";
  const errCode = code2 == null && error2 ? error2.code : code2;
  AxiosError$1.call(axiosError, msg, errCode, config2, request2, response2);
  if (error2 && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error2, configurable: true });
  }
  axiosError.name = error2 && error2.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var Stream$2 = require$$0$4.Stream;
var util$2 = require$$1$1;
var delayed_stream = DelayedStream$1;
function DelayedStream$1() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;
  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$2.inherits(DelayedStream$1, Stream$2);
DelayedStream$1.create = function(source2, options) {
  var delayedStream = new this();
  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }
  delayedStream.source = source2;
  var realEmit = source2.emit;
  source2.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source2, arguments);
  };
  source2.on("error", function() {
  });
  if (delayedStream.pauseStream) {
    source2.pause();
  }
  return delayedStream;
};
Object.defineProperty(DelayedStream$1.prototype, "readable", {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});
DelayedStream$1.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream$1.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }
  this.source.resume();
};
DelayedStream$1.prototype.pause = function() {
  this.source.pause();
};
DelayedStream$1.prototype.release = function() {
  this._released = true;
  this._bufferedEvents.forEach(function(args2) {
    this.emit.apply(this, args2);
  }.bind(this));
  this._bufferedEvents = [];
};
DelayedStream$1.prototype.pipe = function() {
  var r = Stream$2.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};
DelayedStream$1.prototype._handleEmit = function(args2) {
  if (this._released) {
    this.emit.apply(this, args2);
    return;
  }
  if (args2[0] === "data") {
    this.dataSize += args2[1].length;
    this._checkIfMaxDataSizeExceeded();
  }
  this._bufferedEvents.push(args2);
};
DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  this._maxDataSizeExceeded = true;
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this.emit("error", new Error(message));
};
var util$1 = require$$1$1;
var Stream$1 = require$$0$4.Stream;
var DelayedStream = delayed_stream;
var combined_stream = CombinedStream$1;
function CombinedStream$1() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;
  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$1.inherits(CombinedStream$1, Stream$1);
CombinedStream$1.create = function(options) {
  var combinedStream = new this();
  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }
  return combinedStream;
};
CombinedStream$1.isStreamLike = function(stream2) {
  return typeof stream2 !== "function" && typeof stream2 !== "string" && typeof stream2 !== "boolean" && typeof stream2 !== "number" && !Buffer.isBuffer(stream2);
};
CombinedStream$1.prototype.append = function(stream2) {
  var isStreamLike = CombinedStream$1.isStreamLike(stream2);
  if (isStreamLike) {
    if (!(stream2 instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream2, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams
      });
      stream2.on("data", this._checkDataSize.bind(this));
      stream2 = newStream;
    }
    this._handleErrors(stream2);
    if (this.pauseStreams) {
      stream2.pause();
    }
  }
  this._streams.push(stream2);
  return this;
};
CombinedStream$1.prototype.pipe = function(dest, options) {
  Stream$1.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};
CombinedStream$1.prototype._getNext = function() {
  this._currentStream = null;
  if (this._insideLoop) {
    this._pendingNext = true;
    return;
  }
  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};
CombinedStream$1.prototype._realGetNext = function() {
  var stream2 = this._streams.shift();
  if (typeof stream2 == "undefined") {
    this.end();
    return;
  }
  if (typeof stream2 !== "function") {
    this._pipeNext(stream2);
    return;
  }
  var getStream = stream2;
  getStream(function(stream3) {
    var isStreamLike = CombinedStream$1.isStreamLike(stream3);
    if (isStreamLike) {
      stream3.on("data", this._checkDataSize.bind(this));
      this._handleErrors(stream3);
    }
    this._pipeNext(stream3);
  }.bind(this));
};
CombinedStream$1.prototype._pipeNext = function(stream2) {
  this._currentStream = stream2;
  var isStreamLike = CombinedStream$1.isStreamLike(stream2);
  if (isStreamLike) {
    stream2.on("end", this._getNext.bind(this));
    stream2.pipe(this, { end: false });
    return;
  }
  var value = stream2;
  this.write(value);
  this._getNext();
};
CombinedStream$1.prototype._handleErrors = function(stream2) {
  var self2 = this;
  stream2.on("error", function(err) {
    self2._emitError(err);
  });
};
CombinedStream$1.prototype.write = function(data) {
  this.emit("data", data);
};
CombinedStream$1.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
    this._currentStream.pause();
  this.emit("pause");
};
CombinedStream$1.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
    this._currentStream.resume();
  this.emit("resume");
};
CombinedStream$1.prototype.end = function() {
  this._reset();
  this.emit("end");
};
CombinedStream$1.prototype.destroy = function() {
  this._reset();
  this.emit("close");
};
CombinedStream$1.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};
CombinedStream$1.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this._emitError(new Error(message));
};
CombinedStream$1.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var self2 = this;
  this._streams.forEach(function(stream2) {
    if (!stream2.dataSize) {
      return;
    }
    self2.dataSize += stream2.dataSize;
  });
  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};
CombinedStream$1.prototype._emitError = function(err) {
  this._reset();
  this.emit("error", err);
};
var defer_1 = defer$1;
function defer$1(fn) {
  var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  if (nextTick) {
    nextTick(fn);
  } else {
    setTimeout(fn, 0);
  }
}
var defer = defer_1;
var async_1 = async$2;
function async$2(callback) {
  var isAsync = false;
  defer(function() {
    isAsync = true;
  });
  return function async_callback(err, result) {
    if (isAsync) {
      callback(err, result);
    } else {
      defer(function nextTick_callback() {
        callback(err, result);
      });
    }
  };
}
var abort_1 = abort$2;
function abort$2(state2) {
  Object.keys(state2.jobs).forEach(clean.bind(state2));
  state2.jobs = {};
}
function clean(key) {
  if (typeof this.jobs[key] == "function") {
    this.jobs[key]();
  }
}
var async$1 = async_1, abort$1 = abort_1;
var iterate_1 = iterate$2;
function iterate$2(list, iterator2, state2, callback) {
  var key = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
  state2.jobs[key] = runJob(iterator2, key, list[key], function(error2, output) {
    if (!(key in state2.jobs)) {
      return;
    }
    delete state2.jobs[key];
    if (error2) {
      abort$1(state2);
    } else {
      state2.results[key] = output;
    }
    callback(error2, state2.results);
  });
}
function runJob(iterator2, key, item, callback) {
  var aborter;
  if (iterator2.length == 2) {
    aborter = iterator2(item, async$1(callback));
  } else {
    aborter = iterator2(item, key, async$1(callback));
  }
  return aborter;
}
var state_1 = state;
function state(list, sortMethod) {
  var isNamedList = !Array.isArray(list), initState2 = {
    index: 0,
    keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
    jobs: {},
    results: isNamedList ? {} : [],
    size: isNamedList ? Object.keys(list).length : list.length
  };
  if (sortMethod) {
    initState2.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
      return sortMethod(list[a], list[b]);
    });
  }
  return initState2;
}
var abort = abort_1, async = async_1;
var terminator_1 = terminator$2;
function terminator$2(callback) {
  if (!Object.keys(this.jobs).length) {
    return;
  }
  this.index = this.size;
  abort(this);
  async(callback)(null, this.results);
}
var iterate$1 = iterate_1, initState$1 = state_1, terminator$1 = terminator_1;
var parallel_1 = parallel;
function parallel(list, iterator2, callback) {
  var state2 = initState$1(list);
  while (state2.index < (state2["keyedList"] || list).length) {
    iterate$1(list, iterator2, state2, function(error2, result) {
      if (error2) {
        callback(error2, result);
        return;
      }
      if (Object.keys(state2.jobs).length === 0) {
        callback(null, state2.results);
        return;
      }
    });
    state2.index++;
  }
  return terminator$1.bind(state2, callback);
}
var serialOrdered$2 = { exports: {} };
var iterate = iterate_1, initState = state_1, terminator = terminator_1;
serialOrdered$2.exports = serialOrdered$1;
serialOrdered$2.exports.ascending = ascending;
serialOrdered$2.exports.descending = descending;
function serialOrdered$1(list, iterator2, sortMethod, callback) {
  var state2 = initState(list, sortMethod);
  iterate(list, iterator2, state2, function iteratorHandler(error2, result) {
    if (error2) {
      callback(error2, result);
      return;
    }
    state2.index++;
    if (state2.index < (state2["keyedList"] || list).length) {
      iterate(list, iterator2, state2, iteratorHandler);
      return;
    }
    callback(null, state2.results);
  });
  return terminator.bind(state2, callback);
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function descending(a, b) {
  return -1 * ascending(a, b);
}
var serialOrderedExports = serialOrdered$2.exports;
var serialOrdered = serialOrderedExports;
var serial_1 = serial;
function serial(list, iterator2, callback) {
  return serialOrdered(list, iterator2, null, callback);
}
var asynckit$1 = {
  parallel: parallel_1,
  serial: serial_1,
  serialOrdered: serialOrderedExports
};
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var GetIntrinsic2 = getIntrinsic;
var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
var hasToStringTag = requireShams()();
var hasOwn$1 = hasown;
var $TypeError = type$4;
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
var esSetTostringtag = function setToStringTag(object, value) {
  var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
  var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
    throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  }
  if (toStringTag && (overrideIfSet || !hasOwn$1(object, toStringTag))) {
    if ($defineProperty) {
      $defineProperty(object, toStringTag, {
        configurable: !nonConfigurable,
        enumerable: false,
        value,
        writable: false
      });
    } else {
      object[toStringTag] = value;
    }
  }
};
var populate$1 = function(dst, src2) {
  Object.keys(src2).forEach(function(prop) {
    dst[prop] = dst[prop] || src2[prop];
  });
  return dst;
};
var CombinedStream = combined_stream;
var util = require$$1$1;
var path = require$$0$6;
var http$1 = require$$7$2;
var https$1 = require$$8$1;
var parseUrl$2 = require$$0$a.parse;
var fs = require$$1$3;
var Stream = require$$0$4.Stream;
var crypto$1 = require$$0$5;
var mime = mimeTypes;
var asynckit = asynckit$1;
var setToStringTag2 = esSetTostringtag;
var hasOwn = hasown;
var populate = populate$1;
function FormData$1(options) {
  if (!(this instanceof FormData$1)) {
    return new FormData$1(options);
  }
  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];
  CombinedStream.call(this);
  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}
util.inherits(FormData$1, CombinedStream);
FormData$1.LINE_BREAK = "\r\n";
FormData$1.DEFAULT_CONTENT_TYPE = "application/octet-stream";
FormData$1.prototype.append = function(field, value, options) {
  options = options || {};
  if (typeof options === "string") {
    options = { filename: options };
  }
  var append2 = CombinedStream.prototype.append.bind(this);
  if (typeof value === "number" || value == null) {
    value = String(value);
  }
  if (Array.isArray(value)) {
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();
  append2(header);
  append2(value);
  append2(footer);
  this._trackLength(header, value, options);
};
FormData$1.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;
  if (options.knownLength != null) {
    valueLength += Number(options.knownLength);
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === "string") {
    valueLength = Buffer.byteLength(value);
  }
  this._valueLength += valueLength;
  this._overheadLength += Buffer.byteLength(header) + FormData$1.LINE_BREAK.length;
  if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
    return;
  }
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};
FormData$1.prototype._lengthRetriever = function(value, callback) {
  if (hasOwn(value, "fd")) {
    if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
      callback(null, value.end + 1 - (value.start ? value.start : 0));
    } else {
      fs.stat(value.path, function(err, stat) {
        if (err) {
          callback(err);
          return;
        }
        var fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }
  } else if (hasOwn(value, "httpVersion")) {
    callback(null, Number(value.headers["content-length"]));
  } else if (hasOwn(value, "httpModule")) {
    value.on("response", function(response2) {
      value.pause();
      callback(null, Number(response2.headers["content-length"]));
    });
    value.resume();
  } else {
    callback("Unknown stream");
  }
};
FormData$1.prototype._multiPartHeader = function(field, value, options) {
  if (typeof options.header === "string") {
    return options.header;
  }
  var contentDisposition2 = this._getContentDisposition(value, options);
  var contentType2 = this._getContentType(value, options);
  var contents = "";
  var headers = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition2 || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(contentType2 || [])
  };
  if (typeof options.header === "object") {
    populate(headers, options.header);
  }
  var header;
  for (var prop in headers) {
    if (hasOwn(headers, prop)) {
      header = headers[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData$1.LINE_BREAK;
      }
    }
  }
  return "--" + this.getBoundary() + FormData$1.LINE_BREAK + contents + FormData$1.LINE_BREAK;
};
FormData$1.prototype._getContentDisposition = function(value, options) {
  var filename;
  if (typeof options.filepath === "string") {
    filename = path.normalize(options.filepath).replace(/\\/g, "/");
  } else if (options.filename || value && (value.name || value.path)) {
    filename = path.basename(options.filename || value && (value.name || value.path));
  } else if (value && value.readable && hasOwn(value, "httpVersion")) {
    filename = path.basename(value.client._httpMessage.path || "");
  }
  if (filename) {
    return 'filename="' + filename + '"';
  }
};
FormData$1.prototype._getContentType = function(value, options) {
  var contentType2 = options.contentType;
  if (!contentType2 && value && value.name) {
    contentType2 = mime.lookup(value.name);
  }
  if (!contentType2 && value && value.path) {
    contentType2 = mime.lookup(value.path);
  }
  if (!contentType2 && value && value.readable && hasOwn(value, "httpVersion")) {
    contentType2 = value.headers["content-type"];
  }
  if (!contentType2 && (options.filepath || options.filename)) {
    contentType2 = mime.lookup(options.filepath || options.filename);
  }
  if (!contentType2 && value && typeof value === "object") {
    contentType2 = FormData$1.DEFAULT_CONTENT_TYPE;
  }
  return contentType2;
};
FormData$1.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData$1.LINE_BREAK;
    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }
    next(footer);
  }.bind(this);
};
FormData$1.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + FormData$1.LINE_BREAK;
};
FormData$1.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (header in userHeaders) {
    if (hasOwn(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }
  return formHeaders;
};
FormData$1.prototype.setBoundary = function(boundary) {
  if (typeof boundary !== "string") {
    throw new TypeError("FormData boundary must be a string");
  }
  this._boundary = boundary;
};
FormData$1.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }
  return this._boundary;
};
FormData$1.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== "function") {
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }
      if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$1.LINE_BREAK)]);
      }
    }
  }
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};
FormData$1.prototype._generateBoundary = function() {
  this._boundary = "--------------------------" + crypto$1.randomBytes(12).toString("hex");
};
FormData$1.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this.hasKnownLength()) {
    this._error(new Error("Cannot calculate proper length in synchronous way."));
  }
  return knownLength;
};
FormData$1.prototype.hasKnownLength = function() {
  var hasKnownLength = true;
  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }
  return hasKnownLength;
};
FormData$1.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }
  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }
    values.forEach(function(length) {
      knownLength += length;
    });
    cb(null, knownLength);
  });
};
FormData$1.prototype.submit = function(params, cb) {
  var request2;
  var options;
  var defaults2 = { method: "post" };
  if (typeof params === "string") {
    params = parseUrl$2(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults2);
  } else {
    options = populate(params, defaults2);
    if (!options.port) {
      options.port = options.protocol === "https:" ? 443 : 80;
    }
  }
  options.headers = this.getHeaders(params.headers);
  if (options.protocol === "https:") {
    request2 = https$1.request(options);
  } else {
    request2 = http$1.request(options);
  }
  this.getLength(function(err, length) {
    if (err && err !== "Unknown stream") {
      this._error(err);
      return;
    }
    if (length) {
      request2.setHeader("Content-Length", length);
    }
    this.pipe(request2);
    if (cb) {
      var onResponse;
      var callback = function(error2, responce) {
        request2.removeListener("error", callback);
        request2.removeListener("response", onResponse);
        return cb.call(this, error2, responce);
      };
      onResponse = callback.bind(this, null);
      request2.on("error", callback);
      request2.on("response", onResponse);
    }
  }.bind(this));
  return request2;
};
FormData$1.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit("error", err);
  }
};
FormData$1.prototype.toString = function() {
  return "[object FormData]";
};
setToStringTag2(FormData$1, "FormData");
var form_data = FormData$1;
const FormData$2 = /* @__PURE__ */ getDefaultExportFromCjs(form_data);
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData$2 || FormData)();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source2) {
    return !utils$1.isUndefined(source2[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (utils$1.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder2) {
  const _encode = encoder2 ? function(value) {
    return encoder2.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams = require$$0$a.URLSearchParams;
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  require$$0$5.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }
  return str;
};
const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData$2,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform.classes.URLSearchParams(), {
    visitor: function(value, key, path2, helpers2) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers2.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder2) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType2 = headers.getContentType() || "";
    const hasJSONContentType = contentType2.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType2.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType2.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils$1.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$1.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$1.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$1);
const AxiosHeaders$2 = AxiosHeaders$1;
function transformData(fns, response2) {
  const config2 = this || defaults$1;
  const context = response2 || config2;
  const headers = AxiosHeaders$2.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response2 ? response2.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config2, request2) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve2, reject, response2) {
  const validateStatus2 = response2.config.validateStatus;
  if (!response2.status || !validateStatus2 || validateStatus2(response2.status)) {
    resolve2(response2);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response2.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response2.status / 100) - 4],
      response2.config,
      response2.request,
      response2
    ));
  }
}
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var proxyFromEnv = {};
var parseUrl$1 = require$$0$a.parse;
var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
function getProxyForUrl(url2) {
  var parsedUrl = typeof url2 === "string" ? parseUrl$1(url2) : url2 || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
    return "";
  }
  proto = proto.split(":", 1)[0];
  hostname = hostname.replace(/:\d*$/, "");
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return "";
  }
  var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
  if (proxy && proxy.indexOf("://") === -1) {
    proxy = proto + "://" + proxy;
  }
  return proxy;
}
function shouldProxy(hostname, port) {
  var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
  if (!NO_PROXY) {
    return true;
  }
  if (NO_PROXY === "*") {
    return false;
  }
  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;
    }
    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname !== parsedProxyHostname;
    }
    if (parsedProxyHostname.charAt(0) === "*") {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
}
proxyFromEnv.getProxyForUrl = getProxyForUrl;
var followRedirects$1 = { exports: {} };
var debug$1;
var debug_1 = function() {
  if (!debug$1) {
    try {
      debug$1 = requireSrc()("follow-redirects");
    } catch (error2) {
    }
    if (typeof debug$1 !== "function") {
      debug$1 = function() {
      };
    }
  }
  debug$1.apply(null, arguments);
};
var url = require$$0$a;
var URL$1 = url.URL;
var http = require$$7$2;
var https = require$$8$1;
var Writable = require$$0$4.Writable;
var assert = require$$4$2;
var debug = debug_1;
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction$1(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
})();
var useNativeURL = false;
try {
  assert(new URL$1(""));
} catch (error2) {
  useNativeURL = error2.code === "ERR_INVALID_URL";
}
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
];
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = /* @__PURE__ */ Object.create(null);
events.forEach(function(event) {
  eventHandlers[event] = function(arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);
var destroy = Writable.prototype.destroy || noop;
function RedirectableRequest(options, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response2) {
    try {
      self2._processResponse(response2);
    } catch (cause) {
      self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
    }
  };
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error2) {
  destroyRequest(this._currentRequest, error2);
  destroy.call(this, error2);
  return this;
};
RedirectableRequest.prototype.write = function(data, encoding2, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction$1(encoding2)) {
    callback = encoding2;
    encoding2 = null;
  }
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data, encoding: encoding2 });
    this._currentRequest.write(data, encoding2, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};
RedirectableRequest.prototype.end = function(data, encoding2, callback) {
  if (isFunction$1(data)) {
    callback = data;
    data = encoding2 = null;
  } else if (isFunction$1(encoding2)) {
    callback = encoding2;
    encoding2 = null;
  }
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  } else {
    var self2 = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding2, function() {
      self2._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};
RedirectableRequest.prototype.setHeader = function(name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};
RedirectableRequest.prototype.removeHeader = function(name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
  var self2 = this;
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }
  function startTimer(socket) {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
    }
    self2._timeout = setTimeout(function() {
      self2.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }
  function clearTimer() {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
      self2._timeout = null;
    }
    self2.removeListener("abort", clearTimer);
    self2.removeListener("error", clearTimer);
    self2.removeListener("response", clearTimer);
    self2.removeListener("close", clearTimer);
    if (callback) {
      self2.removeListener("timeout", callback);
    }
    if (!self2.socket) {
      self2._currentRequest.removeListener("socket", startTimer);
    }
  }
  if (callback) {
    this.on("timeout", callback);
  }
  if (this.socket) {
    startTimer(this.socket);
  } else {
    this._currentRequest.once("socket", startTimer);
  }
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);
  return this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(method) {
  RedirectableRequest.prototype[method] = function(a, b) {
    return this._currentRequest[method](a, b);
  };
});
["aborted", "connection", "socket"].forEach(function(property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function() {
      return this._currentRequest[property];
    }
  });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
  if (!options.headers) {
    options.headers = {};
  }
  if (options.host) {
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};
RedirectableRequest.prototype._performRequest = function() {
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }
  var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  request2._redirectable = this;
  for (var event of events) {
    request2.on(event, eventHandlers[event]);
  }
  this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
    // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path
  );
  if (this._isRedirect) {
    var i = 0;
    var self2 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error2) {
      if (request2 === self2._currentRequest) {
        if (error2) {
          self2.emit("error", error2);
        } else if (i < buffers.length) {
          var buffer2 = buffers[i++];
          if (!request2.finished) {
            request2.write(buffer2.data, buffer2.encoding, writeNext);
          }
        } else if (self2._ended) {
          request2.end();
        }
      }
    })();
  }
};
RedirectableRequest.prototype._processResponse = function(response2) {
  var statusCode = response2.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response2.headers,
      statusCode
    });
  }
  var location = response2.headers.location;
  if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
    response2.responseUrl = this._currentUrl;
    response2.redirects = this._redirects;
    this.emit("response", response2);
    this._requestBodyBuffers = [];
    return;
  }
  destroyRequest(this._currentRequest);
  response2.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response2.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource []
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) []
  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);
  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }
  if (isFunction$1(beforeRedirect)) {
    var responseDetails = {
      headers: response2.headers,
      statusCode
    };
    var requestDetails = {
      url: currentUrl,
      method,
      headers: requestHeaders
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function wrap(protocols) {
  var exports2 = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
    function request2(input, options, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      } else {
        callback = options;
        options = validateUrl(input);
        input = { protocol };
      }
      if (isFunction$1(options)) {
        callback = options;
        options = null;
      }
      options = Object.assign({
        maxRedirects: exports2.maxRedirects,
        maxBodyLength: exports2.maxBodyLength
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }
      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }
    function get2(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request2, configurable: true, enumerable: true, writable: true },
      get: { value: get2, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports2;
}
function noop() {
}
function parseUrl(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$1(input);
  } else {
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative, base) {
  return useNativeURL ? new URL$1(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread2 = target || {};
  for (var key of preservedUrlFields) {
    spread2[key] = urlObject[key];
  }
  if (spread2.hostname.startsWith("[")) {
    spread2.hostname = spread2.hostname.slice(1, -1);
  }
  if (spread2.port !== "") {
    spread2.port = Number(spread2.port);
  }
  spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
  return spread2;
}
function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code2, message, baseClass) {
  function CustomError(properties2) {
    if (isFunction$1(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties2 || {});
    this.code = code2;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false
    },
    name: {
      value: "Error [" + code2 + "]",
      enumerable: false
    }
  });
  return CustomError;
}
function destroyRequest(request2, error2) {
  for (var event of events) {
    request2.removeListener(event, eventHandlers[event]);
  }
  request2.on("error", noop);
  request2.destroy(error2);
}
function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isFunction$1(value) {
  return typeof value === "function";
}
function isBuffer(value) {
  return typeof value === "object" && "length" in value;
}
function isURL(value) {
  return URL$1 && value instanceof URL$1;
}
followRedirects$1.exports = wrap({ http, https });
followRedirects$1.exports.wrap = wrap;
var followRedirectsExports = followRedirects$1.exports;
const followRedirects = /* @__PURE__ */ getDefaultExportFromCjs(followRedirectsExports);
const VERSION$1 = "1.13.2";
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
    const match = DATA_URL_PATTERN.exec(uri2);
    if (!match) {
      throw new AxiosError$1("Invalid URL", AxiosError$1.ERR_INVALID_URL);
    }
    const mime2 = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer2 = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError$1("Blob is not supported", AxiosError$1.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer2], { type: mime2 });
    }
    return buffer2;
  }
  throw new AxiosError$1("Unsupported protocol " + protocol, AxiosError$1.ERR_NOT_SUPPORT);
}
const kInternals = Symbol("internals");
class AxiosTransformStream extends require$$0$4.Transform {
  constructor(options) {
    options = utils$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source2) => {
      return !utils$1.isUndefined(source2[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding2, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes2 = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes2;
      internals.bytes += bytes2;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
const AxiosTransformStream$1 = AxiosTransformStream;
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const readBlob$1 = readBlob;
const BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new require$$1$1.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils$1.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils$1.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob$1(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$1.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils$1.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return require$$0$4.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
const formDataToStream$1 = formDataToStream;
class ZlibHeaderTransformStream extends require$$0$4.Transform {
  __transform(chunk, encoding2, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding2, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding2);
      }
    }
    this.__transform(chunk, encoding2, callback);
  }
}
const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
const callbackify = (fn, reducer) => {
  return utils$1.isAsyncFn(fn) ? function(...args2) {
    const cb = args2.pop();
    fn.apply(this, args2).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
const callbackify$1 = callbackify;
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes2[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer2;
  const invoke = (args2, now = Date.now()) => {
    timestamp2 = now;
    lastArgs = null;
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
    fn(...args2);
  };
  const throttled = (...args2) => {
    const now = Date.now();
    const passed = now - timestamp2;
    if (passed >= threshold) {
      invoke(args2, now);
    } else {
      lastArgs = args2;
      if (!timer2) {
        timer2 = setTimeout(() => {
          timer2 = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args2) => utils$1.asap(() => fn(...args2));
function estimateDataURLDecodedBytes(url2) {
  if (!url2 || typeof url2 !== "string")
    return 0;
  if (!url2.startsWith("data:"))
    return 0;
  const comma = url2.indexOf(",");
  if (comma < 0)
    return 0;
  const meta = url2.slice(5, comma);
  const body = url2.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);
  if (isBase64) {
    let effectiveLen = body.length;
    const len = body.length;
    for (let i = 0; i < len; i++) {
      if (body.charCodeAt(i) === 37 && i + 2 < len) {
        const a = body.charCodeAt(i + 1);
        const b = body.charCodeAt(i + 2);
        const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
        if (isHex) {
          effectiveLen -= 2;
          i += 2;
        }
      }
    }
    let pad = 0;
    let idx = len - 1;
    const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
    body.charCodeAt(j - 1) === 51 && // '3'
    (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
    if (idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }
    if (pad === 1 && idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }
    const groups = Math.floor(effectiveLen / 4);
    const bytes2 = groups * 3 - (pad || 0);
    return bytes2 > 0 ? bytes2 : 0;
  }
  return Buffer.byteLength(body, "utf8");
}
const zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$1.isFunction(zlib.createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = followRedirects;
const isHttps = /https:?/;
const supportedProtocols = platform.protocols.map((protocol) => {
  return protocol + ":";
});
const flushOnFinish = (stream2, [throttled, flush]) => {
  stream2.on("end", flush).on("error", flush);
  return throttled;
};
class Http2Sessions {
  constructor() {
    this.sessions = /* @__PURE__ */ Object.create(null);
  }
  getSession(authority, options) {
    options = Object.assign({
      sessionTimeout: 1e3
    }, options);
    let authoritySessions = this.sessions[authority];
    if (authoritySessions) {
      let len = authoritySessions.length;
      for (let i = 0; i < len; i++) {
        const [sessionHandle, sessionOptions] = authoritySessions[i];
        if (!sessionHandle.destroyed && !sessionHandle.closed && require$$1$1.isDeepStrictEqual(sessionOptions, options)) {
          return sessionHandle;
        }
      }
    }
    const session = http2.connect(authority, options);
    let removed;
    const removeSession = () => {
      if (removed) {
        return;
      }
      removed = true;
      let entries = authoritySessions, len = entries.length, i = len;
      while (i--) {
        if (entries[i][0] === session) {
          if (len === 1) {
            delete this.sessions[authority];
          } else {
            entries.splice(i, 1);
          }
          return;
        }
      }
    };
    const originalRequestFn = session.request;
    const { sessionTimeout } = options;
    if (sessionTimeout != null) {
      let timer2;
      let streamsCount = 0;
      session.request = function() {
        const stream2 = originalRequestFn.apply(this, arguments);
        streamsCount++;
        if (timer2) {
          clearTimeout(timer2);
          timer2 = null;
        }
        stream2.once("close", () => {
          if (!--streamsCount) {
            timer2 = setTimeout(() => {
              timer2 = null;
              removeSession();
            }, sessionTimeout);
          }
        });
        return stream2;
      };
    }
    session.once("close", removeSession);
    let entry = [
      session,
      options
    ];
    authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [entry];
    return session;
  }
}
const http2Sessions = new Http2Sessions();
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve2, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve2(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({ address, family }) => {
  if (!utils$1.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
const http2Transport = {
  request(options, cb) {
    const authority = options.protocol + "//" + options.hostname + ":" + (options.port || 80);
    const { http2Options, headers } = options;
    const session = http2Sessions.getSession(authority, http2Options);
    const {
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_STATUS
    } = http2.constants;
    const http2Headers = {
      [HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
      [HTTP2_HEADER_METHOD]: options.method,
      [HTTP2_HEADER_PATH]: options.path
    };
    utils$1.forEach(headers, (header, name) => {
      name.charAt(0) !== ":" && (http2Headers[name] = header);
    });
    const req = session.request(http2Headers);
    req.once("response", (responseHeaders) => {
      const response2 = req;
      responseHeaders = Object.assign({}, responseHeaders);
      const status = responseHeaders[HTTP2_HEADER_STATUS];
      delete responseHeaders[HTTP2_HEADER_STATUS];
      response2.headers = responseHeaders;
      response2.statusCode = +status;
      cb(response2);
    });
    return req;
  }
};
const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config2) {
  return wrapAsync(async function dispatchHttpRequest(resolve2, reject, onDone) {
    let { data, lookup, family, httpVersion = 1, http2Options } = config2;
    const { responseType, responseEncoding } = config2;
    const method = config2.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    httpVersion = +httpVersion;
    if (Number.isNaN(httpVersion)) {
      throw TypeError(`Invalid protocol version: '${config2.httpVersion}' is not a number`);
    }
    if (httpVersion !== 1 && httpVersion !== 2) {
      throw TypeError(`Unsupported protocol version '${httpVersion}'`);
    }
    const isHttp2 = httpVersion === 2;
    if (lookup) {
      const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const abortEmitter = new require$$0$8.EventEmitter();
    function abort2(reason) {
      try {
        abortEmitter.emit("abort", !reason || reason.type ? new CanceledError$1(null, config2, req) : reason);
      } catch (err) {
        console.warn("emit error", err);
      }
    }
    abortEmitter.once("abort", reject);
    const onFinished2 = () => {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(abort2);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", abort2);
      }
      abortEmitter.removeAllListeners();
    };
    if (config2.cancelToken || config2.signal) {
      config2.cancelToken && config2.cancelToken.subscribe(abort2);
      if (config2.signal) {
        config2.signal.aborted ? abort2() : config2.signal.addEventListener("abort", abort2);
      }
    }
    onDone((response2, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished2();
        return;
      }
      const { data: data2 } = response2;
      if (data2 instanceof require$$0$4.Readable || data2 instanceof require$$0$4.Duplex) {
        const offListeners = require$$0$4.finished(data2, () => {
          offListeners();
          onFinished2();
        });
      } else {
        onFinished2();
      }
    });
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      if (config2.maxContentLength > -1) {
        const dataUrl = String(config2.url || fullPath || "");
        const estimated = estimateDataURLDecodedBytes(dataUrl);
        if (estimated > config2.maxContentLength) {
          return reject(new AxiosError$1(
            "maxContentLength size of " + config2.maxContentLength + " exceeded",
            AxiosError$1.ERR_BAD_RESPONSE,
            config2
          ));
        }
      }
      let convertedData;
      if (method !== "GET") {
        return settle(resolve2, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: config2
        });
      }
      try {
        convertedData = fromDataURI(config2.url, responseType === "blob", {
          Blob: config2.env && config2.env.Blob
        });
      } catch (err) {
        throw AxiosError$1.from(err, AxiosError$1.ERR_BAD_REQUEST, config2);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils$1.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = require$$0$4.Readable.from(convertedData);
      }
      return settle(resolve2, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders$2(),
        config: config2
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError$1(
        "Unsupported protocol " + protocol,
        AxiosError$1.ERR_BAD_REQUEST,
        config2
      ));
    }
    const headers = AxiosHeaders$2.from(config2.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION$1, false);
    const { onUploadProgress, onDownloadProgress } = config2;
    const maxRate = config2.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils$1.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream$1(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION$1}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await require$$1$1.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = require$$0$4.Readable.from(readBlob$1(data));
    } else if (data && !utils$1.isStream(data)) {
      if (Buffer.isBuffer(data))
        ;
      else if (utils$1.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$1.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError$1(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError$1.ERR_BAD_REQUEST,
          config2
        ));
      }
      headers.setContentLength(data.length, false);
      if (config2.maxBodyLength > -1 && data.length > config2.maxBodyLength) {
        return reject(new AxiosError$1(
          "Request body larger than maxBodyLength limit",
          AxiosError$1.ERR_BAD_REQUEST,
          config2
        ));
      }
    }
    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
    if (utils$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$1.isStream(data)) {
        data = require$$0$4.Readable.from(data, { objectMode: false });
      }
      data = require$$0$4.pipeline([data, new AxiosTransformStream$1({
        maxRate: utils$1.toFiniteNumber(maxUploadRate)
      })], utils$1.noop);
      onUploadProgress && data.on("progress", flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path2;
    try {
      path2 = buildURL(
        parsed.pathname + parsed.search,
        config2.params,
        config2.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config2;
      customErr.url = config2.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path2,
      method,
      headers: headers.toJSON(),
      agents: { http: config2.httpAgent, https: config2.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {},
      http2Options
    };
    !utils$1.isUndefined(lookup) && (options.lookup = lookup);
    if (config2.socketPath) {
      options.socketPath = config2.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config2.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config2.httpsAgent : config2.httpAgent;
    if (isHttp2) {
      transport = http2Transport;
    } else {
      if (config2.transport) {
        transport = config2.transport;
      } else if (config2.maxRedirects === 0) {
        transport = isHttpsRequest ? require$$8$1 : require$$7$2;
      } else {
        if (config2.maxRedirects) {
          options.maxRedirects = config2.maxRedirects;
        }
        if (config2.beforeRedirect) {
          options.beforeRedirects.config = config2.beforeRedirect;
        }
        transport = isHttpsRequest ? httpsFollow : httpFollow;
      }
    }
    if (config2.maxBodyLength > -1) {
      options.maxBodyLength = config2.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config2.insecureHTTPParser) {
      options.insecureHTTPParser = config2.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams2 = [res];
      const responseLength = utils$1.toFiniteNumber(res.headers["content-length"]);
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream$1({
          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams2.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config2.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams2.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams2.push(new ZlibHeaderTransformStream$1());
            streams2.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams2.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams2.length > 1 ? require$$0$4.pipeline(streams2, utils$1.noop) : streams2[0];
      const response2 = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$2(res.headers),
        config: config2,
        request: lastRequest
      };
      if (responseType === "stream") {
        response2.data = responseStream;
        settle(resolve2, reject, response2);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config2.maxContentLength > -1 && totalResponseBytes > config2.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            abort2(new AxiosError$1(
              "maxContentLength size of " + config2.maxContentLength + " exceeded",
              AxiosError$1.ERR_BAD_RESPONSE,
              config2,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError$1(
            "stream has been aborted",
            AxiosError$1.ERR_BAD_RESPONSE,
            config2,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError$1.from(err, null, config2, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils$1.stripBOM(responseData);
              }
            }
            response2.data = responseData;
          } catch (err) {
            return reject(AxiosError$1.from(err, null, config2, response2.request, response2));
          }
          settle(resolve2, reject, response2);
        });
      }
      abortEmitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    abortEmitter.once("abort", (err) => {
      if (req.close) {
        req.close();
      } else {
        req.destroy(err);
      }
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError$1.from(err, null, config2, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config2.timeout) {
      const timeout2 = parseInt(config2.timeout, 10);
      if (Number.isNaN(timeout2)) {
        abort2(new AxiosError$1(
          "error trying to parse `config.timeout` to int",
          AxiosError$1.ERR_BAD_OPTION_VALUE,
          config2,
          req
        ));
        return;
      }
      req.setTimeout(timeout2, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config2.transitional || transitionalDefaults;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        abort2(new AxiosError$1(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config2,
          req
        ));
      });
    } else {
      req.setTimeout(0);
    }
    if (utils$1.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort2(new CanceledError$1("Request stream has been aborted", config2, req));
        }
      });
      data.pipe(req);
    } else {
      data && req.write(data);
      req.end();
    }
  });
};
const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure, sameSite) {
      if (typeof document === "undefined")
        return;
      const cookie2 = [`${name}=${encodeURIComponent(value)}`];
      if (utils$1.isNumber(expires)) {
        cookie2.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (utils$1.isString(path2)) {
        cookie2.push(`path=${path2}`);
      }
      if (utils$1.isString(domain)) {
        cookie2.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie2.push("secure");
      }
      if (utils$1.isString(sameSite)) {
        cookie2.push(`SameSite=${sameSite}`);
      }
      document.cookie = cookie2.join("; ");
    },
    read(name) {
      if (typeof document === "undefined")
        return null;
      const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
      return match ? decodeURIComponent(match[1]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
const headersToObject = (thing) => thing instanceof AxiosHeaders$2 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source2, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source2)) {
      return utils$1.merge.call({ caseless }, target, source2);
    } else if (utils$1.isPlainObject(source2)) {
      return utils$1.merge({}, source2);
    } else if (utils$1.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap2 = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap2[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const resolveConfig = (config2) => {
  const newConfig = mergeConfig$1({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$2.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils$1.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$2.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders$2.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response2 = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response2);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config2, request2);
      err.event = event || null;
      reject(err);
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};
const composeSignals = (signals, timeout2) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout2 || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer2 = timeout2 && setTimeout(() => {
      timer2 = null;
      onabort(new AxiosError$1(`timeout ${timeout2} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout2);
    const unsubscribe = () => {
      if (signals) {
        timer2 && clearTimeout(timer2);
        timer2 = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
const composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream2) {
  if (stream2[Symbol.asyncIterator]) {
    yield* stream2;
    return;
  }
  const reader = stream2.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream2, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream2, chunkSize);
  let bytes2 = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const { isFunction } = utils$1;
const globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils$1.global);
const {
  ReadableStream: ReadableStream$1,
  TextEncoder: TextEncoder$1
} = utils$1.global;
const test = (fn, ...args2) => {
  try {
    return !!fn(...args2);
  } catch (e) {
    return false;
  }
};
const factory = (env2) => {
  env2 = utils$1.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env2);
  const { fetch: envFetch, Request, Response } = env2;
  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction(Request);
  const isResponseSupported = isFunction(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
  const encodeText = isFetchSupported && (typeof TextEncoder$1 === "function" ? ((encoder2) => (str) => encoder2.encode(str))(new TextEncoder$1()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream$1(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
      !resolvers[type2] && (resolvers[type2] = (res, config2) => {
        let method = res && res[type2];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError$1(`Response type '${type2}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config2);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$1.isBlob(body)) {
      return body.size;
    }
    if (utils$1.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$1.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$1.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$1.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config2) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout: timeout2,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config2);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout2);
    let request2 = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$1.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request2 = isRequestSupported && new Request(url2, resolvedOptions);
      let response2 = await (isRequestSupported ? _fetch(request2, fetchOptions) : _fetch(url2, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response2[prop];
        });
        const responseContentLength = utils$1.toFiniteNumber(response2.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response2 = new Response(
          trackStream(response2.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response2, config2);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve2, reject) => {
        settle(resolve2, reject, {
          data: responseData,
          headers: AxiosHeaders$2.from(response2.headers),
          status: response2.status,
          statusText: response2.statusText,
          config: config2,
          request: request2
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request2),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError$1.from(err, err && err.code, config2, request2);
    }
  };
};
const seedCache = /* @__PURE__ */ new Map();
const getFetch = (config2) => {
  let env2 = config2 && config2.env || {};
  const { fetch: fetch2, Request, Response } = env2;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i = len, seed, target, map2 = seedCache;
  while (i--) {
    seed = seeds[i];
    target = map2.get(seed);
    target === void 0 && map2.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env2));
    map2 = target;
  }
  return target;
};
getFetch();
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: {
    get: getFetch
  }
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
function getAdapter$1(adapters2, config2) {
  adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
  const { length } = adapters2;
  let nameOrAdapter;
  let adapter;
  const rejectedReasons = {};
  for (let i = 0; i < length; i++) {
    nameOrAdapter = adapters2[i];
    let id2;
    adapter = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
      if (adapter === void 0) {
        throw new AxiosError$1(`Unknown adapter '${id2}'`);
      }
    }
    if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config2)))) {
      break;
    }
    rejectedReasons[id2 || "#" + i] = adapter;
  }
  if (!adapter) {
    const reasons = Object.entries(rejectedReasons).map(
      ([id2, state2]) => `adapter ${id2} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
    );
    let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError$1(
      `There is no suitable adapter to dispatch the request ` + s,
      "ERR_NOT_SUPPORT"
    );
  }
  return adapter;
}
const adapters = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter: getAdapter$1,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError$1(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$2.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter, config2);
  return adapter(config2).then(function onAdapterResolution(response2) {
    throwIfCancellationRequested(config2);
    response2.data = transformData.call(
      config2,
      config2.transformResponse,
      response2
    );
    response2.headers = AxiosHeaders$2.from(response2.headers);
    return response2;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$2.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig$1(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0)
      ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config2, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$2.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig$1(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$2 = Axios$1;
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort2 = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort2);
    controller.signal.unsubscribe = () => this.unsubscribe(abort2);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
const CancelToken$2 = CancelToken$1;
function spread$1(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
const HttpStatusCode$2 = HttpStatusCode$1;
function createInstance(defaultConfig) {
  const context = new Axios$2(defaultConfig);
  const instance = bind2(Axios$2.prototype.request, context);
  utils$1.extend(instance, Axios$2.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$2;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$2;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$2;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$2;
axios.default = axios;
const axios$1 = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError: CanceledError2,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios$1;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators2, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators2.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators2[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
let HttpService = class {
  constructor(configService2) {
    this.configService = configService2;
  }
  async sendData(data) {
    try {
      const httpConfig = this.configService.getHttpConfig();
      if (!httpConfig.url) {
        this.sendLog("error", "HTTP URL ");
        return;
      }
      this.sendLog("http", ` ${httpConfig.url}...`);
      const payload = {
        data_raw: data.toString("hex"),
        timestamp: Date.now()
      };
      const response2 = await axios$1.post(httpConfig.url, payload, {
        timeout: 5e3,
        headers: {
          "Content-Type": "application/json"
        }
      });
      this.sendLog("success", `HTTP POST  (${response2.status} ${response2.statusText})`);
    } catch (error2) {
      if (error2 instanceof AxiosError) {
        const status = error2.response?.status;
        const statusText = error2.response?.statusText || error2.message;
        this.sendLog("error", `HTTP POST : ${status || ""} ${statusText}`);
      } else {
        this.sendLog("error", `HTTP POST : ${error2.message}`);
      }
    }
  }
  sendLog(type2, message) {
    if (exports.mainWindow) {
      exports.mainWindow.webContents.send("new-log-entry", {
        type: type2,
        message,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  }
};
HttpService = __decorateClass$1([
  commonExports.Injectable()
], HttpService);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators2, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators2.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators2[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
let AppModule = class {
};
AppModule = __decorateClass([
  commonExports.Module({
    imports: [],
    controllers: [],
    providers: [
      ConfigService,
      SerialPortService,
      HttpService
    ],
    exports: [
      ConfigService,
      SerialPortService,
      HttpService
    ]
  })
], AppModule);
let serialPortService = null;
let configService = null;
async function initializeIpcHandlers() {
  if (exports.nestApp) {
    serialPortService = exports.nestApp.get(SerialPortService);
    configService = exports.nestApp.get(ConfigService);
    registerIpcHandlers();
  }
}
function registerIpcHandlers() {
  require$$1$5.ipcMain.handle("get-ports", async () => {
    if (serialPortService) {
      return await serialPortService.listPorts();
    }
    return [];
  });
  require$$1$5.ipcMain.handle("get-config", () => {
    if (configService) {
      return configService.getConfig();
    }
    return {};
  });
  require$$1$5.ipcMain.handle("set-config", (_event, config2) => {
    if (configService) {
      configService.setConfig(config2);
      return true;
    }
    return false;
  });
  require$$1$5.ipcMain.handle("connect", async () => {
    if (serialPortService) {
      return await serialPortService.connect();
    }
    return false;
  });
  require$$1$5.ipcMain.handle("disconnect", async () => {
    if (serialPortService) {
      await serialPortService.disconnect();
      return true;
    }
    return false;
  });
}
exports.mainWindow = null;
exports.nestApp = null;
function createWindow() {
  exports.mainWindow = new require$$1$5.BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: require$$0$6.join(__dirname, "../preload/index.js"),
      nodeIntegration: false,
      contextIsolation: true
    }
  });
  if (process.env.NODE_ENV === "development") {
    exports.mainWindow.loadURL(process.env.VITE_DEV_SERVER_URL + "index.html");
    exports.mainWindow.webContents.openDevTools();
  } else {
    exports.mainWindow.loadFile(require$$0$6.join(__dirname, "../renderer/index.html"));
  }
  exports.mainWindow.on("closed", () => {
    exports.mainWindow = null;
  });
}
async function bootstrapNestJS() {
  try {
    exports.nestApp = await core$d.NestFactory.createApplicationContext(AppModule);
    console.log("NestJS application initialized");
    return exports.nestApp;
  } catch (error2) {
    console.error("Failed to initialize NestJS application:", error2);
  }
}
require$$1$5.app.whenReady().then(async () => {
  await bootstrapNestJS();
  await initializeIpcHandlers();
  createWindow();
  require$$1$5.app.on("activate", () => {
    if (require$$1$5.BrowserWindow.getAllWindows().length === 0)
      createWindow();
  });
});
require$$1$5.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$1$5.app.quit();
  }
});
require$$1$5.app.on("before-quit", () => {
  if (exports.nestApp) {
    exports.nestApp.close();
  }
});
